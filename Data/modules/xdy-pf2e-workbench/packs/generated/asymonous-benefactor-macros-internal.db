{"_id":"0CUig93jQfuqCu2K","actorIds":[],"author":"nWU4cIKCOl1dcEUB","command":"/* Based on a macro by Author: ArthurTrumpet and Symon S.\ncreated by darkim\n\nAncestral Memories Macro\n This Macro gives you an easy way to add a new Ancestral Memories effect for a chosen skill to actors.\n Choose the desired skill and it will be applied to the selected actor.\n*/\n\nif (canvas.tokens.controlled.length !== 1){\n  ui.notifications.warn('You need to select exactly one token to cast Ancestral Memories.');\n} else \n{\n\nconst effect = {\n    type: 'effect',\n    name: 'Ancestral Memories',\n    img: 'systems/pf2e/icons/spells/ancestral-memories.webp',\n    system: {\n      tokenIcon: {\n          show: true\n      },       \n      duration: {\n          value: 1,\n          unit: 'minutes',\n          sustained: false,\n          expiry: 'turn-start'\n      },\n      rules: [\n        {\n            key: 'ActiveEffectLike',\n            mode: 'override',\n            path: 'system.skills.acr.rank',\n            value: {\n                brackets: [\n                    {\n                        end: 10,\n                        start: 1,\n                        value: 1,\n                    },\n                    {\n                        start: 11,\n                        value: 2,\n                    },\n                ],\n            },\n            slug: null,\n            priority: 100,\n            ignored: false,\n            predicate: [],\n            phase: 'applyAEs',\n        },\n      ],\n    },\n  };\n\nconst SKILL_OPTIONS = [\n  {value: \"acr\", name: \"Acrobatics\"},\n  {value: \"arc\", name: \"Arcana\"},\n  {value: \"ath\", name: \"Athletics\"},\n  {value: \"cra\", name: \"Crafting\"},\n  {value: \"dec\", name: \"Deception\"},\n  {value: \"dip\", name: \"Diplomacy\"},\n  {value: \"itm\", name: \"Intimidation\"},\n  {value: \"med\", name: \"Medicine\"},\n  {value: \"nat\", name: \"Nature\"},\n  {value: \"occ\", name: \"Occultism\"},\n  {value: \"prf\", name: \"Performance\"},\n  {value: \"rel\", name: \"Religion\"},\n  {value: \"soc\", name: \"Society\"},\n  {value: \"ste\", name: \"Stealth\"},\n  {value: \"sur\", name: \"Survival\"},\n  {value: \"thi\", name: \"Thievery\"},\n];\n\ncountdownEffect();\n\nfunction countdownEffect() {\n\n  let skills = '';\n  SKILL_OPTIONS.forEach(u => { skills += `<option value=\"${u.value}\">${u.name}</option>`; });\n  let template = `\n  <p>\n    Select a skill to gain proficiency in: <select id=\"selected_skill\">${skills}</select>\n  </p>\n  `;\n\n  new Dialog({\n    title: \"Ancestral Memories\",\n    content: template,\n    buttons: {\n      ok: {\n        label: \"Apply\",\n        callback: (html) => {\n          main(html);\n        },\n      },\n      cancel: {\n        label: \"Cancel\",\n      },\n    },\n  }).render(true);\n}\n\nasync function main(html) {\n\n    const skill = html.find(\"#selected_skill\")[0].value;\n    let selected_skill = SKILL_OPTIONS.filter(result => {\n      return result.value === skill;\n    })[0];\n    effect.name = effect.name + \" (\" + selected_skill.name + \")\";\n\n    effect.system.rules[0].path = \"system.skills.\" + skill + \".rank\";\n\n    await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n}\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Ancestral Memories.js\" - Fetched on 2024-06-05T17:22:21.774Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Ancestral Memories","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"1q1yIamDiJOgDah6","actorIds":[],"author":"EkjiZmuHtbeVWzat","command":"//Ooze Split Extended, by esheyw, last updated 05 Dec 2023\n//creates duplicate ooze token in the space of the original. \n//automatically adds new token to tracker and rolls initiative if combat exists\n//moving the generated token is left to the GM\n//special handling for Pyronite Oozes (they get an effect applied forcing them to be Medium)\n//only large Pyro oozes can split.\n\nif (canvas.tokens.controlled.length !== 1) return ui.notifications.error(\"Please select only a single token.\");\nif (!actor.traits.has('ooze')) return ui.notifications.error(\"Selected token is not an ooze.\");\nconst PYROSOURCE = 'Compendium.pf2e.outlaws-of-alkenstar-bestiary.Actor.aT6c5oEPV8U5zfRD';\nif (actor.sourceId === PYROSOURCE && actor.size !== 'lg') return ui.notifications.error(`Only large Pyronite Oozes split.`);\nconst splitAbility = actor.itemTypes.action.find(a=>a.name.includes('Split'));\nif (!splitAbility) return ui.notifications.error(`Selected ooze does not have a Split ability.`);\nlet sT = splitAbility.system.description.value.match(/(\\d+) or more HP/);\nif (!sT) sT = splitAbility.system.description.value.match(/at least (\\d+) HP/);\nif (!sT) ui.notifications.info(`Couldn't extract split threshold, defaulting to 10.`);\nsT = parseInt(sT[1] ?? 10,10);\n\nif (actor.hitPoints.value < sT) return ui.notifications.error(\"Selected ooze is too damaged to split.\");\nawait actor.update({\"system.attributes.hp.value\": Math.floor(actor.hitPoints.value/2)});\nconst [created] = await canvas.scene.createEmbeddedDocuments(\"Token\",[token.document.toObject()])\n\nif (actor.sourceId === PYROSOURCE) {\n  await splitAbility.toMessage(undefined, {rollMode:CONST.DICE_ROLL_MODES.BLIND});\n  const effectString = `{\"name\":\"Split Pyronite Ooze\",\"type\":\"effect\",\"system\":{\"rules\":[{\"key\":\"CreatureSize\",\"value\":\"medium\"}],\"level\":{\"value\":1},\"duration\":{\"value\":-1,\"unit\":\"unlimited\",\"expiry\":null,\"sustained\":false},\"tokenIcon\":{\"show\":true}},\"img\":\"systems/pf2e/icons/default-icons/alternatives/ancestries/halfling.svg\"}`;\n  const effectData = JSON.parse(effectString);\n  await actor.createEmbeddedDocuments(\"Item\", [effectData]);\n  await created.actor.createEmbeddedDocuments(\"Item\", [effectData]);\n}\nif (game.combat && token.inCombat) await created.actor.rollInitiative({createCombatants:true});\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Ooze Split.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Ooze Split","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"1x7nhCK3Z55p5pDE","actorIds":[],"author":"c6uF0m19NmufPN4m","command":"/*\nScare to Death\nThis macro will make an intimidation check vs the target.\n\nThis Macro works just like the system's Demoralize macro, except for the following additions:\n* Check if the actor has the skill\n* Link the 1 minutes Scare to Death immunity\n* Check if the target is immune\n* Check the 30ft range limit\n* -4 if no Language is shared\n\nLimitations:\n* Does not handle assurance.\n* Does not handle NOTES\n\ncreated with the help of demoralize macro written by darkium\n*/\n\n/**\n* Wrapper for the DSN Hook. It will only use the hook if the non-buggy setting is not enabled.\n*\n* @param {Object} code code which will be executed\n*/\nfunction dsnHook(code) {\n    if (game.modules.get(\"dice-so-nice\")?.active && !game.settings.get(\"dice-so-nice\", \"immediatelyDisplayChatMessages\") && !game.modules.get(\"df-manual-rolls\")?.active) {\n      Hooks.once('diceSoNiceRollComplete', code);\n    } else {\n      code();\n    }\n  }\n\nif (!token.actor.itemTypes.feat.some(ms => ms.slug === \"scare-to-death\")) { return ui.notifications.warn(\"The actor does not possess a Scare to Death feat\"); }\nif (canvas.tokens.controlled.length !== 1){\n    ui.notifications.warn('You need to select exactly one token to perform Scare to Death.');\n} else if (game.user.targets.size < 1){\n    ui.notifications.warn(`You must target at least one token.`);\n} else {\n    const skillName = \"Intimidation\";\n    const skillKey = \"intimidation\";\n    const actionSlug = \"scare-to-death\"\n    const actionName = \"Scare to Death\"\n    \n    const modifiers = []\n\n    // notes are not working for the roll currently. \n    // const notes = [...token.actor.system.skills[skillKey].notes]; // add more notes if necessary\n    const notes = [];\n\n    const options = actor.getRollOptions(['all', 'skill-check', 'action:' + actionSlug]);\n    const traits = ['general', 'emotion', 'fear', 'incapacitation', 'skill'];\n    traits.forEach(traits => {\n        options.push(traits);\n    });\n    //adding the auditory trait as you are speaking out loud to get the effect    \n    options.push(`auditory`);\n\n    const languages = token.actor.system.traits.languages.value;\n\n    const immunityEffect = {\n        type: 'effect',\n        name: 'Scare to Death Immunity',\n        img: 'systems/pf2e/icons/spells/blind-ambition.webp',\n        system: {\n          tokenIcon: {\n              show: true\n          },       \n          duration: {\n              value: '10',\n              unit: 'rounds',\n              sustained: false,\n              expiry: 'turn-start'\n          },\n          rules: [],\n        },\n      };\n\n    const alwaysShowName = !game.settings.get(\"pf2e\", \"metagame_tokenSetsNameVisibility\");\n    for(let target of game.user.targets){\n        let targetActor = target.actor;\n        const showName = alwaysShowName || target.document.playersCanSeeName;\n\n        const nameForNotifications = showName ? target.name : 'Unknown';\n        const nameForChatMessage = showName ? target.name : `Unknown <span data-visibility=\"gm\">(${target.name})</span>`;\n\n        let distance = token.distanceTo(target);\n\n        if (distance > 30) {\n            ui.notifications.warn(`${nameForNotifications} is out of range.`);\n            continue;\n        } else {\n\n            const targetLanguages = targetActor.system.traits.languages.value;\n            if (!targetLanguages.some((lang) => languages.includes(lang))) {\n                langMod = new game.pf2e.Modifier({ label: \"Language barrier\", modifier: -4, type: \"circumstance\" })\n                modifiers.push(langMod);\n            }\n\n            immunityEffect.name = `${actionName} by ${token.name}`;\n            console.log(immunityEffect.name);\n\n            // check if the person being demoralized is currently immune.\n            var isImmune = targetActor.itemTypes.effect.find(obj => {\n                return obj.name === immunityEffect.name\n            });\n            if (isImmune) {\n                ui.notifications.warn(nameForNotifications + ` is currently immune to ${actionName} by ` + token.name);\n                continue;\n            }\n\n            if (game.modules.has('xdy-pf2e-workbench') && game.modules.get('xdy-pf2e-workbench').active) { \n                // Extract the Macro ID from the asynomous benefactor macro compendium.\n                const macroName = `StD Immunity CD`;\n                const macroId = (await game.packs.get('xdy-pf2e-workbench.asymonous-benefactor-macros')).index.find(n => n.name === macroName)?._id;\n                immunityMacroLink = `@Compendium[xdy-pf2e-workbench.asymonous-benefactor-macros.${macroId}]{Click to apply all effects}`\n            } else {\n                ui.notifications.warn(`Workbench Module not active! Linking Immunity effect Macro not possible.`);\n            }\n            const immunityMessage = `is now immune to ${immunityEffect.name} for ${immunityEffect.system.duration.value} ${immunityEffect.system.duration.unit}.<br>${immunityMacroLink}`;\n            const targetWillDC = targetActor.system.saves.will.dc;\n            \n            // -----------------------\n\n            game.pf2e.Check.roll(\n                new game.pf2e.CheckModifier(\n                    `<span class=\"pf2-icon\">A</span> <b>${actionName}</b> - <p class=\"compact-text\">${skillName} Skill Check</p>`,\n                    token.actor.skills[skillKey], modifiers),\n                { actor: token.actor, type: 'skill-check', options, notes, dc: { value: targetWillDC } }, //for DC insert: , dc: {value: 30}\n                event,\n                async (roll) => {\n                    if (roll.degreeOfSuccess === 3) {\n                        // crit success message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Critical Success</strong><br> <strong>${nameForChatMessage}</strong> must make a @Check[type:fortitude|dc:resolve(@actor.skills.intimidation.dc.value)|traits:death,incapacitation], on a critical failure it dies. Otherwise it becomes @UUID[Compendium.pf2e.conditionitems.Item.TBSHQspnbcqxsmjL]{Frightened 2} and is @UUID[Compendium.pf2e.conditionitems.Item.sDPxOjQ9kx2RZE8D]{Fleeing} for 1 round; it suffers no effect on a critical success. <strong>${nameForChatMessage}</strong> ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"scaretodeath\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        stdId: token.actor.id,\n                                        stdName: token.name,\n                                        fleeing: true\n                                    }\n                                }\n                            });\n                        });\n                    } else if (roll.degreeOfSuccess === 2) {\n                        // success message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Success</strong><br> <strong>${nameForChatMessage}</strong> becomes @UUID[Compendium.pf2e.conditionitems.TBSHQspnbcqxsmjL]{Frightened 2} and ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"scaretodeath\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        stdId: token.actor.id,\n                                        stdName: token.name,\n                                    }\n                                }\n                            });\n                        });\n                    } else if (roll.degreeOfSuccess === 1) {\n                        // Fail message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Success</strong><br> <strong>${nameForChatMessage}</strong> becomes @UUID[Compendium.pf2e.conditionitems.TBSHQspnbcqxsmjL]{Frightened 1} and ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"scaretodeath\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        stdId: token.actor.id,\n                                        stdName: token.name,\n                                    }\n                                }\n                            });\n                        });\n                    } else if (roll.degreeOfSuccess === 0) {\n                        // crit fail \n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Critical Failure</strong><br>You fail to scare ${nameForChatMessage} to death and nothing happens. <strong>${nameForChatMessage}</strong> ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"scaretodeath\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        stdId: token.actor.id,\n                                        stdName: token.name,\n                                    }\n                                }\n                            });\n                        });\n                    }\n                },\n            );\n        }\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Scare to Death.js\" - Fetched on 2024-06-05T17:22:21.778Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Scare to Death","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"372msw2q3BlkTCFn","actorIds":[],"author":"Um5aOXzrw9PWcizK","command":"/*Author ArthurTrumpet\n This Macro gives you an easy way to add new named cooldown effects to actors.\n Enter your desired duration in either a numerical value or a roll, like 1d4(default).\n*/\n\nconst current = this.img;\nconsole.log(current);\nfunction onRender(html) {\n    html.find(\"#some-id\").click((event) => someFunction(event, html));\n}\n\nconst effect = {\n    type: \"effect\",\n    name: \"Countdown\",\n    img: this.img,\n    data: {\n        tokenIcon: {\n            show: true,\n        },\n        duration: {\n            value: 1,\n            unit: \"rounds\",\n            sustained: false,\n            expiry: \"turn-start\",\n        },\n    },\n};\n\nfunction someFunction(event, html) {\n    const fp = new FilePicker({\n        type: \"image\",\n        current: current,\n        button: \"image-picker\",\n        callback: (url) => {\n            html.find(\"#imagepath\").val(url);\n        },\n    });\n    fp.browse();\n}\n\ntestFunction();\n\nfunction testFunction() {\n    const unitsn = [\n        { value: \"rounds\", name: \"Rounds\" },\n        { value: \"minutes\", name: \"Minutes\" },\n        { value: \"hours\", name: \"Hours\" },\n        { value: \"days\", name: \"Days\" },\n    ];\n    let units = \"\";\n    unitsn.forEach((u) => {\n        units += `<option value=\"${u.value}\">${u.name}</option>`;\n    });\n\n    let template = `\n  <p>\n    Duration: <input id=\"countdowninput\" type=\"string\" style=\"width: 50px;\" value=\"1d4\">\n  </p>\n  <p>\n    Units: <select id=\"countdownunits\">${units}</select>\n  </p>\n  <p>\n    Name: <input id=\"countdownname\" type=\"string\" style=\"width: 100px;\" value=\"Countdown\">\n  </p> \n  <p>\n    <input type=\"checkbox\" id=\"cooldown\"/>\n    Cooldown (adds 1 to duration)\n  </p>\n <form>\n <div class=\"form-group\">\n   <label>Image:</label>\n   <div class=\"form-fields\">\n     <input type=\"text\" id=\"imagepath\" name=\"imagepath\" value=\"\">\n     <button id=\"some-id\" type=\"button\"><i class=\"fas fa-file-import fa-fw\"></i></button>\n   </div>\n </div>\n </form>\n  `;\n\n    new Dialog({\n        title: \"Example\",\n        content: template,\n        buttons: {\n            ok: {\n                label: \"Apply\",\n                callback: (html) => {\n                    main(html);\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n            },\n        },\n        render: onRender,\n    }).render(true);\n}\n\nasync function main(html) {\n    let duration = html.find(\"#countdowninput\")[0].value;\n    const unit = html.find(\"#countdownunits\")[0].value;\n    const isCooldown = html.find(\"#cooldown\")[0].checked;\n    effect.name = html.find(\"#countdownname\")[0].value;\n    let countdownNumber = \"\";\n    let customImage = html.find(\"#imagepath\")[0].value;\n    if (duration.includes(\"d\")) {\n        countdownNumber = new Roll(duration).roll({ async: false }).total;\n    } else {\n        countdownNumber = duration;\n    }\n    if (isCooldown) {\n        countdownNumber = parseInt(countdownNumber) + 1;\n    }\n    if (customImage) {\n        effect.img = customImage;\n    }\n    effect.data.duration.unit = unit;\n    effect.data.duration.value = countdownNumber;\n    await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Countdown-Cooldown.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Countdown-Cooldown","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"3HTtPtHnWRkUjFty","actorIds":[],"author":"jMOiM5L9KUbr4LN2","command":"/*\nSimple Macro that makes it look like the token is falling\n*/\n\nconst height = await Dialog.wait({\n    title: \"Simulate Falling\",\n    content: `<table><tr><th>Height to set?</th> <th><input type=\"number\" autofocus onfocus=\"this.select()\" value=0></th></tr></table>`,\n    buttons: {\n        ok: {\n            icon: '<i class=\"fa-solid fa-person-falling\"></i>',\n            label: \"Fall\",\n            callback: (html) => {\n                return html[0].querySelector(\"input\").value;\n            }\n        },\n        cancel: {\n            label: \"Cancel\",\n        }\n    },\n    close: () => { return \"cancel\" },\n    default: \"ok\",\n},{width:300});\n\nif (height === \"cancel\") { return }\n\nfor (const t of canvas.tokens.controlled) {\n    const proto = t.actor.prototypeToken.texture;\n    const isReduced = t.document.texture.scaleX !== proto.scaleX;\n    const isLinked = t.actor.prototypeToken.flags.pf2e.linkToActorSize;\n    if (!isReduced && isLinked) {\n        await t.document.setFlag(\"pf2e\",\"linkToActorSize\",false);\n    }\n    if (isReduced && isLinked) {\n        await t.document.setFlag(\"pf2e\",\"linkToActorSize\",true)\n    }\n\n    await t.document.update({\n        \"texture.scaleX\": isReduced ? proto.scaleX : (proto.scaleX * 0.6),\n        \"texture.scaleY\": isReduced ? proto.scaleY : (proto.scaleY * 0.6),\n        alpha: isReduced ? 1 : 0.3,\n        elevation: parseInt(height)\n    });\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Simulate Falling.js\" - Fetched on 2024-06-05T17:22:21.771Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Simulate Falling","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"6FNluoqJQnRcGP88","actorIds":[],"author":"Hk3Rk4dRKshFwcvs","command":"/*\nEvangelize\nThis macro will make an diplomacy check vs the target.\n\nThis Macro works similar the system's Demoralize macro, except for the following additions:\n* Check if the actor has the skill\n* Link the 24 hours Evangelize immunity\n* Check if the target is immune\n* Immune if no Language is shared\n\nLimitations:\n* Does not handle assurance.\n* Does not handle NOTES\n\ncreated with the help of demoralize macro written by darkium\n*/\n\n/**\n* Wrapper for the DSN Hook. It will only use the hook if the non-buggy setting is not enabled.\n*\n* @param {Object} code code which will be executed\n*/\nfunction dsnHook(code) {\n    if (game.modules.get(\"dice-so-nice\")?.active && !game.settings.get(\"dice-so-nice\", \"immediatelyDisplayChatMessages\") && !game.modules.get(\"df-manual-rolls\")?.active) {\n      Hooks.once('diceSoNiceRollComplete', code);\n    } else {\n      code();\n    }\n  }\n\nif (!token.actor.itemTypes.feat.some(ms => ms.slug === \"evangelize\")) { return ui.notifications.warn(\"The actor does not possess the Evangelize feat\"); }\nif (canvas.tokens.controlled.length !== 1){\n    ui.notifications.warn('You need to select exactly one token to perform Evangelize.');\n} else if (game.user.targets.size < 1){\n    ui.notifications.warn(`You must target at least one token.`);\n} else {\n    const skillName = \"Diplomacy\";\n    const skillKey = \"diplomacy\";\n    const actionSlug = \"evangelize\"\n    const actionName = \"Evangelize\"\n    \n    const modifiers = []\n\n    // notes are not working for the roll currently. \n    // const notes = [...token.actor.system.skills[skillKey].notes]; // add more notes if necessary\n    const notes = [];\n\n    const options = actor.getRollOptions(['all', 'skill-check', 'action:' + actionSlug]);\n    const traits = ['auditory', 'general', 'linguistic', 'mental', 'skill'];\n    traits.forEach(traits => {\n        options.push(traits);\n    });\n\n    const languages = token.actor.system.traits.languages.value;\n\n    const immunityEffect = {\n        type: 'effect',\n        name: 'Evangelize Immunity',\n        img: 'systems/pf2e/icons/spells/blind-ambition.webp',\n        system: {\n          tokenIcon: {\n              show: true\n          },       \n          duration: {\n              value: '24',\n              unit: 'hours',\n              sustained: false,\n              expiry: 'turn-start'\n          },\n          rules: [],\n        },\n      };\n\n    const alwaysShowName = !game.settings.get(\"pf2e\", \"metagame_tokenSetsNameVisibility\");\n    for(let target of game.user.targets){\n        let targetActor = target.actor;\n        const showName = alwaysShowName || target.document.playersCanSeeName;\n\n        const nameForNotifications = showName ? target.name : 'Unknown';\n        const nameForChatMessage = showName ? target.name : `Unknown <span data-visibility=\"gm\">(${target.name})</span>`;\n\n        const targetLanguages = targetActor.system.traits.languages.value;\n        if (!targetLanguages.some((lang) => languages.includes(lang))) {\n            ui.notifications.warn(`${nameForNotifications} doesn't understand your language.`);\n            continue;\n        } else {\n\n            immunityEffect.name = `${actionName} by ${token.name}`;\n            console.log(immunityEffect.name);\n\n            // check if the person being evangelized is currently immune.\n            var isImmune = targetActor.itemTypes.effect.find(obj => {\n                return obj.name === immunityEffect.name\n            });\n            if (isImmune) {\n                ui.notifications.warn(nameForNotifications + ` is currently immune to ${actionName} by ` + token.name);\n                continue;\n            }\n\n            if (game.modules.has('xdy-pf2e-workbench') && game.modules.get('xdy-pf2e-workbench').active) { \n                // Extract the Macro ID from the asynomous benefactor macro compendium.\n                const macroName = `Evangelize Immunity CD`;\n                const macroId = (await game.packs.get('xdy-pf2e-workbench.asymonous-benefactor-macros')).index.find(n => n.name === macroName)?._id;\n                immunityMacroLink = `@Compendium[xdy-pf2e-workbench.asymonous-benefactor-macros.${macroId}]{Click to apply all effects}`\n            } else {\n                ui.notifications.warn(`Workbench Module not active! Linking Immunity effect Macro not possible.`);\n            }\n            const immunityMessage = `is now immune to ${immunityEffect.name} for ${immunityEffect.system.duration.value} ${immunityEffect.system.duration.unit}.<br>${immunityMacroLink}`;\n            const targetWillDC = targetActor.system.saves.will.dc;\n            \n            // -----------------------\n\n            game.pf2e.Check.roll(\n                new game.pf2e.CheckModifier(\n                    `<span class=\"pf2-icon\">A</span> <b>${actionName}</b> - <p class=\"compact-text\">${skillName} Skill Check</p>`,\n                    token.actor.skills[skillKey], modifiers),\n                { actor: token.actor, type: 'skill-check', options, notes, dc: { value: targetWillDC } }, //for DC insert: , dc: {value: 30}\n                event,\n                async (roll) => {\n                    if (roll.degreeOfSuccess === 3) {\n                        // crit success message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Critical Success</strong><br> <strong>${nameForChatMessage}</strong> becomes @UUID[Compendium.pf2e.conditionitems.Item.e1XGnhKNSQIm5IXg]{Stupefied 2} for 1 round and ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"evangelize\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        evangelizeId: token.actor.id,\n                                        evangelizeName: token.name,\n                                        fleeing: true\n                                    }\n                                }\n                            });\n                        });\n                    } else if (roll.degreeOfSuccess === 2) {\n                        // success message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Success</strong><br> <strong>${nameForChatMessage}</strong> becomes @UUID[Compendium.pf2e.conditionitems.Item.e1XGnhKNSQIm5IXg]{Stupefied 2} for 1 round and ${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"evangelize\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        evangelizeId: token.actor.id,\n                                        evangelizeName: token.name,\n                                    }\n                                }\n                            });\n                        });\n                    } else if (roll.degreeOfSuccess === 1 || roll.degreeOfSuccess === 0) {\n                        // Fail message\n                        dsnHook(() => {\n                            ChatMessage.create({\n                                user: game.user.id,\n                                type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                                flavor: `<strong>Success</strong><br> <strong>${nameForChatMessage}</strong> is unaffected.${immunityMessage}`,\n                                speaker: ChatMessage.getSpeaker(),\n                                flags: {\n                                    \"evangelize\": {\n                                        id: target.id,\n                                        dos: roll.degreeOfSuccess,\n                                        evangelizeId: token.actor.id,\n                                        evangelizeName: token.name,\n                                    }\n                                }\n                            });\n                        });\n                    }\n                },\n            );\n        }\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Evangelize.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Evangelize","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"76y3bC3Wekr8l9Er","actorIds":[],"author":"Ba76cJVVcxqPEnWU","command":"/*\nBased on the macro Contributed by ArthurTrumpet\nmodified by darkim\n\nUses the a new effect to track who has demoralized whom.\nImmunity duration is set depending on several factors. Default is 10 minutes. \n\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst stdEffect = {\n    type: 'effect',\n    name: 'Scare to Death Immunity',\n    img: 'systems/pf2e/icons/spells/blind-ambition.webp',\n    system: {\n      tokenIcon: {\n          show: true\n      },       \n      duration: {\n          value: 10,\n          unit: 'rounds',\n          sustained: false,\n          expiry: 'turn-start'\n      },\n      rules: [],\n    },\n  };\n\n\nif (!token) {\n    ui.notifications.error(\"No token selected!\");\n} else {\n    main();\n}\n\nasync function main() {\n    const message = game.messages.contents.reverse().find( m => m.flags.scaretodeath?.id === token.id);\n    if (message === undefined) {\n        ui.notifications.info(\"Wrong token selected!\");\n    } else {\n        const applicator = game.actors.get(message.flags.scaretodeath.stdId);\n\n        stdEffect.name = `Scare to Death by ${message.flags.scaretodeath.stdName}`;\n        stdEffect.img = applicator.prototypeToken.texture.src;\n\n        if ( message.flags.scaretodeath.dos == 3 ) {\n            if (!token.actor.hasCondition(\"frightened\") ) {\n                await token.actor.toggleCondition(\"frightened\");\n            }\n            if (token.actor.getCondition(\"frightened\").value < 2 ) {\n                await token.actor.increaseCondition(\"frightened\");\n            }\n            if (message.flags.scaretodeath.fleeing && !token.actor.hasCondition(\"fleeing\")) { \n                await token.actor.toggleCondition(\"fleeing\");\n            }\n        } else if (message.flags.scaretodeath.dos == 2) {\n            if (!token.actor.hasCondition(\"frightened\") ) {\n                await token.actor.toggleCondition(\"frightened\");\n            }\n            if (token.actor.getCondition(\"frightened\").value < 2 ) {\n                await token.actor.increaseCondition(\"frightened\");\n            }\n        } else if (message.flags.scaretodeath.dos == 1) {\n            if (!token.actor.hasCondition(\"frightened\") ) { \n                await token.actor.toggleCondition(\"frightened\");\n            }\n        }\n\n        await token.actor.createEmbeddedDocuments(\"Item\", [stdEffect]);\n        ui.notifications.info(`${token.name} is now immune to Scare to Death by ${message.flags.scaretodeath.stdName}`);\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/StD Immunity CD.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT StD Immunity CD","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"8C5XwDebc5ao0OoH","actorIds":[],"author":"VABu2AGl7KIpHr2k","command":"/*\nThis will generate all scrolls from the inputted criteria and place them into a generated(if not already generated) loot actor,\nan existing loot actor, or in a party actor.\n*/\n\nconst stuff = [];\nconst scrollUuids = {\n  1: 'Compendium.pf2e.equipment-srd.Item.RjuupS9xyXDLgyIr',\n  2: 'Compendium.pf2e.equipment-srd.Item.Y7UD64foDbDMV9sx',\n  3: 'Compendium.pf2e.equipment-srd.Item.ZmefGBXGJF3CFDbn',\n  4: 'Compendium.pf2e.equipment-srd.Item.QSQZJ5BC3DeHv153',\n  5: 'Compendium.pf2e.equipment-srd.Item.tjLvRWklAylFhBHQ',\n  6: 'Compendium.pf2e.equipment-srd.Item.4sGIy77COooxhQuC',\n  7: 'Compendium.pf2e.equipment-srd.Item.fomEZZ4MxVVK3uVu',\n  8: 'Compendium.pf2e.equipment-srd.Item.iPki3yuoucnj7bIt',\n  9: 'Compendium.pf2e.equipment-srd.Item.cFHomF3tty8Wi1e5',\n  10: 'Compendium.pf2e.equipment-srd.Item.o1XIHJ4MJyroAHfF',\n};\n\nconst picks = await Dialog.wait(\n  {\n    title: \"Scroll Generator\",\n    content: `<table>\n      <tr>\n        <th style=\"text-align:center\">Spell Rank:</th>\n        <td><select id=\"level\">\n          <option>1</option>\n          <option>2</option>\n          <option>3</option>\n          <option>4</option>\n          <option>5</option>\n          <option>6</option>\n          <option>7</option>\n          <option>8</option>\n          <option>9</option>\n          <option>10</option>\n          <option>All</option>\n        </select></td>\n      </tr>\n      <tr>\n        <th style=\"text-align:center\">Tradition:</th>\n        <td><select id=\"trad\">\n          <option value=\"arcane\">Arcane</option>\n          <option value=\"divine\">Divine</option>\n          <option value=\"occult\">Occult</option>\n          <option value=\"primal\">Primal</option>\n\t\t\t\t\t<option value=\"all\">All</option>\n        </select></td>\n      </tr>\n      <tr>\n        <th style=\"text-align:center\">Quantity:</th>\n        <td><input style=\"width:20%;text-align:center\" type=\"number\" id=\"quantity\" value=1 /></td>\n      </tr>\n      <tr>\n        <th style=\"text-align:center\">Rarity:</th>\n        <td><select id=\"rarity\">\n          <option value=\"common\">Common</option>\n            <option value=\"uncommon\">Uncommon</option>\n            <option value=\"rare\">Rare</option>\n\t\t\t\t\t\t<option value=\"any\">Any</option>\n        </select></td>\n      </tr>\n      <tr>\n      <th style=\"text-align:center\">Output Type:</th>\n        <td><select id=\"outtype\">\n          <option>Party Actor</option>\n          <option>Existing Loot Actor</option>\n          <option>Generated Loot Actor</option>\n        </select></td>\n      </tr>\n      <tr>\n        <th style=\"text-align:center\">Mystify?</th>\n        <td><input type=\"checkbox\" id=\"mystify\" /></td>\n      </tr>\n</table>`,\n  \tbuttons: {\n      ok: {\n        label: \"Ok\",\n        callback: (html) => {\n          return [\n            html[0].querySelector(\"#level\").value,\n            html[0].querySelector(\"#quantity\").valueAsNumber,\n            html[0].querySelector(\"#rarity\").value,\n            html[0].querySelector(\"#outtype\").value,\n            html[0].querySelector(\"#mystify\").checked,\n            html[0].querySelector(\"#trad\").value,\n          ];\n        },\n      },\n      close: {\n        label: \"Close\",\n      },\n    },\n    close: () => {\n      return \"close\";\n    },\n    default: \"ok\",\n  },\n  { width: \"auto\" }\n);\nif (picks === \"close\") {\n  return;\n}\n\nlet spells = [];\n  const compendiums = [\"pf2e.spells-srd\"];\n  const aCSpells = game.packs.filter(c => compendiums.includes(c.collection));\n  for (const s of aCSpells) {\n    let index = (await s.getIndex({fields: [\"system.level.value\",\"system.slug\",\"system.traits\",\"system.ritual\",\"uuid\"]})).filter(f => !f.system.traits.value.includes(\"cantrip\") && !(f.system.ritual ??= false) && !f.system.traits.value.includes(\"focus\"));\n    if ( picks[0] !== \"All\") { index = index.filter(r => r.system.level.value === parseInt(picks[0])) }\n    if ( picks[2] !== \"any\" ) { index = index.filter(r => r.system.traits.rarity === picks[2]) }\n\t\tif ( picks[5] !== \"all\" ) { index = index.filter(r => r.system.traits.traditions.includes(picks[5])) }\n    for (const x of index){\n      spells.push({ level: x.system.level.value, name: `Scroll of ${x.name} (Rank ${x.system.level.value})`, uuid: x.uuid, suuid: scrollUuids[x.system.level.value]});\n    };\n}\n\nif (spells.length === 0) { return void ui.notifications.warn(\"There are no spells that meet the criteria\"); }\n\nlet a;\nif ( picks[3] === \"Generated Loot Actor\" ) {\n\tif (!game.actors.some( n => n.name === \"Generated Loot\")) {\n\tawait Actor.create({name:\"Generated Loot\",type:\"loot\",img:\"icons/containers/chest/chest-reinforced-steel-red.webp\"});\n\t}\n\ta = game.actors.getName(\"Generated Loot\");\n}\n\t\t\nif ( picks[3] === \"Party Actor\" ) {\n\tif ( game.actors.filter( p => p.type === \"party\" ).length > 1 ) {\n\t\ta = await MyDialog(\"party\");\n\t}\n\telse { \n\t\ta = game.actors.find(p => p.type === \"party\" );\n\t}\n}\n\nif ( picks[3] === \"Existing Loot Actor\" ) {\n\tif ( game.actors.filter( p => p.type === \"loot\" ).length > 1 ) {\n\t\ta = await MyDialog(\"loot\");\n\t}\n\telse { \n\t\ta = game.actors.find(p => p.type === \"loot\" );\n\t}\n}\n\nfor ( const s of spells ) {\n  stuff.push(await createSpellScrollWand(s.suuid, s.uuid, s.level, s.name))\n}\nconst updates = await a.createEmbeddedDocuments(\"Item\",stuff);\nif ( picks[4] ) { await a.updateEmbeddedDocuments(\"Item\", updates.map(u => ({_id: u.id, \"system.identification.status\": \"unidentified\" }))); }\nawait a.sheet.render(true);\n\nasync function MyDialog(type) {\n\tlet options = \"\";\n\tfor (const plac of game.actors.filter( f => f.type === type )) {\n\t\toptions += `<option value=${plac.id}>${plac.name}</option>`\n\t}\n\tconst myac = await Dialog.prompt({\n\t\ttitle: `Select ${type} actor`,\n\t\tcontent:`\n\t\t\t<table>\n\t\t\t\t<tr>\n\t\t\t\t\t<th width=\"70%\" style=\"text-align:center\">Please select an actor : </th>\n\t\t\t\t\t<td width=\"30%\"><select>${options}</select></td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t`,\n\t\tcallback: (html) => { return html[0].querySelector(\"select\").value },\n\t\trejectClose:false,\n\t},{width:\"200px\"});\n\treturn game.actors.get(myac);\n}\n\nasync function createSpellScrollWand(scrollUUID, uuid, level, name) {\n  const spell = (await fromUuid(uuid))?.toObject();\n  if (!spell) return null;\n  if (level === false) level = spell.system.level.value;\n\tscrolls = await fromUuid(scrollUUID);\n\tconst scroll = scrolls?.toObject();\n  if (!scroll) return null;\n\tspell.system.location.heightenedLevel = level;\n  scroll.name = name;\n  scroll.system.description.value = `@UUID[${uuid}]\\n<hr />${scroll.system.description.value}`;\n  scroll.system.spell = spell;\n  scroll.system.traits.rarity = spell.system.traits.rarity;\n  scroll.system.quantity = picks[1];\n  scroll.system.traits.value = [...new Set(scroll.system.traits.value.concat(spell.system.traits.traditions).concat(spell.system.traits.value))];\n  return scroll;\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Generate All Scrolls.js\" - Fetched on 2024-06-05T17:22:21.769Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Generate All Scrolls","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"8b3GhIRwtSsihSZQ","actorIds":[],"author":"fJY1FA2sXyTZjVkz","command":"/*\nTo use this macro, you just have to target someone with a token selected and use it.\n*/\n\n\nSpellsling();\n\nasync function Spellsling() {\n  /* Throw warning if token is not selected*/\n  if (canvas.tokens.controlled.length < 1) { return ui.notifications.warn('No token is selected.'); }\n  if (canvas.tokens.controlled.length > 1) { return ui.notifications.warn('Only 1 token should be selected'); }\n  if (game.user.targets.size < 1) { return ui.notifications.warn('Please target a token'); }\n  if (game.user.targets.size > 1) { return ui.notifications.warn('Spellsling can only affect 1 target'); }\n\n const DamageRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"DamageRoll\"));\n\n  /* New Spell getter*/\n  const spells = [];\n  for (const e of token.actor.itemTypes.spellcastingEntry) {\n    if (e.isRitual) { continue; }\n    if (e.system.prepared.value === \"items\") { continue }\n\t\tconst spellData = await e.getSheetData();\n    for(const group of spellData.groups) {\n      const isCantrip = group.id === \"cantrips\" ? true : false;\n      let i = 0;\n      for (const active of group.active) {\n        const index = i++;\n        if(active === null) { continue; }\n        let spell = active.spell;\n        if(!spell.system.traits.value.includes(\"attack\") || spell === null) { continue; }\n        const castRank = active.castRank ?? (await spell.getChatData()).castRank;\n        const {isAttack, isSave, description, save, slug, traits, formula} = await spell.getChatData({},{castRank});\n        let rank = `Rank ${castRank}`\n        if(spellData.isPrepared) {\n          rank += ` |Slot: ${index + 1}|`\n        }\n        let lvl = castRank+1;\n        const name = spell.name;\n        if(isCantrip) { \n          rank = `Cantrip ${castRank}`\n          lvl = 0;\n        }\n        if(spellData.isFocusPool) { \n          rank = `Focus ${castRank}`\n          lvl = 1;\n        }\n\t\t\t\tconst sname = `${name} ${rank} (${e.name})`;\n        spells.push({name: sname, castRank, sEId: spellData.id, slug, description, DC: save.value, spell, index, isSave, isAttack, basic: spell.system.defense.save?.basic ?? false, isCantrip, isFocus: spellData.isFocusPool, traits, save: save.type ?? \"\", lvl, formula, isExpended: active.expended ? true : false , isUseless: group.uses?.value < 1 ? true : false});\n      }\n    }\n\t};\n\tspells.sort((a, b) => {\n    if (a.lvl === b.lvl)\n      return a.name\n      .toUpperCase()\n      .localeCompare(b.name.toUpperCase(), undefined, {\n        sensitivity: \"base\",\n      });\n    return a.lvl - b.lvl;\n  });\n\n\n  if (spells.length === 0) { return void ui.notifications.info(\"You have no spells available\"); }\n\n  /* Get them guns baby */\n  const weapons = token.actor.itemTypes.weapon.filter(i => i.isEquipped && i.system.group === 'firearm');\n  const map_weap = weapons.map(p => p.name);\n\n\n  /* Build dialog data */\n  const es_data = [\n    { label : `Choose a Spell : `, type : `select`, options : spells.filter(s => !s.isExpended && !s.isUseless).map(p => p.name) },\n    { label: `Beast Gun : `, type: `select`, options: map_weap },\n    { label: `Reroll using hero point?`, type: `checkbox` }\n  ];\n\n  /* Run dialog and alot data */\n  const spell_choice = await quickDialog({ data: es_data, title: `Spellsling` });\n\n  let last, mes;\n  if (spell_choice[2]) {\n    mes = game.messages.contents.findLast( lus => lus.getFlag(\"world\",\"macro.spellUsed\") !== undefined && lus.token.id === token.id);\n    if (mes === undefined) return void ui.notifications.warn(\"There are no previously cast spells or strike has already been rerolled\");\n    if (actor.system.resources.heroPoints.value === 0) { return void ui.notifications.warn(\"You have no hero points left\")}\n    last = mes.getFlag(\"world\",\"macro.spellUsed\");\n    last.spell = actor.itemTypes.spell.find(s => s.slug === last.slug);\n  }\n\n  /* Get the strike actions and roll strike */\n  const strike = token.actor.system.actions.find(a => a.type === 'strike' && a.label === spell_choice[1]);\n  const spc = last ?? spells.find(sp => sp.name === spell_choice[0]);\n  const s_entry = token.actor.itemTypes.spellcastingEntry.find(e => e.id === spc.sEId);\n\n  // Check for spell variants\n  if (spc.spell.hasVariants && spc.isAttack) {\n    let spell_variants;\n    if (spc.spell.overlays.contents[0].system?.time !== undefined) {\n      spell_variants = Array.from(spc.spell.overlays.entries(), ([id, ovl]) => ({name: spc.name + ovl.system.time.value, id: id, castRank: spc.castRank}));\n    }\n    else {\n      spell_variants = Array.from(spc.spell.overlays.entries(), ([id, ovl]) => ({name: ovl.name ?? spc.name, id: id, castRank: spc.castRank}));\n    }\n\n    spell_variants.sort((a, b) => {\n      if (a.lvl === b.lvl)\n        return a.name\n          .toUpperCase()\n          .localeCompare(b.name.toUpperCase(), undefined, {\n            sensitivity: \"base\",\n          });\n      return a.lvl - b.lvl;\n    });\n\n\n    // Build dialog data\n    const ovr_data = [\n      { label: `Choose a Spell Variant : `, type: `select`, options: spell_variants.map(p => p.name) }\n    ];\n\n    // Query user for variant choice\n    const variant_choice = await quickDialog({ data: ovr_data, title: `Variants Detected` });\n\n    // Obtain the ID of the chosen variant, then use that ID to fetch the modified spell\n    const vrId = spell_variants.find(x => x.name === variant_choice[0]).id;\n    const variant = spc.spell.loadVariant({ castRank: spc.castRank, overlayIds: [vrId] });\n    spc.spell = variant;\n  }\n  \n  let pers, critt;\n  if ( !spell_choice[2] ) {\n    critt = (await strike.attack({ event, callback: async(x) =>  { await(game.messages.contents.findLast(m => m.speaker.token === _token.id)).setFlag(\"world\",\"macro.spellUsed\", spc); }})).degreeOfSuccess;\n  }\n  else {\n    await game.pf2e.Check.rerollFromMessage(mes,{heroPoint:1});\n    critt = game.messages.contents.findLast(r => r.isReroll).rolls[0].degreeOfSuccess;\n  }\n\n  let ttags = '';\n  for (const t of spc.traits) {\n    ttags += `<span class=\"tag\" data-trait data-tooltip=${t.description}>${t.value[0].toUpperCase() + t.value.substring(1)}</span>`\n  }\n\n  let dos;\n  let hit = false\n\n  if (critt === 2) { dos = 'Success'; hit = true }\n  if (critt === 3) { dos = 'Critical Success'; hit = true }\n\n  // Automated Animations insertion by MrVauxs\n  if (game.modules.get(\"autoanimations\")?.active) {\n    AutomatedAnimations.playAnimation(token, {name: spc.name}, { targets: [Array.from(game.user.targets)[0]], hitTargets: hit ? [Array.from(game.user.targets)[0]] : [] })\n  }\n\n  let flavName = ` cast at Rank ${spc.castRank}`;\n  if (spc.isCantrip) { flavName = ` Cantrip ${spc.castRank}`; }\n  if (spc.isFocus) { flavName = ` Focus ${spc.castRank}`; }\n  let flavor = `<strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})`;\n  if (spc.slug === null) { flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Spellsling</strong><br>${flavName} [Custom Spell] (${dos})`; }\n  if (spc.isSave) {\n    flavor += `<br>@Check[type:${spc.save}|dc:${spc.DC}|traits:damaging-effect,${spc.traits.map(v => v.value).join()}|basic:${spc.basic}]`;\n  }\n\n  if (spc.slug === \"acid-splash\" && critt === 3) {\n    if (spc.castRank < 3) { flavor += `[[/r 1[persistent,acid]]]` }\n    else if (spc.castRank > 2 && spc.castRank < 5) { flavor += `[[/r 2[persistent,acid]]]` }\n    else if (spc.castRank > 4 && spc.castRank < 7) { flavor += `[[/r 3[persistent,acid]]]` }\n    else if (spc.castRank > 6 && spc.castRank < 9) { flavor += `[[/r 4[persistent,acid]]]` }\n    else { flavor += `[[/r 5[persistent,acid]]]` }\n  }\n  if (spc.slug === 'ignition' && critt === 3) {\n    pers = Math.ceil(actor.level / 2);\n    if (spc.spell.name.includes('Melee')) {\n      pers += 'd6';\n    }\n    else {\n      pers += 'd4';\n    }\n    flavor += `[[/r ${pers}[persistent,fire]]]`\n  }\n  if (spc.slug === 'produce-flame' && critt === 3) {\n    pers = Math.ceil(actor.level / 2) + \"d4\";\n    flavor += `[[/r ${pers}[persistent,fire]]]`\n  }\n  if (spc.slug === 'ray-of-frost' && critt === 3) {\n    flavor += `@UUID[Compendium.pf2e.spell-effects.I4PsUAaYSUJ8pwKC]{Spell Effect: Ray of Frost}`\n  }\n  if (spc.slug === 'gouging-claw' && critt === 3) {\n    pers = Math.ceil(actor.level / 2) + \"d4\";\n    flavor += `[[/r ${pers}[persistent,bleed]]]`\n  }\n  if (spc.slug === 'holy-light' || spc.slug === 'moonlight-ray') {\n    if (game.user.targets.first().actor.traits.has('undead') || game.user.targets.first().actor.traits.has('fiend')) {\n      const spRD = spc.spell.getRollData({ castRank: spc.castRank });\n      spc.roll = (await spRD.item.getDamage()).template.damage.roll;\n      spc.roll = new DamageRoll(`{(${spc.roll.terms[0].rolls[0]._formula})[${spc.roll.terms[0].rolls[0].type}],(${(spc.castRank - 3) * 2 + 5}d6)[spirit]}`);\n      flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})`;\n    }\n  }\n  if (spc.slug === 'chilling-darkness') {\n    if (game.user.targets.first().actor.traits.has('holy')) {\n      const spRD = spc.spell.getRollData({ castRank: spc.castRank });\n      spc.roll = (await spRD.item.getDamage()).template.damage.roll;\n      spc.roll = new DamageRoll(`{(${spc.roll.terms[0].rolls[0]._formula})[${spc.roll.terms[0].rolls[0].type}],(${(spc.castRank - 3) * 2 + 5}d6)[spirit]}`);\n      flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})`;\n    }\n  }\n\n  if (game.modules.get('xdy-pf2e-workbench')?.active && !game.settings.get(\"xdy-pf2e-workbench\", \"autoRollDamageForStrike\")) {\n    if (critt === 2) { await strike.damage({ event }); }\n    if (critt === 3) { await strike.critical({ event }); }\n  }\n  if (!game.modules.has('xdy-pf2e-workbench') || !game.modules.get('xdy-pf2e-workbench')?.active) {\n    if (critt === 2) { await strike.damage({ event }); }\n    if (critt === 3) { await strike.critical({ event }); }\n  }\n\n  /* Chromatic Ray */\n  if (spc.slug === 'chromatic-ray' && critt >= 2) {\n    flavor = `<div class=\"tags\">${ttags}`;\n    let ds = '';\n    let dsc = '';\n    if (token.actor.itemTypes.feat.some(s => s.slug === 'dangerous-sorcery')) {\n      ds = ` + ${spc.castRank}`;\n      dsc = ` + ${spc.castRank * 2}`\n    }\n    const chroma = [\n      { d: `{30${ds}}[fire]`, f: `<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionFire\">Fire</span></div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>1.<strong>Red</strong> (fire) The ray deals 30 fire damage to the target. Double on a Critical.</p>`, dd: `(60${dsc})[fire]` },\n      { d: `{40${ds}}[acid]`, f: `<span class=\"tag\" data-trait=\"acid\" data-description=\"PF2E.TraitDescriptionAcid\">Acid</span></div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>2.<strong>Orange</strong> (acid) The ray deals 40 acid damage to the target. Double on a Critical.</p>`, dd: `(80${dsc})[acid]` },\n      { d: `(50${ds})[electricity]`, f: `<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionElectricity\">Electricity</span></div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>3.<strong>Yellow</strong> <br>(electricity) The ray deals 50 electricity damage to the target. Double on a Critical.</p>`, dd: `(100${dsc})[electricity]` },\n      { d: `(25${ds})[poison]`, f: `<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionPoison\">Poison</span></div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>4.<strong>Green</strong> (poison) The ray deals 25 poison damage to the target, double on a Critical, and the target must succeed at a @Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light,poison] or be @Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 1} for 1 minute (@Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 2} on a critical failure).</p>`, dd: `(50${dsc})[poison]` },\n      { f: `</div><strong><hr>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>5.<strong>Blue</strong> The ray has the effect of the @Compendium[pf2e.spells-srd.Petrify]{Petrify} spell. On a critical hit, the target is @Compendium[pf2e.conditionitems.Clumsy]{Clumsy 1} as long as its slowed by the petrify effect.<br>@Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light]</p>` },\n      { f: `<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionEmotion\">Emotion</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionIncapacitation\">Incapacitation</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionMental\">Mental</span></div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>6.<strong>Indigo</strong> (emotion, incapacitation, mental) The ray has the effect of the @Compendium[pf2e.spells-srd.Confusion]{Confusion} spell. On a critical hit, it has the effect of @Compendium[pf2e.spells-srd.Warp Mind]{Warp Mind} instead.<br>@Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light,emotion,incapacitation,mental]</p>` },\n      { f: `</div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>7.<strong>Violet</strong> <br>The target is @Compendium[pf2e.conditionitems.Slowed]{Slowed} for 1 minute. It must also succeed at a @Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light] or be teleported 120 feet directly away from you (if there isnt room for it to appear there, it appears in the nearest open space); this is a teleportation effect.</p>` },\n      { f: `</div><hr><strong>Spellsling</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>8.<strong>Intense Color</strong> The target is @Compendium[pf2e.conditionitems.Dazzled]{Dazzled} until the end of your next turn, or @Compendium[pf2e.conditionitems.Blinded]{Blinded} if your attack roll was a critical hit. Roll again and add the effects of another color (rerolling results of 8).</p>` },\n    ];\n    let chromaD = '1d4';\n    if (spc.castRank > 5) {\n      chromaD = '1d8';\n      chroma[0].d = `(40${ds})[fire]`;\n      chroma[0].dd = `(80${dsc})[fire]`;\n      chroma[0].f = chroma[0].f.replace('30', '40');\n      chroma[1].d = `(50${ds})[acid]`;\n      chroma[1].dd = `(100${dsc})[acid]`;\n      chroma[1].f = chroma[1].f.replace('40', '50');\n      chroma[2].d = `(60${ds})[electricity]`;\n      chroma[2].dd = `(120${dsc})[electricity]`;\n      chroma[2].f = chroma[2].f.replace('50', '60');\n      chroma[3].d = `(35${ds})[poison]`;\n      chroma[3].dd = `(70${dsc})[poison]`;\n      chroma[3].f = chroma[3].f.replace('25', '35');\n    }\n    const chromaR = new Roll(chromaD).evaluate({ async: false }).total;\n    if (chromaR < 5) {\n      ddice = chroma[chromaR - 1].dd;\n      flavor = flavor + chroma[chromaR - 1].f;\n      spc.roll = new DamageRoll(chroma[chromaR - 1].d);\n      if (critt === 3) {\n        spc.roll = new DamageRoll(chroma[chromaR - 1].dd);\n      }\n    }\n    if (chromaR > 4 && chromaR <= 7) { flavor = flavor + chroma[chromaR - 1].f; await ChatMessage.create({ speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc } }); }\n    if (chromaR === 8) {\n      const flavor2 = flavor + chroma[chromaR - 1].f;\n      await ChatMessage.create({ speaker: ChatMessage.getSpeaker(), content: flavor2, flags: { \"world.macro.spellUsed\": spc } });\n      if (critt === 3) {\n        const chromaRR = new Roll('1d7').evaluate({ async: false }).total;\n        if (chromaRR < 5) { flavor = flavor + chroma[chromaRR - 1].f; spc.roll = new DamageRoll(chroma[chromaRR - 1].dd); }\n        if (chromaRR > 4) { flavor = flavor + chroma[chromaRR - 1].f; await ChatMessage.create({ speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc } }); }\n      }\n    }\n  }\n\n  const { item } = await spc.spell.getRollData({ castRank: spc.castRank });\n  if (critt >= 2) {\n    if (spc.slug !== \"chromatic-ray\" && spc.roll === undefined && spc.formula === undefined) {\n      await item.toMessage(null, { speaker: ChatMessage.getSpeaker(), flags: { \"world.macro.spellUsed\": spc } })\n    }\n    if (critt === 3 && spc.slug !== \"chromatic-ray\") { ui.notifications.info('Spell damage will need to be doubled when applied'); }\n    if (spc.roll !== undefined) {\n      await spc.roll.toMessage({ flavor: flavor, speaker: ChatMessage.getSpeaker(), flags: { \"world.macro.spellUsed\": spc } });\n    }\n    else {\n      await item.rollDamage({ event });\n    }\n  }\n\n  /* Expend slots */\n  if (spc.isCantrip || spell_choice[2]) { return; }\n  await s_entry.cast(spc.spell, { slotId: spc.index, rank: spc.castRank, message: false });\n}\n/* Dialog box */\nasync function quickDialog({ data, title = `Quick Dialog` } = {}) {\n  data = data instanceof Array ? data : [data];\n\n  return await new Promise(async (resolve) => {\n    let content = `\n      <table style=\"width:100%\">\n      ${data.map(({ type, label, options }, i) => {\n      if (type.toLowerCase() === `select`) {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e, i) => `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n      }\n      else if (type.toLowerCase() === `checkbox`) {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n      }\n      else {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n      }\n    }).join(``)}\n      </table>`;\n\n    await new Dialog({\n      title, content,\n      buttons: {\n        Ok: {\n          label: `Ok`, callback: (html) => {\n            resolve(Array(data.length).fill().map((e, i) => {\n              let { type } = data[i];\n              if (type.toLowerCase() === `select`) {\n                return html.find(`select#${i}qd`).val();\n              }\n              else {\n                switch (type.toLowerCase()) {\n                  case `text`:\n                  case `password`:\n                  case `radio`:\n                    return html.find(`input#${i}qd`)[0].value;\n                  case `checkbox`:\n                    return html.find(`input#${i}qd`)[0].checked;\n                  case `number`:\n                    return html.find(`input#${i}qd`)[0].valueAsNumber;\n                }\n              }\n            }));\n          }\n        }\n      },\n      default: 'Ok'\n    }, { width: \"auto\" })._render(true);\n    document.getElementById(\"0qd\").focus();\n  });\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Spellsling.js\" - Fetched on 2024-06-05T17:22:21.772Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Spellsling","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"AtMqQ7GuWMfXX6tK","actorIds":[],"author":"jVvW0hFAsdZOljjN","command":"/* Author ArthurTrumpet\nThis allows you to quickly roll a skill action using the built in system macros.\nIt lists 4 buttons to make it quicker than selecting from a drop down. Simply click the one you want.\nEdit the first four lines to customise the skill actions you wish to perform (always use lower case).\ntype game.pf2e.actions in your browser console (F12 usually) to see a list of all available options.\nYou can shift click to modify the roll, or ctrl-click to make it a secret check.\n*/\n\nlet skill1 = 'demoralize';\nlet skill2 = 'hide';\nlet skill3 = 'sneak';\nlet skill4 = 'trip';\n\nasync function buttonDialog(data)\n{\n  return await new Promise(async (resolve) => {\n    let buttons = {}, dialog;\n\n    data.buttons.forEach(([str, callback])=>{\n      buttons[str] = {\n        label : str,\n        callback\n      }\n    });\n  \n    dialog = new Dialog({\n      title : data.title , \n      buttons, \n      close : () => resolve(true) \n    },{\n      width : 300, height : ( 50 * data.buttons.length)\n    });\n\n    await dialog._render(true);\n    dialog.element.find('.dialog-buttons').css({'flex-direction':'column'});\n  });\n}\n\n\nlet data = {\n    buttons : [\n           [`${skill1}`, () => rollMySkill(`${skill1}`)],\n           [`${skill2}`, () => rollMySkill(`${skill2}`)],\n           [`${skill3}`, () => rollMySkill(`${skill3}`)],\n           [`${skill4}`, () => rollMySkill(`${skill4}`)],\n    ],\n    title : `Skill Action`\n}\n\nawait buttonDialog(data);\n\n\nasync function rollMySkill(selectedSkill) {\n    console.log(selectedSkill);\n    game.pf2e.actions[selectedSkill]({ event: event });\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/QuickSkillActions.js\" - Fetched on 2024-06-05T17:22:21.777Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT QuickSkillActions","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"E1tlJZPZR9G1QHXc","actorIds":[],"author":"8hBpPk3o4DRUqEhj","command":"/*\nMacro to generate a custom mixed heritage item.\nMacro only needs to be run once per world or when new ancestries are added to the world.\n*/\n\nconst packs = game.packs.filter( p => p.metadata.type === \"Item\" && p.index.some(e => e.type === \"ancestry\") && p.metadata.packageName !== \"pf2e-animal-companions\");\nconst indexData = [];\nfor (const p of packs) {\n    indexData.push(await p.getIndex({fields:[\"system.vision\", \"system.slug\"]}));\n}\nconst worldAncestries = game.items.filter(x => x.type === \"ancestry\").flatMap(d => [{slug: d.system.slug === \"\" || d.system.slug === null || d.system.slug === undefined ? game.pf2e.system.sluggify(d.name) : d.system.slug, vision: d.system.vision}]);\nconst ancestries = indexData.flatMap(v => v.contents).filter(x => x.type === \"ancestry\").flatMap(d => [{slug: d.system.slug === \"\" || d.system.slug === null || d.system.slug === undefined ? game.pf2e.system.sluggify(d.name) : d.system.slug, vision: d.system.vision}]).concat(worldAncestries);\nconst lowLightVisionExclusions = ancestries.filter(v => v.vision === \"normal\").map(llve => { return `heritage:${llve.slug}`});\n\nconst itemData = {\n    \"img\": \"systems/pf2e/icons/spells/chromatic-image.webp\",\n    \"name\": \"Custom Mixed Heritage\",\n    \"system\": {\n        \"ancestry\": null,\n        \"description\": {\n            \"value\": \"<p>You can work with your GM to create a mixed heritage for an ancestry other than elf or orc. A custom mixed-ancestry heritage is an uncommon heritage. Choose an ancestry to tie to the heritage. You gain any traits of that ancestry and a new trait for your combined ancestry, similar to how the @UUID[Compendium.pf2e.heritages.N36ZR4lh9eCazDaN]{Aiuvarin} heritage grants the \\\"elf\\\" and \\\"aiuvarin\\\" traits. You also gain low-light vision if the ancestry tied to the heritage has low-light vision or darkvision. The heritage lets you select ancestry feats for the chosen ancestry in addition to those from your base ancestry.</p>\\n<p>Characters of mixed Elven and Orcish ancestries should use the @UUID[Compendium.pf2e.heritages.N36ZR4lh9eCazDaN]{Aiuvarin} and @UUID[Compendium.pf2e.deities.39z55kowQFOUH2v0]{Droskar} heritages.</p>\"\n        },\n        \"publication\": {\n            \"license\": \"ORC\",\n            \"remaster\": true,\n            \"title\": \"Pathfinder Player Core\"\n        },\n        \"rules\": [\n            {\n            \"choices\": {\n                \"filter\": [\n                \"item:type:ancestry\",\n                {\n                    \"nor\": [\n                    \"item:trait:minion\",\n                    \"item:trait:eidolon\",\n                    \"item:trait:animal\",\n                    \"item:trait:elemental\",\n                    \"item:trait:zombie\",\n                    \"item:trait:fungus\",\n                    \"item:slug:arboreal-sapling\",\n                    \"item:slug:zombie\",\n                    \"item:slug:gibtas\",\n                    \"item:slug:riding-drake\",\n                    \"item:slug:shotalashu\",\n                    \"item:slug:skeletal-mount\",\n                    \"item:slug:skeletal-servant\",\n                    \"item:slug:vampiric-animal\"\n                    ]\n                }\n                ],\n                \"itemType\": \"ancestry\",\n                \"slugsAsValues\": true\n            },\n            \"flag\": \"heritage\",\n            \"key\": \"ChoiceSet\",\n            \"prompt\": \"Select an Ancestry\",\n            \"rollOption\": \"heritage\"\n            },\n            {\n                \"add\": [\n                    \"{item|flags.pf2e.rulesSelections.heritage}\"\n                ],\n                \"key\": \"ActorTraits\"\n            },\n            {\n                \"key\": \"ActiveEffectLike\",\n                \"mode\": \"override\",\n                \"path\": \"system.details.ancestry.versatile\",\n                \"value\": \"{item|flags.pf2e.rulesSelections.heritage}\"\n            },\n            {\n                \"key\": \"ActiveEffectLike\",\n                \"mode\": \"add\",\n                \"path\": \"system.details.ancestry.countsAs\",\n                \"value\": \"{item|flags.pf2e.rulesSelections.heritage}\"\n            },\n            {\n                \"key\": \"Sense\",\n                \"predicate\": [\n                    {\n                        \"nor\": lowLightVisionExclusions\n                    }\n                ],\n                \"selector\": \"low-light-vision\"\n            },\n            {\n                \"key\": \"GrantItem\",\n                \"predicate\": [\n                    \"heritage:elf\"\n                ],\n                \"replaceSelf\": true,\n                \"uuid\": \"Compendium.pf2e.heritages.Item.Aiuvarin\"\n            },\n            {\n                \"key\": \"GrantItem\",\n                \"predicate\": [\n                    \"heritage:orc\"\n                ],\n                \"replaceSelf\": true,\n                \"uuid\": \"Compendium.pf2e.heritages.Item.Dromaar\"\n            }\n        ],\n        \"traits\": {\n            \"rarity\": \"uncommon\",\n            \"value\": []\n        }\n    },\n    \"type\": \"heritage\"\n}\n\nif (game.items.some(x => x.name === \"Custom Mixed Heritage\")) {\n    const answer = await Dialog.confirm({\n        title: \"Update Custom Mixed Heritage\",\n        content: \"Replace Custom Mixed Heritage item with an updated version?\"\n    });\n    if (!answer || answer === null) return;\n    const item = game.items.getName(\"Custom Mixed Heritage\");\n    await item.update(itemData);\n    ui.notifications.info(\"Updated Custom Mixed Heritage item\");\n    ui.sidebar.activateTab(\"items\");\n    await item.sheet.render(true, {tab: 'description'});\n}\nelse { \n    const item = await Item.create(itemData);\n    ui.sidebar.activateTab(\"items\");\n    ui.notifications.info(\"Created Custom Mixed Heritage item\");\n    await item.sheet.render(true);\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Custom Mixed Heritage.js\" - Fetched on 2024-06-05T17:22:21.768Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Custom Mixed Heritage","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"Ee6isXrZHQp45btA","actorIds":[],"author":"hZ2wdMvCguoLOU5o","command":"/*\nThis Macro removes all remaining hero points and removes the dying condition as per Heroic Recovery\nhttps://2e.aonprd.com/Rules.aspx?ID=382\nIt does not set hitpoints to 0, since if you are dying your hitpoints should already be 0\n*/\n\nif ( !actor || !actor.system.resources?.heroPoints?.value ) { return void ui.notifications.warn(\"You have not selected a Player character's token\"); }\nif ( actor.system.resources.heroPoints.value < 1 ) { return void ui.notifications.info(`${token.name} is out of hero points`) }\nif ( !actor.hasCondition(\"dying\") ) { return void ui.notifications.info(`${token.name} is not dying`) }\nawait actor.update({\"system.resources.heroPoints.value\": 0});\nawait actor.toggleCondition(\"dying\");\nawait ChatMessage.create({\n    content: `${token.name} performs a heroic recovery, expending all remaining hero points, and is no longer dying`,\n    type: CONST.CHAT_MESSAGE_TYPES.EMOTE,\n    speaker: ChatMessage.getSpeaker()\n});\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Heroic Recovery.js\" - Fetched on 2024-06-05T17:22:21.769Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Heroic Recovery","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"FWzNkwSeUzwefS9b","actorIds":[],"author":"MUxM20IgKaRwpaT4","command":"//Simple Shared prey Macro that changes the Macro's image to that of the actor's image with whom the prey is being shared\n//It will then publish a ChatMessage with that PC's token name and the effect.\n//Needs to be used on a token and populates playerOwned PC tokens on the canvas to the droplist\n\nif (!token.actor.items.some(s => s.slug === \"hunters-edge\")) return void ui.notifications.warn(\"This PC does not have the hunter's edge class feature\");\nif (!token.actor.items.some(s => s.slug === \"shared-prey\")) return void ui.notifications.warn(\"This PC does not have the shared prey feat\");\nif (!token ) return void ui.notifications.warn(\"Please select your token\");\nconst tokens = canvas.tokens.placeables.filter(t => t.actor.type === \"character\" && t.actor.hasPlayerOwner);\ntokens.sort((a, b) => {\n  return a.name\n      .toUpperCase()\n      .localeCompare(b.name.toUpperCase(), undefined, {\n        sensitivity: \"base\",\n      });\n});\nlet content = `\n  <div class=\"form-group\">\n    <label for=\"exampleSelect\">Choose PC to share prey with</label>\n    <select id=\"exampleSelect\">\n`\nfor (const t of tokens) {\n  content += `<option value=\"${t.id}\">${t.name}</option>`\n}\ncontent += `</select></div>`\nconst sPTId = await Dialog.prompt({\n  title: \"Shared Prey\",\n  content,\n  rejectClose: false,\n  callback: (html) => { return html.find(\"#exampleSelect\").val(); }\n});\n\nif (sPTId === null) { return }\n\nconst uuids = [\n  \"@UUID[Compendium.pf2e.feat-effects.Item.uXCU8GgriUjuj5FV]\", //flurry effect\n  \"@UUID[Compendium.pf2e.feat-effects.Item.4UNQfMrwfWirdwoV]\", //masterful flurry effect\n  \"@UUID[Compendium.pf2e.feat-effects.Item.ltIvO9ZQlmqGD89Y]\", //outwit effect\n  \"@UUID[Compendium.pf2e.feat-effects.Item.iqvurepX0zyu9OlI]\", //masterful outwit efect\n  \"@UUID[Compendium.pf2e.feat-effects.Item.mNk0KxsZMFnDjUA0]\", //precision effect\n  \"@UUID[Compendium.pf2e.feat-effects.Item.Lt5iSfx8fxHSdYXz]\", //masterful precision effect\n]; //add additional uuid's to effects of custom Hunter's Edge\nlet uuid = \"\";\nif (actor.items.some(s => s.sourceId === \"Compendium.pf2e.classfeatures.Item.6v4Rj7wWfOH1882r\")) {\n  uuid = uuids[0];\n  if (actor.level > 16) { uuid = uuids[1] }\n} //flurry\nif (actor.items.some(s => s.sourceId === \"Compendium.pf2e.classfeatures.Item.NBHyoTrI8q62uDsU\")) {\n  uuid = uuids[2];\n  if (actor.level > 16) { uuid = uuids[3] }\n} //outwit\nif (actor.items.some(s => s.sourceId === \"Compendium.pf2e.classfeatures.Item.u6cBjqz2fiRBadBt\")) {\n  uuid = uuids[4];\n  if (actor.level > 16) { uuid = uuids[5] }\n} //precision\nif (uuid === \"\") { ui.notifications.warn(\"You may have a custom Hunter's Edge. If so, please modify the macro to accomodate your custom Hunter's Edge custom effect, if it has one\")} // remove this line if your custom doesn't have an effect\nconst sPT = canvas.tokens.get(sPTId);\nawait ChatMessage.create({\n  content:`Sharing Prey with ${sPT.name}<bR> ${uuid}`,\n  speaker: ChatMessage.getSpeaker()\n});\nawait this.update({img: sPT.actor.img});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Shared Prey.js\" - Fetched on 2024-06-05T17:22:21.771Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Shared Prey","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"Fm0enDz9xwwD0c6w","actorIds":[],"author":"u8DXQeaFgNMJ1bNi","command":"/*\nContributed by Mark Pearce.\nThis Macro is an easy way to use Skill Actions.\nSimply choose your Skill and the associated Action.\n*/\n\n// dialog constructor\nclass SkillActionDialog extends Dialog {\n  static get defaultOptions() {\n    return {\n      ...super.defaultOptions,\n      height: \"auto\",\n    };\n  }\n\n  activateListeners($html) {\n    super.activateListeners($html);\n    const $app = $html.closest(\".window-app.dialog\");\n    let $content = $app.children(\".window-content\");\n    const $buttons = $content.children(\".dialog-buttons\");\n  }\n}\n\n// start of macro\nconst standardSkills = [\n  \"acrobatics\",\n  \"arcana\",\n  \"athletics\",\n  \"crafting\",\n  \"deception\",\n  \"diplomacy\",\n  \"intimidation\",\n  \"medicine\",\n  \"nature\",\n  \"occultism\",\n  \"performance\",\n  \"religion\",\n  \"society\",\n  \"stealth\",\n  \"survival\",\n  \"thievery\"\n]\n\n// get token and actor\nconst actors = canvas.tokens.controlled\n  .flatMap((token) => (token.actor ? token.actor : []))\n  .filter((actor) => actor.isOwner)\n  .filter((actor) => actor.type == \"character\" || actor.type == \"npc\");\n\nif (actors.length === 0 && game.user.character) {\n  actors.push(game.user.character);\n}\n\n// do nothing if we couldn't find the player's character\nif (actors.length === 0) {\n  new Dialog({\n    title: `Problem with auto-detection`,\n    content: `Unfortunately, this macro wasn't able to automatically detect which token is yours.<br/><br/>Please manually select your token and try again.`,\n    buttons: {}\n  }).render(true);\n  return; // this is illegal, but I don't know how else to make processing stop\n}\n\n// simplify, make global\nconst actor = actors[0];\n\nlet selectedToken = token;\n// let tokenSkills = token.actor.data.data.skills;\nlet tokenSkills = actor.skills;\nlet SelectedActor = selectedToken.actor;\nlet selectedActorFeats = Array.from(SelectedActor.items).filter(\n  (item) => item.type === \"feat\"\n);\n\n// lore variables\nlet tokenSkillKeys = Object.keys(tokenSkills);\nlet loreKeys = [];\nlet loreListForHTML = [];\nlet selectedLore = \"\";\n\ntokenSkillKeys.forEach((skillKey) => {\n  if (!standardSkills.includes(skillKey)) {\n    loreKeys.push(skillKey);\n  }\n});\n\n// make lore dialog\nselectedLore = loreKeys[0];\nloreKeys.forEach((lore) => {\n  loreListForHTML.push(\n    `<option value=\"${lore}\">${tokenSkills[lore].label}</option>`\n  );\n});\n\nlet loreContent = `<form name=\"select lore\">\n      <div class=\"form-group\">\n        <label>Action:</label>\n        <select name=\"lore-selector\">${loreListForHTML}</select>\n      </div>\n    </form>`;\n\nlet loreDialog = new SkillActionDialog({\n  title: \"Lore selector\",\n  content: loreContent,\n  buttons: {\n    performAction: {\n      label: \"Select lore\",\n      callback: () => recallKnowledge(selectedLore),\n    },\n    cancel: {\n      label: \"Cancel\",\n    },\n  },\n  default: \"cancel\",\n  render: ([loreContent]) => {\n    loreContent\n      .querySelector(\"[name=lore-selector]\")\n      .addEventListener(\"change\", changeLore);\n  },\n}).render(false);\n\n// skill data model\nconst skillActionDirectory = getSkillActionDirectory();\n\n// Make skill list\nlet skillList = [];\nskillActionDirectory.forEach((skill) => {\n  skillList.push(skill.skillName);\n});\nconst skillListForHTML = []; // array of skills formatted for HTML options - one gets tagged as selected = \"selected\"\n\n// default selection values\nlet selectedSkill = skillList[0];\nlet selectedAction = skillActionDirectory[0].actions[0].actionName;\n\n// initialize skill strings for HTML\nlet skillsTextForHTML = \"\";\nlet actionsTextForHTML = \"\";\nupdateSkills();\n\n// initialize actions for skill\nlet actionList = [];\nlet actionListForHTML = [];\nupdateActions();\n\nlet dialogContent = `<form name=\"skill-action-dialog\">\n    <div class=\"form-group\">\n        <label>Skill:</label>\n        <select name=\"skill-selector\">${skillsTextForHTML}</select>\n    </div>\n     <div class=\"form-group\">\n        <label>Action:</label>\n        <select name=\"action-selector\">${actionsTextForHTML}</select>\n    </div>\n</form>`;\n\n// create the actions dialog\nlet actionsDialog = new SkillActionDialog({\n  title: \"Action Selector\",\n  content: dialogContent,\n  buttons: {\n    performAction: {\n      label: \"Use Action\",\n      callback: () => performAction(),\n    },\n    cancel: {\n      label: \"Cancel\",\n    },\n  },\n  default: \"cancel\",\n  render: ([dialogContent]) => {\n    dialogContent\n      .querySelector(\"[name=skill-selector]\")\n      .addEventListener(\"change\", changeSkill);\n    dialogContent\n      .querySelector(\"[name=action-selector]\")\n      .addEventListener(\"change\", changeAction);\n  },\n}).render(true);\n\n// end of macro - functions are below\n\nfunction updateSkills() {\n  skillListForHTML.splice(0, skillListForHTML.length); // clear skill list for HTML\n  skillActionDirectory.forEach((skill) => {\n    if (skill.skillName !== selectedSkill) {\n      skillListForHTML.push(\n        `<option value=\"${skill.skillName}\">${skill.skillName}</option>`\n      );\n    } else {\n      skillListForHTML.push(\n        `<option value=\"${skill.skillName}\" selected = \"selected\">${skill.skillName}</option>`\n      );\n    }\n    skillsTextForHTML = skillListForHTML.toString();\n  });\n}\n\nfunction updateActions() {\n  // empty action arrays\n  actionList.splice(0, actionList.length);\n  actionListForHTML.splice(0, actionListForHTML.length);\n  // get actions from selected skill\n  actionList = [\n    ...skillActionDirectory[skillList.indexOf(selectedSkill)].actions,\n  ];\n  // build html version;\n  actionList\n    .filter(\n      (x) =>\n        !x.prerequisite ||\n        selectedActorFeats.map((x) => x.data.data.slug).includes(x.prerequisite)\n    )\n    .sort((a, b) =>\n      a.actionName > b.actionName ? 1 : b.actionName > a.actionName ? -1 : 0\n    )\n    .forEach((action) => {\n      let costString = \"\";\n      if (action.actionCost != null) {\n        costString = \" (\" + action.actionCost.toString() + \")\";\n      }\n      if (action.actionName !== selectedAction) {\n        actionListForHTML.push(\n          `<option value=\"${action.actionName}\">${action.actionName + costString\n          }</option>`\n        );\n      } else {\n        actionListForHTML.push(\n          `<option value=\"${action.actionName}\" selected = \"selected\">${action.actionName + costString\n          }</option>`\n        );\n      }\n    });\n  actionsTextForHTML = actionListForHTML.toString();\n}\n\nfunction changeSkill(event) {\n  let selectElement = event.target;\n  selectedSkill = selectElement.value;\n  selectedAction =\n    skillActionDirectory[skillList.indexOf(selectedSkill)].actions[0]\n      .actionName;\n  updateSkills();\n  updateActions();\n  updateDialogContent();\n}\n\nfunction changeAction(event) {\n  let selectElement = event.target;\n  selectedAction = selectElement.value;\n  updateActions();\n  updateDialogContent();\n}\n\nfunction updateDialogContent() {\n  $(\"select[name='action-selector']\").empty();\n  $(\"select[name='action-selector']\").append(actionsTextForHTML);\n  $(\"select[name='skill-selector']\").empty();\n  $(\"select[name='skill-selector']\").append(skillsTextForHTML);\n}\n\nfunction performAction() {\n  let pActionsFromSkill =\n    skillActionDirectory[skillList.indexOf(selectedSkill)].actions;\n  pActionsFromSkill.forEach((action) => {\n    if (action.actionName === selectedAction) {\n      action.command();\n    }\n  });\n}\n\nfunction coreAction(whatAction, skill = \"\") {\n  let actionProperties = { event: event }\n  if (skill.length > 0) {\n    actionProperties[\"skill\"] = skill;\n  }\n  game.pf2e.actions[whatAction](actionProperties);\n}\n\nfunction recallKnowledge(skill) {\n  if (skill) game.pf2e.actions.get(\"recall-knowledge\").use({ statistic: skill });\n}\n\n\nfunction loreSkill(whatAction) {\n  if (loreKeys.length < 1) {\n    return ui.notifications.error(\"Selected token does not have a lore skill\");\n  }\n\n  if (loreKeys.length > 0) {\n    loreDialog.render(true);\n  }\n}\n\nfunction changeLore(event) {\n  let selectElement = event.target;\n  selectedLore = selectElement.value;\n}\n\nfunction createADiversion(whatVariant) {\n  game.pf2e.actions.createADiversion({ event: event, variant: whatVariant });\n}\n\nfunction treatWounds() {\n  async function _executeMacroByName(name) {\n    let pack = game.packs.get(\"pf2e.pf2e-macros\");\n    pack.getIndex().then((index) => {\n      let id = index.find((e) => e.name === name)?._id;\n      if (id) pack.getDocument(id).then((e) => e.execute());\n    });\n  }\n  _executeMacroByName(\"Treat Wounds\");\n}\n\nfunction earnIncome() {\n  async function _executeMacroByName(name) {\n    let pack = game.packs.get(\"pf2e.pf2e-macros\");\n    pack.getIndex().then((index) => {\n      let id = index.find((e) => e.name === name)?._id;\n      if (id) pack.getDocument(id).then((e) => e.execute());\n    });\n  }\n  _executeMacroByName(\"Earn Income\");\n}\n\nfunction unspecifiedActivity(skillName, secret = false) {\n  let _title = skillName.charAt(0).toUpperCase() + skillName.slice(1) + \" Check\"; // uppercase first letter\n  let _skill;\n  if (skillName == \"perception\") {\n    _skill = actor.perception;\n  } else {\n    _skill = actor.skills[skillName];\n  }\n  let checkData = {\n    actor,\n    type: \"skill-check\",\n    createMessage: true,\n  }\n  if (secret) {\n    checkData[\"options\"] = [\"secret\"];\n  }\n  game.pf2e.Check.roll(new game.pf2e.CheckModifier(_title, _skill), checkData);\n}\n\n// TODO use exsiting action macros\n// game.macros.getName(``).execute();\n\n// An array of skills and all of thier actions\nfunction getSkillActionDirectory() {\n  return [\n    {\n      skillName: \"Acrobatics\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"acrobatics\");\n          }\n        },\n        {\n          actionName: \"Balance\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"balance\");\n          },\n        },\n        {\n          actionName: \"Tumble Through\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"tumbleThrough\");\n          },\n        },\n        {\n          actionName: \"Maneuver in Flight\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"maneuverInFlight\");\n          },\n        },\n        {\n          actionName: \"Squeeze\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"squeeze\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Arcana\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"arcana\");\n          }\n        },\n        {\n          actionName: \"Recall Knowledge, Arcana\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"arcana\");\n          },\n        },\n        {\n          actionName: \"Borrow an Arcane Spell\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"arcana\");\n          },\n        },\n        {\n          actionName: \"Decipher Writing\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"decipherWriting\", \"arcana\");\n          },\n        },\n        {\n          actionName: \"Identify Magic\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"arcana\");\n          },\n        },\n        {\n          actionName: \"Learn a Spell\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"arcana\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Athletics\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"athletics\");\n          }\n        },\n        {\n          actionName: \"Climb\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"climb\");\n          },\n        },\n        {\n          actionName: \"Force Open\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"forceOpen\");\n          },\n        },\n        {\n          actionName: \"Grapple\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"grapple\");\n          },\n        },\n        {\n          actionName: \"High Jump\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"highJump\");\n          },\n        },\n        {\n          actionName: \"Long Jump\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"longJump\");\n          },\n        },\n        {\n          actionName: \"Shove\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"shove\");\n          },\n        },\n        {\n          actionName: \"Swim\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"swim\");\n          },\n        },\n        {\n          actionName: \"Trip\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"trip\");\n          },\n        },\n        {\n          actionName: \"Disarm\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"disarm\");\n          },\n        },\n        {\n          actionName: \"Whirling Throw\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: \"whirling-throw\",\n          actionCost: 1,\n          command: () => {\n            coreAction(\"whirlingThrow\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Crafting\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"crafting\");\n          }\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"crafting\");\n          },\n        },\n        {\n          actionName: \"Repair\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"repair\");\n          },\n        },\n        {\n          actionName: \"Craft\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"craft\");\n          },\n        },\n        {\n          actionName: \"Earn Income\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            earnIncome();\n          },\n        },\n        {\n          actionName: \"Identify Alchemy\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"crafting\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Deception\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"deception\");\n          }\n        },\n        {\n          actionName: \"Create a Diversion: Words\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            createADiversion(\"distracting-words\");\n          },\n        },\n        {\n          actionName: \"Create a Diversion: Gesture\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            createADiversion(\"gesture\");\n          },\n        },\n        {\n          actionName: \"Create a Diversion: Trick\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            createADiversion(\"trick\");\n          },\n        },\n        {\n          actionName: \"Impersonate\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"impersonate\");\n          },\n        },\n        {\n          actionName: \"Lie\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"lie\");\n          },\n        },\n        {\n          actionName: \"Feint\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"feint\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Diplomacy\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"diplomacy\");\n          }\n        },\n        {\n          actionName: \"Gather Information\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"gatherInformation\");\n          },\n        },\n        {\n          actionName: \"Make an Impression\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"makeAnImpression\");\n          },\n        },\n        {\n          actionName: \"Request\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"request\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Intimidation\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"intimidation\");\n          }\n        },\n        {\n          actionName: \"Coerce\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"coerce\");\n          },\n        },\n        {\n          actionName: \"Demoralize\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"demoralize\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Lore\",\n      actions: [\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            loreSkill(\"recallKnowledge\");\n          },\n        },\n        {\n          actionName: \"Earn Income\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            earnIncome();\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Medicine\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"medicine\");\n          }\n        },\n        {\n          actionName: \"Administer First Aid\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 2,\n          command: () => {\n            coreAction(\"administerFirstAid\");\n          },\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"medicine\");\n          },\n        },\n        {\n          actionName: \"Treat Disease\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"treatDisease\");\n          },\n        },\n        {\n          actionName: \"Treat Poison\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"treatPoison\");\n          },\n        },\n        {\n          actionName: \"Treat Wounds\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            treatWounds();\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Nature\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"nature\");\n          }\n        },\n        {\n          actionName: \"Command an Animal\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"commandAnAnimal\");\n          },\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"nature\");\n          },\n        },\n        {\n          actionName: \"Identify Magic\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"nature\");\n          },\n        },\n        {\n          actionName: \"Learn a Spell\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"nature\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Occultism\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"occultism\");\n          }\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"occultism\");\n          },\n        },\n        {\n          actionName: \"Decipher Writing\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"decipherWriting\", \"occultism\");\n          },\n        },\n        {\n          actionName: \"Identify Magic\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"occultism\");\n          },\n        },\n        {\n          actionName: \"Learn a Spell\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"occultism\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Performance\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"performance\");\n          }\n        },\n        {\n          actionName: \"Perform\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"perform\");\n          },\n        },\n        {\n          actionName: \"Earn Income\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            earnIncome();\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Perception\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"perception\", true);\n          }\n        },\n        {\n          actionName: \"Seek\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"seek\");\n          },\n        },\n        {\n          actionName: \"Sense Motive\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"senseMotive\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Religion\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"religion\");\n          }\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"religion\");\n          },\n        },\n        {\n          actionName: \"Decipher Writing\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"decipherWriting\", \"religion\");\n          },\n        },\n        {\n          actionName: \"Identify Magic\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"religion\");\n          },\n        },\n        {\n          actionName: \"Learn a Spell\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"religion\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Society\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"society\");\n          }\n        },\n        {\n          actionName: \"Recall Knowledge\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            recallKnowledge(\"society\");\n          },\n        },\n        {\n          actionName: \"Subsist\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"subsist\", \"society\");\n          },\n        },\n        {\n          actionName: \"Create Forgery\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"createForgery\");\n          },\n        },\n        {\n          actionName: \"Decipher Writing\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"decipherWriting\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Stealth\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"stealth\");\n          }\n        },\n        {\n          actionName: \"Conceal an Object\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"concealAnObject\");\n          },\n        },\n        {\n          actionName: \"Hide\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"hide\");\n          },\n        },\n        {\n          actionName: \"Sneak\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"sneak\");\n          },\n        },\n        {\n          actionName: \"Create Forgery\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"createForgery\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Survival\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"survival\");\n          }\n        },\n        {\n          actionName: \"Sense Direction\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"senseDirection\");\n          },\n        },\n        {\n          actionName: \"Subsist\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"subsist\", \"survival\");\n          },\n        },\n        {\n          actionName: \"Cover Tracks\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"sur\");\n          },\n        },\n        {\n          actionName: \"Track\",\n          actionType: \"exp\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            coreAction(\"track\");\n          },\n        },\n      ],\n    },\n    {\n      skillName: \"Thievery\",\n      actions: [\n        {\n          actionName: \"Unspecified\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            unspecifiedActivity(\"theivery\");\n          }\n        },\n        {\n          actionName: \"Palm an Object\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"palmAnObject\");\n          },\n        },\n        {\n          actionName: \"Steal\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"steal\");\n          },\n        },\n        {\n          actionName: \"Disable Device\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 2,\n          command: () => {\n            coreAction(\"disableDevice\");\n          },\n        },\n        {\n          actionName: \"Pick a Lock\",\n          actionType: \"enc\",\n          proficiency: \"trained\",\n          prerequisite: null,\n          actionCost: 2,\n          command: () => {\n            coreAction(\"pickALock\");\n          },\n        },\n      ],\n    },\n    { skillName: \"-----Special Activities-----\", actions: [{ actionName: \"\", command: () => { } }] },\n    {\n      skillName: \"Escape\",\n      actions: [\n        {\n          actionName: \"Escape\",\n          actionType: \"enc\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: 1,\n          command: () => {\n            coreAction(\"escape\");\n          },\n        },\n      ]\n    },\n    {\n      skillName: \"Earn Income\",\n      actions: [\n        {\n          actionName: \"Earn Income\",\n          actionType: \"exp\",\n          proficiency: \"untrained\",\n          prerequisite: null,\n          actionCost: null,\n          command: () => {\n            earnIncome();\n          },\n        },\n      ],\n    },\n  ];\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Skill Action Dialog.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Skill Action Dialog","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"I81RRwf4MuEKJHOk","actorIds":[],"author":"N0XM9W70E7BAZnvQ","command":"/*Overdrive Macro by redeux\ntested V9 / pf2 3.2.2.10109\nBased off of PF2 wiki's generic customizable macro\nMajor thanks to stwlam for the massive legs crashing through some barriers I ran into (async roll after updating to V9 and sending dmg to chat)\n\nupdated to v10 and v11 by darkim\nalso did a few improvements\n*/\n\nfunction dsnHook(code) {\n    if (game.modules.get(\"dice-so-nice\")?.active && !game.settings.get(\"dice-so-nice\", \"immediatelyDisplayChatMessages\") && !game.modules.get(\"df-manual-rolls\")?.active) {\n        Hooks.once('diceSoNiceRollComplete', code);\n    } else {\n        code();\n    }\n}\n\nif (canvas.tokens.controlled.length < 1){\n    ui.notifications.warn('You need to select at least one token to perform Overdrive.');\n  } else {\n    const actors = canvas.tokens.controlled.flatMap((token) => token.actor ?? []);\n    const token_options = actors.reduce((acc, actor) => acc +=`<option value=\"${actor.id}\">${actor.name}</option>`, \"\");\n    \n    const overdrive = async ({\n        inventorTokenActor,\n       }) => {\n    \n        const skillName = \"Overdrive\";\n        const skillKey = \"crafting\";\n        const actionSlug = \"Overdrive\"\n        const actionName = \"Overdrive\"\n        \n        const modifiers = []\n        const OD_Succ_ITEM_UUID = 'Compendium.pf2e.feat-effects.MZDh3170EFIfOwTO'; // Effect: Overdrive (Success)\n        const OD_CrSu_ITEM_UUID = 'Compendium.pf2e.feat-effects.1XlJ9xLzL19GHoOL'; // Effect: Overdrive (Critical Success)\n        // get Main Actor\n\n        const options = inventorTokenActor.getRollOptions(['all', 'skill-check', skillName.toLowerCase()]);\n        options.push(`action:${actionSlug}`);\n\n        let DCbyLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50]\n        let DC = DCbyLevel[inventorTokenActor.system.details.level.value]\n        \n        game.pf2e.Check.roll(\n            new game.pf2e.CheckModifier(\n                `<span class=\"pf2-icon\">A</span> <b>${actionName}</b> - <p class=\"compact-text\">${skillName} Skill Check</p>`,\n                inventorTokenActor.skills[skillKey], modifiers),\n            { actor: inventorTokenActor, type: 'skill-check', options, dc: { value: DC } }, //for DC insert: , dc: {value: 30}\n            event,\n            async (roll) => {\n                if (roll.degreeOfSuccess === 3) {\n                    dsnHook(() => {\n                        ChatMessage.create({\n                            user: game.user.id,\n                            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                            flavor: `<strong>Critical Success</strong><br>Your gizmos go into a state of incredible efficiency called critical overdrive, adding great power to your attacks. Your Strikes deal additional damage equal to your Intelligence modifier for 1 minute. After the Overdrive ends, your gizmos become unusable as they cool down or reset, and you can't use Overdrive for 1 minute.<br>@UUID[Compendium.pf2e.feat-effects.Item.1XlJ9xLzL19GHoOL]{Effect: Overdrive (Critical Success)}`,\n                            speaker: ChatMessage.getSpeaker(),\n                        });\n                    });\n                    //apply crit effect\n                    const source = (await fromUuid(OD_CrSu_ITEM_UUID)).toObject();\n                    source.flags.core ??= {};\n                    source.flags.core.sourceId = OD_CrSu_ITEM_UUID;\n                    for await (const actor of actors) {\n                        const success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_Succ_ITEM_UUID);\n                        const cr_success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_CrSu_ITEM_UUID);\n                        if (cr_success_effect) {\n                            // nothing happens.\n                        } else if (success_effect) {\n                            source.system.start.initiative = success_effect.system.start.initiative;\n                            source.system.start.value = success_effect.system.start.value;\n                            source.system.duration.unit = \"rounds\";\n                            // yes, this is hacky but I found no other way.\n                            source.system.duration.value = Math.floor(success_effect.remainingDuration.remaining / 6);\n                            await success_effect.delete();\n                            await actor.createEmbeddedDocuments('Item', [source]);\n                        } else {\n                            await actor.createEmbeddedDocuments('Item', [source]);\n                        }\n                    };\n                } else if (roll.degreeOfSuccess === 2) {\n                    dsnHook(() => {\n                        ChatMessage.create({\n                            user: game.user.id,\n                            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                            flavor: `<strong>Success</strong><br>Your gizmos go into overdrive, adding power to your attacks.Your Strikes deal additional damage equal to half your Intelligence modifier for 1 minute. After the Overdrive ends, your gizmos become unusable as they cool down or reset, and you can't use Overdrive for 1 minute.<br>@UUID[Compendium.pf2e.feat-effects.Item.MZDh3170EFIfOwTO]{Effect: Overdrive (Success)}<br><br>\n                            <small><strong>Special</strong> When under the effects of Overdrive, you can still use the Overdrive action. You can't extend your Overdrive's duration this way, but you can turn an overdrive into a critical overdrive if you critically succeed. A failure has no effect on your current Overdrive, and you end your Overdrive on a critical failure.</small>\n                            `,\n                            speaker: ChatMessage.getSpeaker(),\n                        });\n                    });\n                    //apply success effect\n                    const source = (await fromUuid(OD_Succ_ITEM_UUID)).toObject();\n                    source.flags.core ??= {};\n                    source.flags.core.sourceId = OD_Succ_ITEM_UUID;\n                    for await (const actor of actors) {\n                        const success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_Succ_ITEM_UUID);\n                        const cr_success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_CrSu_ITEM_UUID);\n                        if (success_effect || cr_success_effect) {\n                            // nothing happens.\n                        } else {\n                            await actor.createEmbeddedDocuments('Item', [source]);\n                        }\n                    };\n                } else if (roll.degreeOfSuccess === 1) {\n                    dsnHook(() => {\n                        ChatMessage.create({\n                            user: game.user.id,\n                            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                            flavor: `<strong>Failure</strong><br>You make a miscalculation and nothing happens.`,\n                            speaker: ChatMessage.getSpeaker(),\n                        });\n                    });\n                } else if (roll.degreeOfSuccess === 0) {\n                    //crit fail damage\n                    let actorLevel = inventorTokenActor.system.details.level.value\n                    let DamageRoll = CONFIG.Dice.rolls.find((r) => r.name == \"DamageRoll\");\n                    dsnHook(() => {\n                        new DamageRoll(actorLevel + \"[fire]\").toMessage({ \n                            flavor: \"<strong>Overdrive Critical Malfunction !!</strong><br>Whoops! Something explodes.<br>You take fire damage equal to your level, and you can't use Overdrive again for 1 minute as your gizmos cool down and reset.\",\n                            speaker: ChatMessage.getSpeaker(),\n                        });\n                    });\n                    for await (const actor of actors) {\n                        const success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_Succ_ITEM_UUID);\n                        const cr_success_effect = actor.itemTypes.effect.find((effect) => effect.getFlag('core', 'sourceId') === OD_CrSu_ITEM_UUID);\n                        if (success_effect) {\n                            await success_effect.delete();\n                        } else if (cr_success_effect) {\n                            await cr_success_effect.delete();\n                        }\n                    };\n                }\n            },\n        );\n    }\n\nasync function applyChanges($html) {\n    const inventorTokenActor = actors.filter((actor) => actor.id === $html.find('[name=\"inventor\"]')[0].value)[0];\n    overdrive({inventorTokenActor});\n}\n\n/* Dialog box */\nconst renderDialogContent = ({\n    token_options,\n   }) => `\n    <div>\n      Temporarily cranking the gizmos on your body into overdrive, you try to add greater power to your attacks. Attempt a Crafting check that has a standard DC for your level.<br>\n    </div>\n    <hr/>\n    <form>\n      <div class=\"form-group\">\n        <label title=\"Select the Inventor\">Select Inventor:</label>\n        <select id=\"inventor\" name=\"inventor\">${token_options}</select>\n        </select>\n      </div>\n    </form>\n    `;\n\nconst dialog = new Dialog({\n    title: 'Overdrive',\n    content: renderDialogContent({\n        token_options,\n    }),\n    buttons: {\n        yes: {\n        icon: `<i class=\"fas fa-hand-holding-medical\"></i>`,\n        label: 'Confirm',\n        callback: applyChanges,\n        },\n        no: {\n        icon: `<i class=\"fas fa-times\"></i>`,\n        label: 'Cancel',\n        },\n    },\n    default: 'yes',\n    });\nawait dialog.render(true);\n\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Overdrive.js\" - Fetched on 2024-06-05T17:22:21.777Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Overdrive","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"JVbAV17ERqABE6sR","actorIds":[],"author":"jRsUxhkLhSD8R4sS","command":"/*\nContributed by Cerapter\n*/\n\nif (token?.actor?.type !== \"loot\") {\n  ui.notifications.error(`You must select at least one Merchant actor!`);\n} else if (token.actor.data.data.lootSheetType !== \"Merchant\") {\n  ui.notifications.error(`The selected actor must be a Merchant!`);\n} else {\n  showPopup(token.actor);\n}\n\nfunction showPopup(actor) {\n  new Dialog({\n    title: \"Adjust Prices\",\n    content: formatPopup(actor),\n    buttons: {\n      no: {\n        icon: '<i class=\"fas fa-times\"></i>',\n        label: \"Cancel\",\n      },\n      yes: {\n        icon: '<i class=\"fas fa-coins\"></i>',\n        label: \"Adjust\",\n        callback: ($html) => {\n          const inputs = $html[0].querySelectorAll(\"input[name]\");\n          const percentChange =\n            parseInt(\n              $html[0].querySelector(\"input[name='merchantAdjust.Percent']\")\n                .value,\n              10\n            ) ?? 100;\n\n          let updates = [];\n          for (let input of inputs) {\n            let item = actor.items.find((i) => i.id === input.name);\n            if (!!item) {\n              const newValue = game.pf2e.Coins.fromString(input.value);\n\n              updates.push({\n                _id: item.id,\n                \"data.price.value\": newValue.scale(percentChange / 100),\n              });\n            }\n          }\n          actor.updateEmbeddedDocuments(\"Item\", updates);\n        },\n      },\n    },\n    default: \"yes\",\n  }).render(true);\n}\n\nfunction formatPopup(actor) {\n  const weapon = gatherItems(actor.itemTypes.weapon);\n  const armour = gatherItems(actor.itemTypes.armor);\n  const equipment = gatherItems(actor.itemTypes.equipment);\n  const consumable = gatherItems(actor.itemTypes.consumable);\n  const treasure = gatherItems(actor.itemTypes.treasure);\n  const backpack = gatherItems(actor.itemTypes.backpack);\n\n  const generalSettings = generalSettingsToHTML();\n  const weaponHTML = formatItemsToHTML(\"Weapon\", weapon);\n  const armourHTML = formatItemsToHTML(\"Armour\", armour);\n  const equipmentHTML = formatItemsToHTML(\"Equipment\", equipment);\n  const consumableHTML = formatItemsToHTML(\"Consumable\", consumable);\n  const treasureHTML = formatItemsToHTML(\"Treasure\", treasure);\n  const backpackHTML = formatItemsToHTML(\"Container\", backpack);\n\n  return `${generalSettings}\n  <hr>\n  ${weaponHTML}\n  ${armourHTML}\n  ${equipmentHTML}\n  ${consumableHTML}\n  ${treasureHTML}\n  ${backpackHTML}\n  `;\n}\n\nfunction gatherItems(items) {\n  return items\n    .filter((notcoins) => notcoins.data.data.stackGroup !== \"coins\")\n    .map((item) => ({\n      id: item.id,\n      name: item.name,\n      price: item.data.data.price.value,\n    }));\n}\n\nfunction formatItemsToHTML(title, items) {\n  if (items.length === 0) {\n    return ``;\n  }\n\n  return `\n    <h1>${title}</h1>\n    <table class=\"pf2-table\">\n      <thead>\n        <tr>\n          <th>Name</th><th>New Price</th>\n        </tr>\n      </thead>\n      <tbody>\n      ${items\n        .map(\n          (item) => `\n          <tr><td>${item.name}</td><td><input name=\"${\n            item.id\n          }\" type=\"text\" value=\"${item.price.toString()}\" /></td></tr>`\n        )\n        .join(\"\")}\n      </tbody></table>`;\n}\n\nfunction generalSettingsToHTML() {\n  return `<h1>All</h1>\n  <form>\n  <div class=\"form-group\">\n    <label>Changes All Prices By Percent</label>\n    <div class=\"form-fields\">\n        <input type=\"number\" name=\"merchantAdjust.Percent\" value=\"100\">\n    </div>\n    <p class=\"notes\">\n      Every price will be automatically adjusted to this percentage (the default 100% will keep prices as-is). \n      This happens after your changing the prices.\n    </p>\n  </div>\n  </form>\n  `;\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Adjust Merchant Prices.js\" - Fetched on 2024-06-05T17:22:21.773Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Adjust Merchant Prices","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"LcsZnr5XELDwu2Ib","actorIds":[],"author":"a3HTKk3Vbqd3EMx8","command":"/* Original Author: ArthurTrumpet Modded by Symon S., volfied and alatar224.\n This Macro gives you an easy way to add new named cooldown effects to actors.\n Enter your desired duration in either a numerical value or a roll, like 1d4(default).\n Choose your unit type from the drop down menu. I added minutes, hours, and days for things like abilities with hourly cooldowns, spells with 1 minute durations, and afflictions that do things in x days.\n Choose a preset from the drop-down and it will automatically set the appropriate values and icon.\n Click the plus button to add or remove presets.\n \n# source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Modded Countdown Cooldown.js\" - Fetched on 2022-08-14T18:39:42.877Z\n*/\n\nconst effect = {\n    type: 'effect',\n    name: 'Countdown',\n    img: 'systems/pf2e/icons/spells/time-beacon.webp',\n    system: {\n      tokenIcon: {\n          show: true\n      },       \n      duration: {\n          value: 1,\n          unit: 'rounds',\n          sustained: false,\n          expiry: 'turn-start'\n      },\n      unidentified: false\n    },\n  };\n  \n  function pickIcon(event) {\n    const currentTarget = event.currentTarget;\n    console.log(currentTarget);\n    const fp = new FilePicker({\n        type: \"image\",\n        current: currentTarget.src,\n        button: \"image-picker\",\n        callback: (url) => {\n            document.getElementById(currentTarget.id).src = url;\n        },\n    });\n    fp.browse();\n  }\n  \n  function onMainRender(html) {\n  console.log(\"On render\", html);\n  document.getElementById(\"effect-icon\").addEventListener(\"click\", pickIcon);\n  document.getElementById(\"save-preset\").addEventListener(\"click\", presetDialog);\n  }\n  \n  function rewriteSelect(html) {\n  let presetsn = game.user.flags.world.countdownPresets;\n  let presets = '';\n  Object.values(presetsn).forEach(p => { presets += `<option value=\"${p.slug}\">${p.name}</option>`; });\n  document.getElementById(\"presets\").innerHTML = presets;\n  }\n  \n  async function countdownEffect() {\n  await initializePresets();\n  let presetsn = game.user.flags.world.countdownPresets;\n  let presets = '';\n  Object.values(presetsn).forEach(p => { presets += `<option value=\"${p.slug}\">${p.name}</option>`; });\n  const defPairs = Object.entries(presetsn)[0][1];\n  const defVals = { \"duration\":defPairs.duration, \"units\":defPairs.units, \"name\":defPairs.name, \"icon\":defPairs.icon, \"cooldown\":defPairs.cooldown };\n  const unitsn = [{value: \"rounds\", name: \"Rounds\"}, {value: \"minutes\", name: \"Minutes\"}, {value: \"hours\", name: \"Hours\"}, {value: \"days\", name: \"Days\"}];\n  let units = '';\n  unitsn.forEach(u => { units += `<option value=\"${u.value}\"${defVals.units === u.value ? ' selected' : ''}>${u.name}</option>`; });\n  console.log(defVals.cooldown);\n  let template = `\n  <script>\n    function assignValues(e) {\n      let presets = game.user.flags.world.countdownPresets;\n      let p = e.target.value\n      const insertDuration = presets[p].duration;\n      document.getElementById(\"countdowninput\").value = insertDuration;\n      const insertUnits = presets[p].units;\n      document.getElementById(\"countdownunits\").value = insertUnits;\n      const insertName = presets[p].name;\n      document.getElementById(\"countdownname\").value = insertName;\n      const insertIcon = presets[p].icon;\n      document.getElementById(\"effect-icon\").src = insertIcon;\n      const insertCooldown = presets[p].cooldown;\n      document.getElementById(\"cooldown\").checked = insertCooldown;\n    }\n  </script>\n  <div style=\"float: right\">\n    <p align=\"right\">Presets:<br>\n      <button id=\"save-preset\" type=\"button\" style=\"width:35px\">\n          <i class=\"fas fa-plus-square\"></i>\n        </button>\n      <select id=\"presets\" onchange=\"assignValues(event)\">${presets}</select>\n    </p>\n    <p align=\"right\">\n      <img id=\"effect-icon\" src=\"${defVals.icon}\" data-edit=\"img\" title=\"icon\" height=\"48\" width=\"48\">\n    </p>\n  </div>\n  <p>\n    Duration: <input id=\"countdowninput\" type=\"string\" style=\"width: 50px;\" value=\"${defVals.duration}\">\n  </p>\n  <p>\n    Units: <select id=\"countdownunits\">${units}</select>\n  </p>\n  <p>\n    Name: <input id=\"countdownname\" type=\"string\" style=\"width: 150px;\" value=\"${defVals.name}\">\n  </p> \n  <p>\n    <input type=\"checkbox\" id=\"cooldown\"${defVals.cooldown ? ' checked' : ''}/>Expire at End of round\n    </p>\n    <p>\n    <input type=\"checkbox\" id=\"unidentified\"${defVals.cooldown ? ' checked' : ''}/>Unidentified\n    </p>\n  `;\n  \n  new Dialog(\n    {\n      title: \"Countdown Effect\",\n      content: template,\n      buttons: {\n        ok: {\n          label: \"Apply\",\n          callback: (html) => {\n            clickOk(html);\n          },\n        },\n        cancel: {\n          label: \"Cancel\",\n        },\n      }, \n      render: onMainRender,\n    }, \n    { width: 400 }\n  ).render(true);\n  }\n  \n  function CheckFeat(slug, healer) {\n  if (healer.items.find((i) => i.slug === slug && i.type === 'feat')) {\n      return true;\n  }\n  return false;\n  }\n  \n  async function bmApply(html, html2) {\n  const bm_UUID = 'Compendium.pf2e.feat-effects.2XEYQNZTCGpdkyR6'; //Battle medicine Immunity effect\n  const showIcons = false;\n  const bmEffect = (await fromUuid(bm_UUID)).toObject();\n  bmEffect.system.tokenIcon.show = showIcons; //Potential for lots of effects to be on a token. Don't show icon to avoid clutter\n  bmEffect.flags.core ??= {};\n  bmEffect.flags.core.sourceId = bm_UUID;\n  \n  const applicator = game.actors.getName(html.find(\"#bmPC\")[0].value);\n  bmEffect.name = \"BM by \" + applicator.name;\n  //it was here\n  const isMedic = CheckFeat('medic-dedication', applicator);\n  const isgodless = CheckFeat('godless-healing', token.actor); //godless healing affects the patient, not the healer\n  const isForensic = CheckFeat('forensic-medicine-methodology', applicator);\n  // check if the person being healed is currently immune. If so, check if healer is a medic\n  var isImmune = token.actor.itemTypes.effect.find(obj => {\n      return obj.name === bmEffect.name\n  })\n  \n  if (isImmune) {\n      if (isMedic) {\n          var medicCooldown = applicator.itemTypes.effect.find(obj => {\n              return obj.name === \"Medic dedication used\"\n          })\n          if (medicCooldown) {\n              ui.notifications.warn(actor.name + \" is currently immune to Battle Medicine by \" + applicator.name);\n              return;\n          } else {\n              if (applicator.skills.medicine.rank > 2) {\n                  bmEffect.system.duration.unit = \"hours\"; //Cooldown of Medic Dedication depends on medicine skill rank\n              }\n              bmEffect.name = \"Medic dedication used\";\n              bmEffect.img = \"icons/magic/symbols/question-stone-yellow.webp\";\n              await applicator.createEmbeddedDocuments(\"Item\", [bmEffect]);\n              ui.notifications.info(applicator.name + \" has now used their Medic Dedication to Battle Medicine \" + actor.name);\n              return;\n          }\n      } else {\n          ui.notifications.warn(actor.name + \" is currently immune to Battle Medicine by \" + applicator.name);\n          return;\n      }\n  }\n  \n  if (isForensic || isgodless) {\n      bmEffect.system.duration.unit = \"hours\";\n  }\n  bmEffect.img = applicator.img;\n  await token.actor.createEmbeddedDocuments(\"Item\", [bmEffect]);\n  ui.notifications.info(token.actor.name + \" is now immune to Battle Medicine by \" + applicator.name);\n  }\n  \n  function battlemedicineEffect(html2) {\n  let playersNames = canvas.tokens.placeables.filter(pc => pc.actor.hasPlayerOwner && pc.actor.type === \"character\" && pc.actor.itemTypes.feat.some(x => x.slug === 'battle-medicine')).map(pc => pc.actor.name);\n    let playerNameList = '';\n    playersNames.map((pc) => {\n        playerNameList += `<option value=\"${pc}\"}>${pc}</option>`;\n    });\n    let template = `\n  <p>Character performing Battle Medicine:<br><select id=\"bmPC\">${playerNameList}</select></p> \n  `;\n  \n    new Dialog({\n        title: \"Battle Medicine Countdown\",\n        content: template,\n        buttons: {\n            ok: {\n                label: \"Apply\",\n                callback: (html) => {\n                    bmApply(html, html2);\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n            },\n        }\n    }, \n    { width: 300 }\n  ).render(true);\n  }\n  \n  async function clickOk(html) {\n  effect.name = html.find(\"#countdownname\")[0].value;\n  if (effect.name === 'Battle Medicine') {\n    if (canvas.tokens.controlled.length === 0) {\n      ui.notifications.warn(\"You must select a token before clicking Apply.\");\n    }\n    battlemedicineEffect(html);\n  } else if (effect.name === 'Cover') {\n    const actors = canvas.tokens.controlled.flatMap((token) => token.actor ?? []);\n    if (actors.length === 0 && game.user.character) actors.push(game.user.character);\n    if (actors.length === 0) {\n        const message = game.i18n.localize(\"PF2E.ErrorMessage.NoTokenSelected\");\n        return ui.notifications.error(message);\n    }\n  \n    const ITEM_UUID = \"Compendium.pf2e.other-effects.I9lfZUiCwMiGogVi\"; // Effect: Cover\n    const source = (await fromUuid(ITEM_UUID)).toObject();\n    source.flags = mergeObject(source.flags ?? {}, { core: { sourceId: ITEM_UUID } });\n    \n    for (const actor of actors) {\n        const existing = actor.itemTypes.effect.find((e) => e.flags.core?.sourceId === ITEM_UUID);\n        if (existing) {\n            await existing.delete();\n        } else {\n            await actor.createEmbeddedDocuments(\"Item\", [source]);\n        }\n    }\n  } else {\n    main(html);\n  }\n  }\n  \n  async function main(html, bmImg = null) {\n    let duration = html.find(\"#countdowninput\")[0].value;\n    const unit = html.find(\"#countdownunits\")[0].value;  \n    const isCooldown = html.find(\"#cooldown\")[0].checked; \n    const isUnidentified = html.find(\"#unidentified\")[0].checked;\n    effect.name = html.find(\"#countdownname\")[0].value;    \n    if (effect.name === 'Battle Medicine') {\n      effect.img = bmImg;\n    } else {\n      effect.img = html.find(\"#effect-icon\")[0].src;  \n    }\n    let countdownNumber = \"\";\n    if (duration.includes(\"d\")) {\n        countdownNumber = new Roll(duration).roll({ async : false }).total;\n    } else {\n        countdownNumber = duration;\n    }\n    if (isCooldown) {effect.system.duration.expiry = 'turn-end'};\n    if (isUnidentified) {\n      effect.system.unidentified = true;\n      effect.system.tokenIcon.show = false;\n  }\n    \n    effect.system.duration.unit = unit;\n    effect.system.duration.value = countdownNumber;\n    await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n  }\n  \n  const defaultIcon = \"systems/pf2e/icons/spells/time-beacon.webp\";\n  \n  const defaultPresets = [\n  {slug: \"battle_medicine\", name: \"Battle Medicine\", duration: \"24\", units: \"hours\", icon: \"icons/magic/symbols/question-stone-yellow.webp\", cooldown: false},\n  {slug: \"treat_wounds\", name: \"Treat Wounds\", duration: \"50\", units: \"minutes\", icon: \"systems/pf2e/icons/features/feats/treat-wounds.webp\", cooldown: false},\n  ];\n  \n  const defaultUnits = [\n  {value: \"rounds\", name: \"Rounds\"},\n  {value: \"minutes\", name: \"Minutes\"}, \n  {value: \"hours\", name: \"Hours\"},\n  {value: \"days\", name: \"Days\"},\n  ];\n  \n  async function savePreset(preset) {\n  console.log(\"Save preset\", preset);\n  return game.user.setFlag('world', 'countdownPresets', { [preset.slug]: preset });\n  }\n  \n  async function removePreset(name) {\n  console.log(\"Remove preset\", name);\n  return game.user.unsetFlag('world', `countdownPresets.${name}`);\n  }\n  \n  function getPresets() {\n  console.log(\"Get presets\", game.user.flags.world?.countdownPresets);\n  return game.user.flags.world?.countdownPresets || {};\n  }\n  \n  async function clearPresets() {\n  console.log(\"Clear presets\");\n  return await Promise.all(Object.keys(game.user.flags.world?.countdownPresets || {}).map(removePreset));\n  }\n  \n  async function initializePresets(reset = false) {\n  console.log(\"Initialize presets\");\n  if (reset) {\n    await clearPresets();\n    await Object.values(ui.windows).find(e => e.id === \"preset-dialog\").close();\n    if (!hasPresets()) {\n      await saveAllPresets(defaultPresets);\n    }\n    presetDialog();\n  } else {\n    if (!hasPresets()) {\n      await saveAllPresets(defaultPresets);\n    }\n  }\n  return getPresets();\n  }\n  \n  async function saveAllPresets(presets) {\n  console.log(\"Save all presets\", presets);\n  return Promise.all(presets.map(savePreset));\n  }\n  \n  function hasPresets() {\n  const ret = Object.keys(game.user.flags.world?.countdownPresets || {}).length > 0;\n  console.log(\"Has presets\", ret);\n  return ret;\n  }\n  \n  function getUnitsHtml(selected) {\n  console.log(\"Get units HTML\", selected);\n  return defaultUnits.map(u => `<option value=\"${u.value}\" ${u.value == selected ? \"selected\" : \"\"} >${u.name}</option>`).join(\"\");\n  }\n  \n  function getRowHtml(i, preset) {\n  console.log(\"Get row HTML\", i, preset);\n  const unitsHtml = getUnitsHtml(preset?.units);\n  return `<tr id=\"preset-row-${i}\" class=\"preset-row\">\n      <td><input name=\"${i}.name\" type=\"string\" style=\"width: 200px;\" value=\"${preset?.name || \"\"}\" /></td>\n      <td><input name=\"${i}.duration\" type=\"string\" style=\"width: 50px;\" value=\"${preset?.duration || \"\"}\" /></td>\n      <td><select name=\"${i}.units\">${unitsHtml}</select></td>\n      <td><input name=\"${i}.cooldown\" type=\"checkbox\" ${preset?.cooldown ? \"checked\" : \"\"} /></td>\n      <td><img class=\"effect-icon\" id=\"icon-${i}\" src=\"${preset?.icon || defaultIcon }\" height=\"35\" width=\"35\" /></td>\n      <td align=\"center\"><button class=\"delete-me\" value=\"${i}\" type=\"button\" style=\"width:27px;height:27px;padding:0;border:none;background:none\"><i class=\"fas fa-minus-square\"></i></button></td>\n    </tr>`\n  }\n  \n  function getTableHtml() {\n  console.log(\"Get table HTML\");\n  const rowsHtml = Object.values(getPresets()).map((preset, i) => getRowHtml(i, preset)).join(\"\");\n  return `<h3>Countdown Presets\n  <div style=\"float: right\">\n    <button id=\"reset-presets\" type=\"button\" style=\"width:27px;height:27px;padding:0;border:none;background:none\"><i class=\"fas fa-book-arrow-up\"></i></button>\n  </div></h3>\n    <form id=\"preset-form\">\n      <table id=\"preset-table\" style=\"border-collapse: separate; border-spacing:5px\">\n        <thead>\n          <tr>\n            <th>Name</th>\n            <th>Value</th>\n            <th>Units</th>\n            <th>Cool</th>\n            <th>Icon</th>\n            <th align=\"center\"><button id=\"add-row\" type=\"button\" style=\"width:27px;height:27px;padding:0;border:none;background:none\"><i class=\"fas fa-plus-square\"></i></button></th>\n          </tr>\n        </thead>\n        <tbody id=\"preset-table-body\">\n          ${rowsHtml}\n        </tbody>\n      </table>\n    </form>`;\n  }\n  \n  function addRow(i) {\n  console.log(\"Add row\", i);\n  document.getElementById(\"preset-table-body\").insertAdjacentHTML(\"beforeend\", getRowHtml(i));\n  const row = document.getElementById(`preset-row-${i}`);\n  attachEvents(row);\n  }\n  \n  function deleteRow(event) {\n  const i = event.currentTarget.value;\n  console.log(\"Delete row\", i);\n  const row = document.getElementById(`preset-row-${event.currentTarget.value}`)\n  removeEvents(row);\n  row.remove();\n  }\n  \n  function attachEvents(row) {\n  console.log(\"Attach events\", row);\n  row.querySelector(\".effect-icon\").addEventListener(\"click\", pickIcon);\n  row.querySelector(\".delete-me\").addEventListener(\"click\", deleteRow);\n  }\n  \n  function removeEvents(row) {\n  console.log(\"Remove events\", row);\n  row.querySelector(\".effect-icon\").removeEventListener(\"click\", pickIcon);\n  row.querySelector(\".delete-me\").removeEventListener(\"click\", deleteRow);\n  }\n  \n  function onPreRender(html) {\n  console.log(\"On preset render\", html);\n  let count = Object.keys(getPresets()).length;\n  html[0].querySelector(\"#add-row\").addEventListener(\"click\", event => addRow(count++));\n  html[0].querySelector(\"#reset-presets\").addEventListener(\"click\", event => initializePresets(true));\n  html[0].querySelectorAll(\".preset-row\").forEach(attachEvents);\n  }\n  \n  function getPresetData(formElement) {\n  console.log(\"Get preset data\", formElement);\n  const formData = new FormData(formElement);\n  const presets = {}\n  for (const [name, value] of formData.entries()) {\n    const [i, prop] = name.split(\".\");\n    if (!presets[i]) {\n      presets[i] = {};\n    }\n    presets[i][prop] = value;\n  }\n  // Now we need to iterate back through to populate the icon paths\n  for (const [i, preset] of Object.entries(presets)) {\n    // TODO Validate slug\n    preset.slug = preset.name.toLowerCase().match(/^((?!\\s\\().)+/)[0].replace(/[^a-z0-9 ]/g,'').replace(/\\s/,'_');;\n    // TODO Validate other inputs\n    // False values will be missing from FormData\n    preset.cooldown = !!preset.cooldown;\n    // Use getAttribute so we get back the relative URL\n    preset.icon = formElement.querySelector(`#icon-${i}`).getAttribute(\"src\");\n  }\n  return Object.values(presets);\n  }\n  \n  async function saveCallback(html) {\n  console.log(\"Save callback\", html);\n  const form = html[0].querySelector(\"#preset-form\");\n  await clearPresets();\n  await saveAllPresets(getPresetData(form));\n  rewriteSelect(html);\n  }\n  \n  async function presetDialog() {\n  console.log(\"Array test\");\n  // await initializePresets();\n  \n  new Dialog(\n    {\n      title: \"Countdown Effect\",\n      content: getTableHtml(),\n      buttons: {\n        ok: {\n          label: \"Save\",\n          callback: saveCallback,\n        },\n        cancel: {\n          label: \"Cancel\",\n        },\n      },\n      render: onPreRender,\n    },\n    { id: 'preset-dialog',\n      width: 500 }\n  ).render(true);\n  }\n  \n  // await presetDialog();\n  \n  countdownEffect();\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Advanced Countdown.js\" - Fetched on 2024-06-05T17:22:21.773Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Advanced Countdown","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"MX7HNH3tZHxTBdKv","actorIds":[],"author":"5mz9mrE6eH7ZNdqx","command":"/*\nBased on the macro Contributed by ArthurTrumpet\nmodified by darkim\n\nUses the a new effect to track who has demoralized whom.\nImmunity duration is set depending on several factors. Default is 10 minutes. \n\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst evangelizeEffect = {\n    type: 'effect',\n    name: 'Evangelize Immunity',\n    img: 'systems/pf2e/icons/spells/blind-ambition.webp',\n    system: {\n      tokenIcon: {\n          show: true\n      },       \n      duration: {\n          value: 24,\n          unit: 'hours',\n          sustained: false,\n          expiry: 'turn-start'\n      },\n      rules: [],\n    },\n  };\n\n\nif (!token) {\n    ui.notifications.error(\"No token selected!\");\n} else {\n    main();\n}\n\nasync function main() {\n    const message = game.messages.contents.reverse().find( m => m.flags.evangelize?.id === token.id);\n    if (message === undefined) {\n        ui.notifications.info(\"Wrong token selected!\");\n    } else {\n        const applicator = game.actors.get(message.flags.evangelize.evangelizeId);\n\n        evangelizeEffect.name = `Evangelize by ${message.flags.evangelize.evangelizeName}`;\n        evangelizeEffect.img = applicator.prototypeToken.texture.src;\n\n        if ( message.flags.evangelize.dos == 3 ) {\n            if (!token.actor.hasCondition(\"stupefied\") ) {\n                await token.actor.toggleCondition(\"stupefied\");\n            }\n            if (token.actor.getCondition(\"stupefied\").value < 2 ) {\n                await token.actor.increaseCondition(\"stupefied\");\n            }\n        } else if (message.flags.evangelize.dos == 2) {\n            if (!token.actor.hasCondition(\"stupefied\") ) {\n                await token.actor.toggleCondition(\"stupefied\");\n            }\n        }\n\n        await token.actor.createEmbeddedDocuments(\"Item\", [evangelizeEffect]);\n        ui.notifications.info(`${token.name} is now immune to Evangelize by ${message.flags.evangelize.evangelizeName}`);\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Evangelize Immunity CD.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Evangelize Immunity CD","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"OL49ul0SWEpVsxNs","actorIds":[],"author":"wQTWb6ApsRbY0QD2","command":"/* A quick Macro to pop up a notification with the DCs for spells based on level and rarity.\nThese DCs are used for counteract checks, learning a spell, etc.\nThese are NOT DCs for saves against these spells.*/\n\nconst rarity = await new Promise((resolve) => {\n new Dialog({\n title: 'Rarity?',\n buttons: {\n  com: { label: 'Common', callback: async(rar) => { resolve(0); } },\n  unc: { label: 'Uncommon', callback: async(rar) => { resolve(2); } },\n  rar: { label: 'Rare', callback: async(rar) => { resolve(5); } },\n  uni: { label: 'Unique', callback: async(rar) => { resolve(10); } },\n  },\n default: 'com',\n }).render(true);\n});\n\nconst level = await new Promise((resolve) => {\n new Dialog({\n title: 'Rank?',\n buttons: {\n  1: { label: '1', callback: async(rar) => { resolve(0); } },\n  2: { label: '2', callback: async(rar) => { resolve(1); } },\n  3: { label: '3', callback: async(rar) => { resolve(2); } },\n  4: { label: '4', callback: async(rar) => { resolve(3); } },\n  5: { label: '5', callback: async(rar) => { resolve(4); } },\n  6: { label: '6', callback: async(rar) => { resolve(5); } },\n  7: { label: '7', callback: async(rar) => { resolve(6); } },\n  8: { label: '8', callback: async(rar) => { resolve(7); } },\n  9: { label: '9', callback: async(rar) => { resolve(8); } },\n  10: { label: '10', callback: async(rar) => { resolve(9); } },\n  },\n }).render(true);\n});\n\nconst sDCs = [15,18,20,23,26,28,31,34,36,39];\nconst bDC = sDCs[level] + rarity;\nui.notifications.info(`The Spell DC is ${bDC}`);\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Spell DCs by Rank.js\" - Fetched on 2024-06-05T17:22:21.772Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Spell DCs by Rank","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"P5azZj1v0V8BlDd1","actorIds":[],"author":"5Ml7vQF7pOXeWzaf","command":"// Created by ArthurTrumpet\n// Heart icon idea from the Discord. Please contact if you know who came up with it so can attribute here.\n// Gives a health estimate and distance to the hovered token\n\nif (canvas.tokens.controlled.length === 0) {\n        ui.notifications.warn(\"You must select a token\");\n}\nelse if (canvas.tokens.hover?.actor.hitPoints.value == null) {\n        ui.notifications.warn(\"Not hovering over a token\");\n}\nelse {\n     let currentHealth = canvas.tokens.hover?.actor.hitPoints.value;\n      let maxHealth = canvas.tokens.hover?.actor.hitPoints.max;\n       let percentageHealth = (currentHealth/maxHealth)*100;\n        let distance = token.distanceTo(canvas.tokens.hover);\n         let distanceUI = (Math.ceil(distance)+ \" ft to pointer\");\n\n          if (percentageHealth > 85.5) { ui.notifications.info(\" - \" + distanceUI) }\n           else if (percentageHealth > 75) { ui.notifications.info(\" - \" + distanceUI) }\n            else if (percentageHealth > 62.5) { ui.notifications.info(\" - \" + distanceUI) }\n             else if (percentageHealth > 50) { ui.notifications.info(\" - \" + distanceUI) }\n              else if (percentageHealth > 37.5) { ui.notifications.info(\" - \" + distanceUI) }\n               else if (percentageHealth > 25) { ui.notifications.info(\" - \" + distanceUI) }\n                else if (percentageHealth > 12.5) { ui.notifications.info(\" - \" + distanceUI) }\n                 else if (percentageHealth > 0) { ui.notifications.info(\" - \" + distanceUI) }\n                  else { ui.notifications.info(\"\") }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Hearts and Distance.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Hearts and Distance","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"QEO3wxLHkoCR2frU","actorIds":[],"author":"eY6x1CYxuwi9IInd","command":"/*\nupdated by darkim\n\nRepair a thing other than an item (for that there is an Macro in the pf2e System which works really great - use it)\n\nCurrently the system macro only works with items. Not with companions or not when you just want to repair something in the world.\nHere is a small macro to just make a repair check and have a good output dependent on the result.\n\nLimitations:\n* Does not handle assurance.\n* Does not (yet) check if you have an repair kit or a feat that allows to repair without one.\n*/\n\n\n/**\n* Check if any itemType equipment of the actor matches a slug (and optionally checks in how many hands it is held)\n*\n* @param {string} slug Slug of the equipment to search\n* @param {int} hands Number of hands the item shall be held\n* @returns {boolean} true if the actor has a matching item equipment\n*/\nconst checkItemPresent = (slug, hands) =>\ntoken.actor.itemTypes.equipment.some(\n (equipment) => equipment.slug === slug && (!hands || equipment.handsHeld === hands)\n);\n\n/**\n* Wrapper for the DSN Hook. It will only use the hook if the non-buggy setting is not enabled.\n*\n* @param {Object} code code which will be executed\n*/\nfunction dsnHook(code) {\n    if (game.modules.get(\"dice-so-nice\")?.active && !game.settings.get(\"dice-so-nice\", \"immediatelyDisplayChatMessages\") && !game.modules.get(\"df-manual-rolls\")?.active) {\n        Hooks.once('diceSoNiceRollComplete', code);\n    } else {\n      code();\n    }\n}\n\n/**\n * Check wether the current actor has a feature.\n *\n * @param {string} slug\n * @returns {boolean} true if the feature exists, false otherwise\n */\nconst checkFeat = (slug) =>\ntoken.actor.items\n  .filter((item) => item.type === 'feat')\n  .some((item) => item.slug === slug);\n\n\nif (canvas.tokens.controlled.length !== 1){\n    ui.notifications.warn('You need to select exactly one token to perform repair.');\n} else {\n    const hasRepairKit = checkItemPresent('repair-kit') || checkItemPresent('repair-kit-superb');\n    // const hasRepairFeat = checkFeat('tinkering-fingers');\n\n    const skillName = \"Repair\";\n    const skillKey = \"crafting\";\n    const actionSlug = \"Repair\"\n    const actionName = \"Repair\"\n\n    const modifiers = []\n\n    let DCsByLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50]\n    let DC = DCsByLevel[token.actor.system.details.level.value] + 2\n\n    const options = token.actor.getRollOptions(['all', 'skill-check', skillName.toLowerCase()]);\n    options.push(`action:${actionSlug}`);\n    let DamageRoll = CONFIG.Dice.rolls.find((r) => r.name == \"DamageRoll\");\n    game.pf2e.Check.roll(\n        new game.pf2e.CheckModifier(\n            `<span class=\"pf2-icon\">A</span> <b>${actionName}</b> - <p class=\"compact-text\">${skillName} Skill Check</p>`,\n            token.actor.skills[skillKey], modifiers),\n        { actor: token.actor, type: 'skill-check', options, dc: { value: DC } }, //for DC insert: , dc: {value: 30}\n        event,\n        async (roll) => {\n            if (roll.degreeOfSuccess === 3) {\n                // crit success message\n                dsnHook(() => {\n                    new DamageRoll(`10 + ${token.actor.skills.crafting.rank} * 10`).toMessage({ \n                        flavor: `<strong>Critical Success</strong><br>You restore 10 Hit Points to the item, plus an additional 10 Hit Points per proficiency rank you have in Crafting (a total of 20 HP if youre trained, 30 HP if youre an expert, 40 HP if youre a master, or 50 HP if youre legendary).`,\n                        speaker: ChatMessage.getSpeaker(),\n                    });\n                });\n            } else if (roll.degreeOfSuccess === 2) {\n                // success message\n                dsnHook(() => {\n                    new DamageRoll(`5 + ${token.actor.skills.crafting.rank} * 5`).toMessage({ \n                        flavor: `<strong>Success</strong><br>You restore 5 Hit Points to the item, plus an additional 5 per proficiency rank you have in Crafting (for a total of 10 HP if you are trained, 15 HP if youre an expert, 20 HP if youre a master, or 25 HP if youre legendary).`,\n                        speaker: ChatMessage.getSpeaker(),\n                    });\n                });\n            } else if (roll.degreeOfSuccess === 1) {\n                // Fail message\n                dsnHook(() => {\n                    ChatMessage.create({\n                        user: game.user.id,\n                        type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n                        flavor: `<strong>Failure</strong><br>You fail to make the repair and nothing happens.`,\n                        speaker: ChatMessage.getSpeaker(),\n                    });\n                });\n            } else if (roll.degreeOfSuccess === 0) {\n                // crit fail damage\n                dsnHook(() => {\n                    new DamageRoll(\"2d6\").toMessage({ \n                        flavor: \"<strong>Critical Failure</strong><br>You deal 2d6 damage to the item. Apply the items Hardness to this damage.\",\n                        speaker: ChatMessage.getSpeaker(),\n                    });\n                });\n            }\n        },\n    );\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Repair.js\" - Fetched on 2024-06-05T17:22:21.777Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Repair","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"QZbrUi03cyIECAtw","actorIds":[],"author":"JYiZx8GT1KaHAybS","command":"/*\nAutomates Marshal Stances\nDoes not work without workbench module.\n*/\n\nif (!game.modules.get('xdy-pf2e-workbench')?.active) { return ui.notifications.error('This macro requires workbench module to be installed!'); }\nif (!actor || token.actor.type !== 'character') { return ui.notifications.warn(\"You must have a PC token selected\"); }\nif (canvas.tokens.controlled.length > 1) { return ui.notifications.warn(\"Please select the token with the Marshal Dedication\"); }\nif (!token.actor.itemTypes.feat.some(ms => ms.slug === \"dread-marshal-stance\" || ms.slug === \"inspiring-marshal-stance\" || ms.slug === \"devrins-cunning-stance\")) { return ui.notifications.warn(\"The actor does not possess a Marshal Stance feat\"); }\nconst modifiers = [];\nconst level = token.actor.level;\nlet skillName,skillKey,actionSlug,actionName,choice,notes;\nlet buttons = {};\nif (token.actor.itemTypes.feat.some(ms => ms.slug === \"inspiring-marshal-stance\")) { \n  buttons.ims = { label: 'Inspiring Marshal Stance' };\n}\nif (token.actor.itemTypes.feat.some(ms => ms.slug === \"dread-marshal-stance\")) {\n  buttons.dms = { label: 'Dread Marshal Stance' };\n}\nif (token.actor.itemTypes.feat.some(ms => ms.slug === \"devrins-cunning-stance\")) { \n  buttons.dcs = { label: 'Devrins Cunning Stance' };\n}\n\nif (Object.keys(buttons).length > 1) {\n  let width = 400;\n  if (Object.keys(buttons).length > 2 ) { width = 600 }\n  choice = await Dialog.wait({\n    title: 'Which Stance?',\n    buttons,\n    close: () => { return \"close\" }\n  },{width});\n}\nelse {\n  choice = Object.keys(buttons)[0];\n}\n\nif ( choice === \"close\" ) { return ui.notifications.warn(\"You did not select a stance\"); }\n\nlet img = 'systems/pf2e/icons/features/feats/dread-marshal-stance.webp'\nlet stance = 'dmscf';\nif (choice === \"ims\") {\n  if (token.actor.itemTypes.effect.some(e => e.slug === 'imscf')) { return ui.notifications.warn('You cannot enter a marshal stance while in cooldown!'); }\n  stance = 'imscf';\n  img = 'systems/pf2e/icons/features/feats/inspiring-marshal-stance.webp'\n  skillName = \"Diplomacy\";\n  skillKey = \"diplomacy\";\n  notes = [];\n  actionSlug = \"inspiring-marshal-stance\";\n  actionName = \"Inspiring Marshal Stance\";\n  notes.push({\"outcome\":[\"success\"], \"selector\":\"diplomacy\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.kzEPq4aczYb6OD2h]{Marshal's Aura} grants you and allies a +1 status bonus to attack rolls and saves against mental effects.</p>`});\n  notes.push({\"outcome\":[\"criticalSuccess\"], \"selector\":\"diplomacy\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.kzEPq4aczYb6OD2h]{Marshal's Aura} increases to 20 feet and grants you and allies a +1 status bonus to attack rolls and saves against mental effects.</p>`});\n  notes.push({\"outcome\":[\"failure\"], \"selector\":\"diplomacy\", \"text\":`<p>You fail to enter the stance.</p>`});\n  notes.push({\"outcome\":[\"criticalFailure\"], \"selector\":\"diplomacy\", \"text\":`<p>You fail to enter the stance and can't take this action again for 1 minute.</p>`});\n}\nif (choice === \"dms\") {\n  if (token.actor.itemTypes.effect.some(e => e.slug === 'dmscf')) { return ui.notifications.warn('You cannot enter a marshal stance while in cooldown!'); }\n  skillName = \"Intimidation\";\n  skillKey = \"intimidation\"\n  notes = [];\n  actionSlug = \"dread-marshal-stance\";\n  actionName = \"Dread Marshal Stance\";\n  notes.push({\"outcome\":[\"success\"], \"selector\":\"intimidation\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.KBEJVRrie2JTHWIK]{Marshal's Aura} grants you and allies a status bonus to damage rolls equal to the number of weapon damage dice of the unarmed attack or weapon you are wielding that has the most weapon damage dice. When you or an ally in the aura critically hits an enemy with a Strike, that enemy is @Compendium[pf2e.conditionitems.TBSHQspnbcqxsmjL]{Frightened 1}.</p>`});\n  notes.push({\"outcome\":[\"criticalSuccess\"], \"selector\":\"intimidation\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.KBEJVRrie2JTHWIK]{Marshal's Aura} increases to 20 feet, and it grants you and allies a status bonus to damage rolls equal to the number of weapon damage dice of the unarmed attack or weapon you are wielding that has the most weapon damage dice. When you or an ally in the aura critically hits an enemy with a Strike, that enemy is @Compendium[pf2e.conditionitems.TBSHQspnbcqxsmjL]{Frightened 1}.</p>`});\n  notes.push({\"outcome\":[\"failure\"], \"selector\":\"intimidation\", \"text\":`<p>You fail to enter the stance.</p>`});\n  notes.push({\"outcome\":[\"criticalFailure\"], \"selector\":\"intimidation\", \"text\":`<p>You fail to enter the stance and can't take this action again for 1 minute.</p>`});\n}\nif (choice === \"dcs\") {\n  if (token.actor.itemTypes.effect.some(e => e.slug === 'dcscf')) { return ui.notifications.warn('You cannot enter a marshal stance while in cooldown!'); }\n  stance = \"dcscf\"\n  img = \"systems/pf2e/icons/spells/anticipate-peril.webp\"\n  skillName = \"Deception\";\n  skillKey = \"deception\"\n  notes = [];\n  actionSlug = \"devrins-cunning-stance\";\n  actionName = \"Devrin's Cunning Stance\";\n  notes.push({\"outcome\":[\"success\"], \"selector\":\"deception\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.jACKRmVfr9ATsmwg]{Marshal's Aura} grants you and your allies a +1 status bonus to skill checks. When you or an ally in the aura Strike an @UUID[Compendium.pf2e.conditionitems.Item.AJh5ex99aV6VTggg] enemy, that enemy cant use reactions until the beginning of its next turn.</p>`});\n  notes.push({\"outcome\":[\"criticalSuccess\"], \"selector\":\"deception\", \"text\":`<p>Your @Compendium[pf2e.feat-effects.jACKRmVfr9ATsmwg]{Marshal's Aura} increases to a 20-foot emanation, and it grants you and your allies a +1 status bonus to skill checks. When you or an ally in the aura Strike an @UUID[Compendium.pf2e.conditionitems.Item.AJh5ex99aV6VTggg] enemy, that enemy cant use reactions until the beginning of its next turn.</p>`});\n  notes.push({\"outcome\":[\"failure\"], \"selector\":\"deception\", \"text\":`<p>You fail to enter the stance.</p>`});\n  notes.push({\"outcome\":[\"criticalFailure\"], \"selector\":\"deception\", \"text\":`<p>You fail to enter the stance and can't take this action again for 1 minute.</p>`});\n}\n\nconst custom = await new Promise((resolve) => {\n  new Dialog({\n  \ttitle: 'Custom DC?',\n    buttons: {\n      yes: { label: 'Yes', callback: async() => { resolve(true); } },\n      no: { label: 'No', callback: async() => { resolve(false); } },\n    },\n    default: 'no',\n    close: () => { return; }\n  }).render(true);\n});\n\nconst DCbyLevel = [14,15,16,18,19,20,22,23,24,26,27,28,30,31,32,34,35,36,38,39,40,42,44,46,48,50]\n\nlet DC = DCbyLevel[level];\n\nconst options = token.actor.getRollOptions(['all', 'skill-check', skillName.toLowerCase()]);\noptions.push(`action:${actionSlug}`);\n\nif (custom) { await new Promise(() => {\n    new Dialog({\n      title: 'Enter a custom DC',\n      content: `DC:&nbsp <input id=\"dcinput\" type=\"number\" autofocus style=\"width: 25px;text-align: center;\" value=''>`,\n      buttons: {\n        enter: { label: 'Enter', callback: (html) => { main(html); } },\n        cancel: { label: 'Cancel', callback: () => { return; } },\n      },\n      default: 'enter',\n      close: () => { return; }\n    }).render(true);\n  });\n}\n\nelse { await SRoll(); }\n\nasync function main(html) {\n  DC = parseInt(html.find(\"#dcinput\")[0].value);\n  if ( isNaN(DC) ) { return ui.notifications.warn('Please enter a numerical value for your custom DC'); }\n  await SRoll();\n}\n\nasync function SRoll() {\n  const roll = await game.pf2e.Check.roll(\n    new game.pf2e.CheckModifier(\n      `<span class=\"pf2-icon\">A</span> <b>${actionName}</b><br><p class=\"compact-text\">${skillName } Skill Check</p>`,\n\t  token.actor.skills[skillKey], modifiers\n    ),\n    { actor: token.actor, type: 'skill-check', options, notes, flag: 'marshal-stance', dc: { value: DC }, skipDialog: true },\n\tnull,\n  );\n\n  if (roll.options.degreeOfSuccess > 1) {\n    if(choice === 'dms'){\n      const effect = (await fromUuid('Compendium.pf2e.feat-effects.qX62wJzDYtNxDbFv')).toObject();\n      effect.img = img;\n      effect.system.rules.shift();\n      effect.system.rules[0].radius = 10;\n      if (roll.options.degreeOfSuccess === 3) { effect.system.rules[0].radius = 20; }\n      effect.system.rules[0].slug = \"marshal-drd-stance\";\n      await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n    }\n      if (choice === 'ims'){\n        const effect = (await fromUuid(\"Compendium.pf2e.feat-effects.er5tvDNvpbcnlbHQ\")).toObject();\n        effect.img = img;\n        effect.system.rules.shift();\n        effect.system.rules[0].radius = 10;\n        if (roll.options.degreeOfSuccess === 3) { effect.system.rules[0].radius = 20; }\n        effect.system.rules[0].slug = \"marshal-insp-stance\";\n        await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n      }\n      if(choice === 'dcs'){\n        const effect = (await fromUuid('Compendium.pf2e.feat-effects.Item.kyrvZfZfzKK1vx9b')).toObject();\n        effect.img = img;\n        effect.system.rules.shift();\n        effect.system.rules[0].radius = 10;\n        if (roll.options.degreeOfSuccess === 3) { effect.system.rules[0].radius = 20; }\n        effect.system.rules[0].slug = \"marshal-dcs-stance\";\n        await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n      }\n  }\n  if (roll.options.degreeOfSuccess === 0) {\n    const effect = {     \n      type: 'effect',\n      name: 'Marshal Stance Critical Failure Cooldown',\n      img: img,\n      system: {\n        slug: stance,\n        tokenIcon: {\n          show: true\n        },       \n        duration: {\n          value: 1,\n          unit: 'minutes',\n          sustained: false,\n          expiry: 'turn-end'\n        }\n      },\n    };\n    await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n  }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Marshal Stances.js\" - Fetched on 2024-06-05T17:22:21.770Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Marshal Stances","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"SWSNTUL7Lrb4asFB","actorIds":[],"author":"9Zhd4Vmkl7WtsxDO","command":"/*\nThis version of the Force Barrage Macro Automatically expends slots(prepared), spell uses(spontaneous), charges(wands), and consumes scrolls.\nWhen Wand of Shardstorm is used, it places an effect on the character that allows it to tell if you are using the lingering effect of those wands. This adds the option to terminate the effect from within the dialog box through a checkbox (nothing else happens), or select the effect and have it shoot a Force Barrage as per the wand's description.\nDo not make spellcasting entries for your wands or scrolls.\nFor staves please use a spellcasting entry due to the nature of how staves work.\nThe macro will not prompt for trick magic item due to DCs being variable. May change this in the future.\n\nThis macro was modified slightly by Syven to include jb2a's animations.\nFurther modified by MrVauxs to be usable with and without animations.\n\nAnd again by MrVauxs to include PF2e Target Damage compatibility.\n\nModified once again by Maximus to add compatibility with Unleash Psyche\n*/\n\nif (!token) { return ui.notifications.warn(\"You must have a token selected\") }\n\nconst mani = [\"wand-of-shardstorm-1st-rank-spell\", \"wand-of-shardstorm-3rd-rank-spell\", \"wand-of-shardstorm-5th-rank-spell\", \"wand-of-shardstorm-7th-rank-spell\"]\nif (!token.actor.itemTypes.spell.some(s => s.slug === 'force-barrage') && !token.actor.itemTypes.consumable.some(s => s.system.spell?.system?.slug === 'force-barrage') && !token.actor.itemTypes.equipment.some(s => mani.includes(s.slug))) { \n\treturn ui.notifications.error('You do not have Force Barrage') \n}\nif (game.user.targets.ids === undefined || game.user.targets.ids.length === 0) { return ui.notifications.error('At least 1 target is required'); }\n\nconst DamageRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"DamageRoll\"));\nconst mmE = token.actor.itemTypes.spellcastingEntry.filter(m => m.spells?.some(x => x.slug === 'force-barrage'));\n\nconst mmIds = [];\nfor (const id of token.actor.itemTypes.spell) {\n\tif (id.slug === 'force-barrage') { mmIds.push(id.id); }\n};\n\nconst mm = [];\n\nfor (const e of mmE) {\n\tconst spellData = await e.getSheetData();\n\tfor (const sp of spellData.groups) {\n\t\tif (sp.uses !== undefined && sp.id !== \"cantrips\" && sp.uses?.value < 1) { continue; }\n\t\tlet i = 0;\n\t\tfor (const spa of sp.active) {\n\t\t\tconst index = i++\n\t\t\tif (spa === null) { continue; }\n\t\t\tif (spa.spell.slug !== \"force-barrage\") { continue; }\n\t\t\tif (spa.expended) { continue; }\n\t\t\tif (spellData.isFocusPool && !spa.spell.isCantrip && token.actor.system.resources.focus.value === 0) { continue; }\n\t\t\tconst level = sp.id === \"cantrips\" ? `Cantrip ${sp.maxRank}` : `Rank ${sp.maxRank}`;\n\t\t\tconst lvl = sp.id === \"cantrips\" ? 0 : sp.maxRank;\n\t\t\tconst rank = sp.maxRank;\n\t\t\tconst name = spa.spell.name;\n\t\t\tconst sname = `${name} ${level} (${e.name})`;\n\t\t\tmm.push({ name: sname, entryId: spellData.id, rank, lvl, spId: spa.spell.id, slug: spa.spell.slug, spell: spa.spell, index, link:spa.spell.link });\n\t\t};\n\t};\n};\n\nmm.sort((a, b) => {\n    if (a.lvl === b.lvl)\n    \treturn a.name\n      \t.toUpperCase()\n      \t.localeCompare(b.name.toUpperCase(), undefined, {\n        \tsensitivity: \"base\",\n      \t});\n    return a.lvl - b.lvl;\n});\n\nfor (const s of token.actor.itemTypes.consumable) {\n\tif (!s.system.traits.value.includes(\"wand\") && !s.system.traits.value.includes(\"scroll\")) { continue; }\n\tif (s.system.spell?.system?.slug === 'force-barrage') {\n\t\tif (s.system.traits.value.includes(\"wand\") && s.system.uses?.value > 0) {\n\t\t\tmm.push({ name: `${s.name}`, rank: s.system.spell.system.location.heightenedLevel, prepared: false, entryId: s.id, wand: true, scroll: false, spont: false, link: s.link})\n\t\t}\n\t\tif (s.system.traits.value.includes(\"scroll\")) {\n\t\t\tmm.push({ name: `${s.name}`, rank: s.system.spell.system.location.heightenedLevel, prepared: false, entryId: s.id, wand: false, scroll: true, spont: false, link: s.link })\n\t\t}\n\t}\n};\nfor (const s of token.actor.itemTypes.equipment) {\n\tif (mani.includes(s.slug)) {\n\t\tmm.push({ name: `${s.name}`, rank: parseInt(s.slug.substr(19, 1)), prepared: false, entryId: s.slug, wand: true, scroll: false, spont: false, link: s.link });\n\t}\n};\n\nif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) {\n\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\");\n\tmm.unshift({ name: `${effect.name}`, rank: effect.system.level.value, prepared: false, entryId: null, wand: false, scroll: false, spont: false, link: effect.link });\n}\n\nif (mm.length === 0) { return ui.notifications.warn(\"You currently have no available means of casting Force Barrage\"); }\n\nconst mmdd = [{ label: 'Which spell?', type: 'select', options: mm.map(n => n.name) },\n{ label: 'Number of Actions?', type: 'select', options: [3, 2, 1] }\n];\n\nif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) { mmdd.push({ label: `Remove Effect Instead?`, type: \"checkbox\" }) }\n\nconst mmdiag = await quickDialog({ data: mmdd, title: `Force Barrage` });\n\nif (mmdiag[2] === true) {\n\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\")\n\tawait effect.delete();\n\treturn;\n}\n\nconst mmch = mm.find(n => n.name === mmdiag[0]);\nif (mmch.entryId === null) { mmdiag[1] = 1 }\n\nconst multi = parseInt(mmdiag[1]) * Math.floor((1 + mmch.rank) / 2);\n\nconst targetIds = game.user.targets.ids;\nconst targets = game.user.targets.values().toArray();\n\nconst script1 = function THoverIn(event) {\n\tconst tok = game.user.targets.find(x => x.id === event.id);\n\ttok._onHoverIn(event)\n}\n\nconst script2 = function THoverOut(event) {\n\tconst tok = game.user.targets.find(x => x.id === event.id);\n\ttok._onHoverOut(event)\n}\n\nconst tdata = [];\nlet i = 0;\nfor (const t of targets) {\n\t++i\n\tif (t.actor.hasPlayerOwner) { ui.notifications.info(`${t.name} is most likely an ally`); }\n\tconst label = t.document.displayName <= 20 && !t.actor.isOwner && t.name.includes(t.actor.name) ? `<script>${script1}${script2}</script><img src=${t.document.texture.src} style=\"width:50px; height:50px\" onmouseover=\"THoverIn(this)\" onmouseout=\"THoverOut(this)\" id=${t.id}><figcaption>Target #${i}</figcaption>` : t.name;\n\ttdata.push({ label, type: 'number', options: [1] });\n};\n\n\nif (targetIds.length === 1) { tdata[0].options = [multi]; }\n\nconst tdiag = await quickDialog({ data: tdata, title: `Distribute ${multi} Barrages` });\n\nlet tot = 0;\ni = undefined;\nlet c = 1;\nconst fmm = [];\nfor (const m of tdiag) {\n\ttot = tot + m\n\tif (i !== undefined) { i++ }\n\tif (i === undefined) { i = 0 }\n\tconst name = targets[i].document.displayName <= 20 && !targets[i].actor.isOwner && targets[i].name.includes(targets[i].actor.name) ? `<img src=${targets[i].document.texture.src} style=\"width:50px; height:50px\"><figcaption>Target #${c}</figcaption>` : targets[i].name;\n\tc++\n\tfmm.push({ name, num: m , uuid: targets[i].document.uuid })\n};\n\nif (tot > multi) { return ui.notifications.warn(`You have entered ${tot - multi} too many missiles. Please try again`) }\nif (tot < multi) { return ui.notifications.warn(`You have entered ${multi - tot} too few missiles. Please try again`) }\n\nlet expend = true;\nlet targetNum = 0;\nfor (const a of fmm) {\n\tif (a.num === 0 || a.num === undefined) { continue; }\n\n\tlet dam;\n\t\n\tif(token.actor.itemTypes.feat.some(ds => ds.slug === 'dangerous-sorcery')) {\n\n\t\t dam = `(${a.num}d4 + ${a.num} + ${mmch.rank})[force]`;\n\n\t} else if(token.actor.itemTypes.effect.some(ef => ef.slug === \"effect-unleash-psyche\")) {\n\n\t\t dam = `(${a.num}d4 + ${a.num} + ${2*(mmch.rank)})[force]`;\n\n\t} else {\n\n\t\t dam = `(${a.num}d4 + ${a.num})[force]`;\n\n\t}\n\t\n\tconst droll = new DamageRoll(dam);\n\tdroll.toMessage(\n\t\t{\n\t\t\tflags: {\"pf2e-toolbelt.targetHelper.targets\": [a.uuid]},\n\t\t\tflavor: `<strong>${a.name} was targeted by ${a.num} Force Barrage(s)</strong><br>${mmch.link}`,\n\t\t\tspeaker: ChatMessage.getSpeaker(),\n\t\t}\n\t);\n\n\tif (game.modules.get(\"sequencer\")?.active && (game.modules.get(\"JB2A_DnD5e\")?.active || game.modules.get(\"jb2a_patreon\")?.active)) {\n\t\tnew Sequence()\n\t\t.effect()\n\t\t.file(`jb2a.magic_missile`)\n\t\t.atLocation(canvas.tokens.controlled[0])\n\t\t.stretchTo(targets[targetNum])\n\t\t.repeats(a.num, 100, 300)\n\t\t.delay(300, 600)\n\t\t.play()\n\t}\n\ttargetNum++\n};\n\nconst s_entry = mmE.find(e => e.id === mmch.entryId);\n\n/* Expend slots */\nif (!mmch.wand && !mmch.scroll && expend) {\n\tawait s_entry.cast(mmch.spell, { slotId: mmch.index, rank: mmch.rank, message: false });\n}\n\n\n/* Wand */\nif (mmch.wand) {\n\tif (mani.includes(mmch.entryId)) {\n\t\tif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) {\n\t\t\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\")\n\t\t\tawait effect.delete();\n\t\t}\n\t\tif (!token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) {\n\t\t\tconst maniEF = {\n\t\t\t\t\"name\": `${mmch.name} Effect`,\n\t\t\t\t\"type\": \"effect\",\n\t\t\t\t\"img\": \"systems/pf2e/icons/equipment/wands/specialty-wands/wand-of-manifold-missiles.webp\",\n\t\t\t\t\"system\": {\n\t\t\t\t\t\"description\": {\n\t\t\t\t\t\t\"value\": `<p><strong>Requirements</strong> You used Wand of Shardstorm to cast Force Barrage.</p>\\n<hr />\\n<p>After you cast the spell, an additional barrage or barrages are released from the wand at the start of each of your turns, as though you cast the 1-action version of force barrage. Choose targets each time. This lasts for 1 minute, until you are no longer wielding the wand, or until you try to activate the wand again.</p>`\n\t\t\t\t\t},\n\t\t\t\t\t\"slug\": \"maniEF\",\n\t\t\t\t\t\"level\": {\n\t\t\t\t\t\t\"value\": mmch.rank\n\t\t\t\t\t},\n\t\t\t\t\t\"duration\": {\n\t\t\t\t\t\t\"value\": 1,\n\t\t\t\t\t\t\"unit\": \"minutes\",\n\t\t\t\t\t\t\"sustained\": false,\n\t\t\t\t\t\t\"expiry\":\"turn-start\"\n\t\t\t\t\t},\n\t\t\t\t\t\"tokenIcon\": {\n\t\t\t\t\t\t\"show\": true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait actor.createEmbeddedDocuments('Item', [maniEF]);\n\t\t}\n\t}\n\telse {\n\t\tconst w = token.actor.itemTypes.consumable.find(id => id.id === mmch.entryId);\n\t\tconst wData = duplicate(w);\n\t\twData.system.uses.value--;\n\t\tawait actor.updateEmbeddedDocuments('Item', [wData]);\n\t}\n}\n\n/* Scroll */\nif (mmch.scroll) {\n\tconst s = token.actor.itemTypes.consumable.find(id => id.id === mmch.entryId);\n\tif (s.system.quantity > 1) {\n\t\tconst sData = duplicate(s);\n\t\tsData.system.quantity--;\n\t\tawait actor.updateEmbeddedDocuments('Item', [sData]);\n\t}\n\telse { await s.delete(); }\n}\n\n\n/* Dialog box */\nasync function quickDialog({ data, title = `Quick Dialog` } = {}) {\n\tdata = data instanceof Array ? data : [data];\n\n\treturn await new Promise(async (resolve) => {\n\t\tlet content = `\n\t\t\t<table style=\"width:100%\">\n\t\t  \t${data.map(({ type, label, options }, i) => {\n\t\t\tif (type.toLowerCase() === `select`) {\n\t\t\t\treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e, i) => `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n\t\t\t} else if (type.toLowerCase() === `checkbox`) {\n\t\t\t\treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n\t\t\t} else {\n\t\t\t\treturn `<tr><th style=\"width:90%\"><label>${label}</label></th><td style=\"width:10%\"><input type=\"${type}\" style=\"text-align:center\" autofocus id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n\t\t\t}\n\t\t}).join(``)}\n\t\t\t</table>`;\n\n\t\tawait new Dialog({\n\t\t\ttitle, content,\n\t\t\tbuttons: {\n\t\t\t\tOk: {\n\t\t\t\t\tlabel: `Ok`, callback: (html) => {\n\t\t\t\t\t\tresolve(Array(data.length).fill().map((e, i) => {\n\t\t\t\t\t\t\tlet { type } = data[i];\n\t\t\t\t\t\t\tif (type.toLowerCase() === `select`) {\n\t\t\t\t\t\t\t\treturn html.find(`select#${i}qd`).val();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tswitch (type.toLowerCase()) {\n\t\t\t\t\t\t\t\t\tcase `text`:\n\t\t\t\t\t\t\t\t\tcase `password`:\n\t\t\t\t\t\t\t\t\tcase `radio`:\n\t\t\t\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].value;\n\t\t\t\t\t\t\t\t\tcase `checkbox`:\n\t\t\t\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].checked;\n\t\t\t\t\t\t\t\t\tcase `number`:\n\t\t\t\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].valueAsNumber;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdefault: 'Ok'\n\t\t})._render(true);\n\t\tdocument.getElementById(\"0qd\").focus();\n\t},{width:\"auto\",height:\"auto\"});\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Force Barrage.js\" - Fetched on 2024-06-05T17:22:21.769Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Force Barrage","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"XWFGrYfbaWdWx5xd","actorIds":[],"author":"k2gAzBCzO9O1iNJG","command":"/*\nThis Macro pulls all the PCs with player owners who are online and consumes x amount of rations\nIt uses the consume function from system, so it is a little spammy.\nWhen finished it will output how many days of rations were consumed over the elapsed time.\nIt will also fire warnings to the GM when PCs have no more rations\n*/\n\nif (!game.user.isGM) { return ui.notifications.warn(\"This Macro can only be used by the GM\");}\nconst uIds = game.users.filter(x => !x.isGM && x.active).map(i => i.id);\nif (uIds.length < 1) { return ui.notifications.warn(\"This Macro requires players to be logged into the game to work.\") }\nconst days = await Dialog.wait({\n    title: \"Ration Consumer\",\n    content: `<table><tr><th>How many days worth?</th> <th><input id =\"days\" type=\"number\" autofocus onfocus=\"this.select()\" value=\"1\"></th></tr></table>`,\n    buttons: {\n        ok: {\n            icon: '<i class=\"fas fa-meat\"></i>',\n            label: \"Consume\",\n            callback: (html) => {\n                return html[0].querySelector(\"#days\").value;\n            }\n        },\n        cancel: {\n            label: \"Cancel\",\n        }\n    },\n    close: () => { return \"cancel\" },\n    default:\"ok\",\n},{width:300});\nif (days === \"cancel\") { return }\nconst consume = Array.fromRange(days,1);\nlet ate = [];\nconst comp = [\"Construct Companion\",\"Eidolon\",\"Animal Companion\"]\nfor (a of game.actors.contents) {\n    let tof = false;\n    for (ids of uIds) {\n        if (a.ownership[ids] === 3) { tof = true; }\n    }\n    if (a.type !== \"character\" || !a.hasPlayerOwner || !tof || comp.includes(a.class.name)) {\n        continue;\n    }\n    if (!a.itemTypes.consumable.some(r => r.slug === \"rations\")) { \n        ui.notifications.warn(`${a.name} has no rations left`);\n        ate.push({name:a.name, xdays:0})\n        continue;\n    }\n    let xdays = parseInt(days);\n\n    for (c of consume) {\n        if (!a.itemTypes.consumable.some(r => r.slug === \"rations\")) { \n            ui.notifications.warn(`${a.name} has no rations left`);\n            xdays = c;\n            break;\n        }\n        await a.itemTypes.consumable.find(r => r.slug === \"rations\").consume();\n    }\n    ate.push({name:a.name, xdays});\n}\n\nlet content = ''\nfor (t of ate) {\n    content += `<strong>${t.name}</strong> has consumed <strong>${t.xdays}</strong> of <strong>${days}</strong> days of rations<br><br>`\n}\nawait ChatMessage.create({\n    content,\n    whisper: [game.userId]\n});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Ration Consumer.js\" - Fetched on 2024-06-05T17:22:21.771Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Ration Consumer","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"XzoFazB6uaCpkCq3","actorIds":[],"author":"suVu7DmoIihUkgis","command":"/*\nBased on the macro Contributed by ArthurTrumpet\nmodified by darkim\nmodified again by kromko\n\nUses the a new effect to track who has demoralized whom.\nImmunity duration is set depending on several factors. Default is 10 minutes. \n\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst demEffect = {\n  type: 'effect',\n  name: 'Demoralize Immunity',\n  img: 'systems/pf2e/icons/spells/blind-ambition.webp',\n  system: {\n    slug: 'demoralize-immunity',\n    tokenIcon: {\n        show: true\n    },       \n    duration: {\n        value: 10,\n        unit: 'minutes',\n        sustained: false,\n        expiry: 'turn-end'\n    },\n    rules: [],\n  },\n};\n\nmain();\n\n\nasync function main() {\n  const message = game.messages.contents.findLast( m => m.flags.demoralize);\n\n  let {sourceTokenId, sourceName, results} = message.flags.demoralize;\n\n  let source = canvas.tokens.get(sourceTokenId);\n  \n  results = results.filter(r => r.outcome !== 'invalid');\n\n  // Check if we have permissions to edit all of the target actors\n  if(!results.every(r=>canvas.tokens.get(r.targetTokenId)?.actor.isOwner))\n      return ui.notifications.warn(\"You don't have permissions to edit some of the tokens\");\n\n  demEffect.name = `Demoralize Immunity from ${sourceName}`;\n  demEffect.img = source.actor.prototypeToken.texture.src;\n  demEffect.flags = {demoralize: {source: source.actor.id}};\n\n  for(let {targetTokenId, outcome} of results){\n    let target = canvas.tokens.get(targetTokenId);\n\n    // Frightened\n    if(['success', 'criticalSuccess'].includes(outcome)){\n      let frightened = target.actor.getCondition('frightened')?.value ?? 0;\n      let newFrightened = Math.max(frightened, outcome == 'success' ? 1 : 2);\n      target.actor.increaseCondition('frightened', {value:newFrightened, max:newFrightened});\n    }\n\n    // Terrified retreat\n    if(source.actor.itemTypes.feat.some(f=>f.slug === 'terrified-retreat') && source.actor.level > target.actor.level && outcome === 'criticalSuccess'){\n      target.actor.increaseCondition('fleeing', {max:1});\n    }\n\n    // Temporary immunity\n    await target.actor.createEmbeddedDocuments(\"Item\", [demEffect]);\n  }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Demoralize Immunity CD.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Demoralize Immunity CD","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"Y99dWY4Zcemovbiw","actorIds":[],"author":"lJfjc7OcZUGIftj0","command":"//=============================================\n//              Request Checks Menu\n//            by Zael, Variant Rules\n// A utility to request a lot of checks in\n// quick succession. Made at the request of\n// TMun from the PF2e FoundryVTT Community\n// Discord.\n// CSS and Code Amendments by Symon S\n//=============================================\n\nconst saves_list = [\n    \"fortitude\",\n    \"reflex\",\n    \"will\",    \n];\n\nconst checks_list = [\n    \"acrobatics\",\n    \"arcana\",\n    \"athletics\",\n    \"crafting\",\n    \"deception\",\n    \"diplomacy\",\n    \"intimidation\",\n    \"medicine\",\n    \"nature\",\n    \"occultism\",\n    \"performance\",\n    \"religion\",\n    \"society\",\n    \"stealth\",\n    \"survival\",\n    \"thievery\"\n];\n\nasync function callCheckMenu() {\nawait new Promise(async (resolve) => {\n                setTimeout(resolve,200);\n            await new Dialog({\n                title:\"Request Checks Menu\",\n                content,\n                buttons:{ Close: { label: \"Close\" } },\n            },{width: 600}).render(true);\n            });\n}\n\nconst script1 = async function rollCheck(name) {\n    await new Promise(async (resolve) => {\n                setTimeout(resolve,200);\n            let menuContent = `<p style=\"font-size:80%;text-align:center;\">If the DC is invalid or left blank, then a Check with no listed DC will be posted.</p>\n                <form><div class=\"form-group\">\n                <label><strong>DC:</strong></label>\n                <input type='number' id='thisinputhere' name='DCValue' autofocus></input>\n                </div></form>`;\n            await new Dialog({\n                title:\"Enter DC\",\n                content: menuContent,\n                buttons: {\n                    one: {\n                        icon: '<i class=\"fas fa-dice-d20\"></i>',\n                        label: \"Confirm and Post\",\n                        callback: () => confirmed = true\n                    },\n                    two: {\n                        icon: '<i class=\"fas fa-times\"></i>',\n                        label: \"Cancel\",\n                        callback: () => confirmed = false\n                    }\n                },\n                default: \"one\",\n                render: () => document.getElementById(\"thisinputhere\").focus(),\n                close: html => {\n                    if (confirmed) {\n                        var DCValue = html.find('input[name=\\'DCValue\\']');\n                        if (DCValue.val()== '') {\n                            console.log(\"Error: DC Not Entered.\");\n                            return ui.notifications.error(\"Please input a number in the DC field.\");\n                        } else if (isNaN(DCValue.val())) {\n                            console.log(\"Error: DC Not a Number.\");\n                            return ui.notifications.error(\"Please input a number in the DC field.\");\n                        } else if (DCValue.val()<= 0) {\n                            console.log(\"Error: DC Not Valid.\");\n                            return ui.notifications.error(\"Please input a number greater than zero in the DC field.\");\n                        } else {\n                            DCValue = parseInt(html.find('[name=DCValue]')[0].value);\n                            DC = `dc:${DCValue}|`;\n                        }\n                        \n                        \n                        checkText = `@Check[type:${name}|${DC}traits:action]`;\n\n                        ChatMessage.create({\n                            user: game.user._id,\n                            speaker: ChatMessage.getSpeaker(),\n                            content: checkText\n                        });\n                        \n                    }\n                }\n            },{width: 300}).render(true);\n            });\n    \n};\n\nconst script2 = async function rollSecretCheck(name) {\n    await new Promise(async (resolve) => {\n                setTimeout(resolve,200);\n            let menuContent = `<p style=\"font-size:80%;text-align:center;\">If the DC is invalid or left blank, then a Check with no listed DC will be posted.</p>\n                <form><div class=\"form-group\">\n                <label><strong>DC:</strong></label>\n                <input type='number' id='thisinputhere' name='DCValue' autofocus></input>\n                </div></form>`;\n            await new Dialog({\n                title:\"Enter DC\",\n                content: menuContent,\n                buttons: {\n                    one: {\n                        icon: '<i class=\"fas fa-dice-d20\"></i>',\n                        label: \"Confirm and Post\",\n                        callback: () => confirmed = true\n                    },\n                    two: {\n                        icon: '<i class=\"fas fa-times\"></i>',\n                        label: \"Cancel\",\n                        callback: () => confirmed = false\n                    }\n                },\n                default: \"one\",\n                render: () => document.getElementById(\"thisinputhere\").focus(),\n                close: html => {\n                    if (confirmed) {\n                        var DCValue = html.find('input[name=\\'DCValue\\']');\n                        if (DCValue.val()== '') {\n                            console.log(\"Error: DC Not Entered.\");\n                            return ui.notifications.error(\"Please input a number in the DC field.\");\n                        } else if (isNaN(DCValue.val())) {\n                            console.log(\"Error: DC Not a Number.\");\n                            return ui.notifications.error(\"Please input a number in the DC field.\");\n                        } else if (DCValue.val()<= 0) {\n                            console.log(\"Error: DC Not Valid.\");\n                            return ui.notifications.error(\"Please input a number greater than zero in the DC field.\");\n                        } else {\n                            DCValue = parseInt(html.find('[name=DCValue]')[0].value);\n                            DC = `dc:${DCValue}|`;\n                        }\n                        \n                        \n                        checkText = `@Check[type:${name}|${DC}traits:action:search,secret]`;\n\n                        ChatMessage.create({\n                            user: game.user._id,\n                            speaker: ChatMessage.getSpeaker(),\n                            content: checkText\n                        });\n                        \n                    }\n                }\n            },{width: 300}).render(true);\n            });\n};\n\nlet content = `<style>\n.zmenumain {\n    margin: 1px auto;\n}\n.zmenu {\n    margin: 1px auto;\n    column-count: 4;\n    column-width: auto;\n}\n.zbutton {\n    width: 100%;\n    margin: 1px auto;\n}\n.pbutton {\n    background: #93b7c9;\n    margin: 1px auto;\n    width: fit-content;\n    height: fit-content;\n}\n.sbutton {\n    background: #cfa1a1;\n    margin: 1px auto;\n    width: fit-content;\n    height: fit-content;\n}\n</style><script>${script1}${script2}</script><div class=\"zmenumain\">`;\n\ncontent += `<p style=\"font-size:80%;text-align:center;\">Upon selecting a check, you will be prompted for a DC.</p><p><h2><i class=\"fas fa-eye\"></i>&nbsp;&nbsp;Perception Checks</h2></p>`;\n\ncontent += `<button name=\"buttonPerception\" class=\"pbutton\" type=\"button\" onclick=\"rollCheck('perception')\">Perception</button><button name=\"buttonSecretPerception\" class=\"sbutton\" type=\"button\" onclick=\"rollSecretCheck('perception')\"><i class=\"fas fa-eye-slash\"></i></button>`;\n\ncontent += `<br><br><p><h2><i class=\"fas fa-fire-alt\"></i>&nbsp;&nbsp;Saving Throws</h2></p><div class=\"zmenu\">`;\n\nsaves_list.forEach((c,i) => {\n    content += `<div class=\"zbutton\"><button name=\"button${i}\" class=\"pbutton\" type=\"button\" onclick=\"rollCheck('${c}')\">${c[0].toUpperCase() + c.substring(1)}</button><button name=\"buttonSecret${i}\" class=\"sbutton\" type=\"button\" onclick=\"rollSecretCheck('${c}')\"><i class=\"fas fa-eye-slash\"></i></button></div>`;\n});\n\ncontent += `</div><br><p><h2><i class=\"fas fa-balance-scale\"></i>&nbsp;&nbsp;Skill Checks</h2></p><div class=\"zmenu\">`;\n\nchecks_list.forEach((c,i) => {\n    content += `<div class=\"zbutton\"><button name=\"button${i}\" class=\"pbutton\" type=\"button\" onclick=\"rollCheck('${c}')\">${c[0].toUpperCase() + c.substring(1)}</button><button name=\"buttonSecret${i}\" class=\"sbutton\" type=\"button\" onclick=\"rollSecretCheck('${c}')\"><i class=\"fas fa-eye-slash\"></i></button></div>`;\n    \n});\ncontent += `</div><br></div>`;\ncallCheckMenu();\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/RequestChecksMenu.js\" - Fetched on 2024-06-05T17:22:21.777Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT RequestChecksMenu","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"YWrsqkbifC35Zm0B","actorIds":[],"author":"L0Z9gVTzhjRNvvQA","command":"/*\nSimple Macro to check for level based DCs.\nEither select a token, multiple tokens, or no token at all.\nYou will be prompted for an adjustment.\nWhen multiple tokens or no tokens are selected you will be prompted for a level as well.\n*/\n\nconst diff = await new Promise((resolve) => {\n new Dialog({\n title: 'Difficulty?',\n buttons: {\n  ineasy: { label: 'Incredibly Easy', callback: () => { resolve(-10); } },\n  veasy: { label: 'Very Easy', callback: () => { resolve(-5); } },\n  easy: { label: 'Easy', callback: () => { resolve(-2); } },\n  norm: { label: 'Normal', callback: () => { resolve(0); } },\n  hard: { label: 'Hard', callback: () => { resolve(2); } },\n  vhard: { label: 'Very Hard', callback: () => { resolve(5); } },\n  inhard: { label: 'Incredibly Hard', callback: () => { resolve(10); } },\n  },\n default: 'norm',\n },{width:600}).render(true);\n});\n\nlet level;\nif (canvas.tokens.controlled.length === 1) { level = canvas.tokens.controlled[0].actor.level + 1 }\n\nelse {\n  level = await new Promise((resolve) => {\n    new Dialog({\n      title: 'Level?',\n      buttons: {\n        0: { label: '-1', callback: () => { resolve(0); } },\n        1: { label: '0', callback: () => { resolve(1); } },\n        2: { label: '1', callback: () => { resolve(2); } },\n        3: { label: '2', callback: () => { resolve(3); } },\n        4: { label: '3', callback: () => { resolve(4); } },\n        5: { label: '4', callback: () => { resolve(5); } },\n        6: { label: '5', callback: () => { resolve(6); } },\n        7: { label: '6', callback: () => { resolve(7); } },\n        8: { label: '7', callback: () => { resolve(8); } },\n        9: { label: '8', callback: () => { resolve(9); } },\n        10: { label: '9', callback: () => { resolve(10); } },\n        11: { label: '10', callback: () => { resolve(11); } },\n        12: { label: '11', callback: () => { resolve(12); } },\n        13: { label: '12', callback: () => { resolve(13); } },\n        14: { label: '13', callback: () => { resolve(14); } },\n        15: { label: '14', callback: () => { resolve(15); } },\n        16: { label: '15', callback: () => { resolve(16); } },\n        17: { label: '16', callback: () => { resolve(17); } },\n        18: { label: '17', callback: () => { resolve(18); } },\n        19: { label: '18', callback: () => { resolve(19); } },\n        20: { label: '19', callback: () => { resolve(20); } },\n        21: { label: '20', callback: () => { resolve(21); } },\n        22: { label: '21', callback: () => { resolve(22); } },\n        22: { label: '22', callback: () => { resolve(23); } },\n        23: { label: '23', callback: () => { resolve(24); } },\n        24: { label: '24', callback: () => { resolve(25); } },\n        25: { label: '25', callback: () => { resolve(26); } },\n      },\n      render: () => {\n        let myElem = [...document.getElementsByClassName(\"dialog-buttons\")].pop();\n        if (myElem.style === undefined) { myElem = [...document.getElementsByClassName(\"dialog-buttons\")].pop(); }\n        myElem.style.display = \"grid\";\n        myElem.style.gridTemplateColumns = \"repeat(13,1fr)\";\n        myElem.style.gap = \"1px 1px\";\n      }\n    },{width:500}).render(true);\n  });\n}\n\nconst lDCs = [13,14,15,16,18,19,20,22,23,24,26,27,28,30,31,32,34,35,36,38,39,40,42,44,46,48,50];\nconst bDC = lDCs[level] + diff;\nui.notifications.info(`Level based DC is ${bDC}`);\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Level Based DCs.js\" - Fetched on 2024-06-05T17:22:21.770Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Level Based DCs","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"a2NBYRLGECrceuiN","actorIds":[],"author":"clOLvUzNniD03knC","command":"/*\nBased on the macro Contributed by ArthurTrumpet\nmodified by darkim\n\nUses the built in Treat Wounds immunity effect to track who has healed whom.\nPlayer selects the token being healed, and chooses the healer from the drop down.\nThe effect icon won't appear on the token, as you can potentially be Treated Wounds several times, and it would just clutter up the token. \nIf you want to show the icons, update the variable showIcons on line #2 to true.\nImmunity duration is set depending on several factors. Default is 1 hour. \nA character with the Continual Recovery feat will only give a 10 minute cooldwon.\n\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst tw_UUID = 'Compendium.pf2e.feat-effects.Lb4q2bBAgxamtix5'; //Treat Wounds Immunity effect\nconst showIcons = true;\n\nif (!token) {\n    ui.notifications.error(\"No token selected!\");\n} else {\n    main();\n}\n\nfunction CheckFeat(slug, healer) {\n    return healer.itemTypes.feat.some((i) => i.slug === slug);\n}\n\nasync function main() {\n    const message = game.messages.contents.reverse().find( m => m.flags.treat_wounds_battle_medicine?.id === token.id);\n    if (message === undefined) {\n        ui.notifications.info(\"Wrong token selected!\");\n    } else {\n        const twEffect = (await fromUuid(tw_UUID)).toObject();\n        twEffect.data.tokenIcon.show = showIcons; //Potential for lots of effects to be on a token. Don't show icon to avoid clutter\n        twEffect.flags.core ??= {};\n        twEffect.flags.core.sourceId = tw_UUID;\n\n        const applicator = game.actors.get(message.flags.treat_wounds_battle_medicine.healerId);\n\n        twEffect.name = \"Treat Wounds\";\n        const useContinualRecovery = CheckFeat('continual-recovery', applicator);\n\n        if (useContinualRecovery) {\n            twEffect.data.duration.unit = \"minutes\";\n            twEffect.data.duration.value = 10;\n        }\n        if ( message.flags.treat_wounds_battle_medicine.dos >= 2 ) {\n            if (token.actor.hasCondition(\"wounded\") ) { \n                await token.actor.toggleCondition(\"wounded\");\n            }\n        }\n\n        await token.actor.createEmbeddedDocuments(\"Item\", [twEffect]);\n        ui.notifications.info(token.actor.name + \" is now immune to Treat Wounds for \" + twEffect.data.duration.value + \" \" + twEffect.data.duration.unit + \".\");\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/TW Immunity CD.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT TW Immunity CD","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"a7qxt5CpqyLKcj7m","actorIds":[],"author":"yDrKWngFL26kGRXk","command":"/**\n * Contributed by JDCalvert\n * Allows the user to update the radius of an active aura effect. Useful for auras like Protective Ward\n */\n\n/**\n * Find exactly one actor and token to update\n */\nfunction getControlledActorAndToken() {\n    const controlledTokens = canvas.tokens.controlled;\n    if (controlledTokens.length) {\n        if (controlledTokens.length === 1) {\n            const myToken = controlledTokens[0];\n            const myActor = myToken?.actor;\n            if (myToken && myActor) {\n                return { myActor, myToken };\n            }\n        }\n    } else {\n        const myActor = game.user.character;\n        const myTokens = myActor?.getActiveTokens();\n        const myToken = myTokens?.length === 1 ? myTokens[0] : null;\n        if (myActor && myToken) {\n            return { myActor, myToken };\n        }\n    }\n\n    ui.notifications.warn(\"You must have a single character selected.\");\n    return { myActor: null, myToken: null };\n}\n\n/**\n * Build the options to select an aura to update\n */\nfunction buildAuraEffectOptions(auraEffects) {\n    let options = ``;\n    for (let aura of auraEffects) {\n        const currentRadius = aura.rules\n            .map(rule => rule.data)\n            .find(rule => rule.key === \"Aura\")\n            .radius;\n        options += `<option value=\"${aura.id}\">${aura.name} (${currentRadius} ft.)</option>`;\n    }\n    return options;\n}\n\nfunction applyChanges($html, auraEffects) {\n    const auraId = $html.find(`[name=\"auraId\"]`).val();\n    const radius = Number($html.find(`[name=\"radius\"]`).val());\n\n    if (!(radius > 0 && radius % 5 === 0)) {\n        ui.notifications.error(\"The aura's radius must be a positive multiple of 5 ft.\");\n        return;\n    }\n\n    const auraEffect = auraEffects.find(effect => effect.id === auraId);\n    if (!auraEffect) {\n        ui.notifications.error(\"Aura not found.\");\n        return;\n    }\n\n    const auraRule = auraEffect.data.data.rules.find(rule => rule.key === \"Aura\");\n    if (!auraRule) {\n        ui.notifications.error(\"Aura rule not found.\");\n        return;\n    }\n\n    auraRule.radius = radius;\n    auraEffect.update({ \"data.rules\": auraEffect.data.data.rules });\n    \n    // PF2e x JB2A Macros Implementation by MrVauxs\n    if (game.modules.get(\"sequencer\")?.active) {\n        const sequencerEffects = Sequencer.EffectManager.getEffects({ origin: auraRule.slug, source: myToken })\n        if (sequencerEffects.length) {\n            const sizeChange = 1.5 + 3 * (radius / 5)\n            sequencerEffects[0].update({size: { width: sizeChange, height: sizeChange, gridUnits: true }})\n        }\n    }\n}\n\n\nconst { myActor, myToken } = getControlledActorAndToken();\nif (!(myActor && myToken)) {\n    return;\n}\n\nconst auraEffects = myActor.itemTypes.effect.filter(effect =>\n    effect.rules.find(rule => rule.data.key === \"Aura\")\n);\n\nif (!auraEffects.length) {\n    ui.notifications.warn(`${myToken.name} has no aura effects.`);\n    return;\n}\n\nnew Dialog(\n    {\n        title: \"Update Aura Radius\",\n        content: `\n            <form>\n                <div class=\"form-group\">\n                    <label>Aura:</label>\n                    <select id=\"auraId\" name=\"auraId\">\n                        ${buildAuraEffectOptions(auraEffects)}\n                    </select>\n                </div>\n            </form>\n            <form>\n                <div class=\"form-group\">\n                    <label>Radius (ft.)</label>\n                    <input type=\"number\" id=\"radius\" name=\"radius\" title=\"The new radius for the aura. This must be a positive multiple of 5 ft.\"/>\n                </div>\n            </form>       \n        `,\n        buttons: {\n            one: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"Update\",\n                callback: ($html) => applyChanges($html, auraEffects)\n            },\n            two: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: \"Cancel\"\n            }\n        },\n        default:\"one\",\n    }\n).render(true);\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Update Aura Radius.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Update Aura Radius","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"afuMwG7fXdZbo2G0","actorIds":[],"author":"iaOPrr1pMsbjVVV5","command":"/* Little Loot Genrator written for the PF2e system. The values for Treasures are in Silver 1GP = 10SP\n\nWhen using rarity:\n**No filter = completely random loot**\n**Uncommon/Rare = Uncommon and rare items only, scrolls and wands will have uncommon/rare spells if randomly generated\nand available (rare spells not available at each rank), if not available another item will be generated in its place.**\n**Unique = There are no unique spells in the game, so this will only push unique items if available.**\n\n\n\nModded by LebombJames to use getIndex for faster loading.\nSpecial thanks to Idle for scroll/wand creation function.\n*/\n\nLootGenerator();\n\nasync function LootGenerator() {\n\tconst wandIds = {\n        1: \"UJWiN0K3jqVjxvKk\",\n        2: \"vJZ49cgi8szuQXAD\",\n        3: \"wrDmWkGxmwzYtfiA\",\n        4: \"Sn7v9SsbEDMUIwrO\",\n        5: \"5BF7zMnrPYzyigCs\",\n        6: \"kiXh4SUWKr166ZeM\",\n        7: \"nmXPj9zuMRQBNT60\",\n        8: \"Qs8RgNH6thRPv2jt\",\n        9: \"Fgv722039TVM5JTc\"\n    };\n\n\t//Limit Macro use to GM\n\tif (!game.user.isGM) { return ui.notifications.warn(\"You are unable to use this macro!\"); }\n\n\t//Dialog Inputs\n\tconst dialogs = [\t\n\t\t{ label : `What type of item?`, type: `select`, options: [\"Permanents\",\"Consumables\",\"Treasures\"]},\n\t\t{ label : `Level? (Only Permanents and Consumables)`, type: `select`, options: Array.fromRange(21)},\n\t\t{ label : `Center range value in Silver (Only Treasures)<br>(50% in either direction will be evaluated)`, type: `number`},\n\t\t{ label : `Quantity?`, type: `number`, options: [1]},\n\t\t{ label : `Rarity? (Only Permanents and Consumables)`, type: `select`, options: [\"No filter\", \"Common\", \"Uncommon\", \"Rare\", \"Unique\"] },\n\t\t{ label : `Distribution type?`, type: `select`, options: [\"Party Actor\",\"Existing Loot Actor\",\"Generated Loot Actor\",\"Message\"]},\n\t\t{ label : `Mystify?`, type: `checkbox`, options: \"checked\"}\n\t];\n\n\t//Run Dialog and gather Data\n\tconst picks = await quickDialog({title: 'Loot Generator', data: dialogs});\n\tpicks[1] = parseInt(picks[1]);\n\n\t//Throw warn if quantity is below 1\n\tif ( Noan(picks[3]) || picks[3] < 1) { return ui.notifications.warn(\"A quantity of at least 1 is required!\");}\n\n\t//Pre-prep a counter array\n\tlet itemArray = [...Array(Math.round(picks[3])).keys()];\n\tlet randomItems = [];\n\n\t//Populate items\n\tconst iC = [\"pf2e.equipment-srd\",\"battlezoo-bestiary-pf2e.pf2e-battlezoo-equipment\",/*\"pf2e-expansion-pack.Expansion-Equipment\",\"pf2e-wayfinder.wayfinder-equipment\"*/,\"battlezoo-bestiary-su-pf2e.pf2e-battlezoo-su-equipment\",\"battlezoo-world-of-indigo-isles-pf2e.indigo-isles-equipment\",];\n\tconst item = game.packs.filter(c => iC.includes(c.collection));\n\tlet items = [];\n\tfor (const i of item) {\n\t\tconst index = await i.getIndex({fields: [\"system.level.value\", \"system.slug\", \"system.price.value\", \"system.traits.value\", \"system.traits.rarity\",\"uuid\"]});\n\t\tindex.forEach( x => {\n\t\t\tx.compendium = i.collection;\n\t\t\titems.push(x);\n\t\t});\n\t};\n\n\t//Populate Spells\n\tlet spellz;\n\tlet spellS = [];\n\tlet treasures = [];\n\tconst output = [];\n\n\tif (picks[0] !== \"Treasures\") {\n\t\tconst iS = [\"pf2e.spells-srd\",/*\"pf2e-expansion-pack.Expansion-Spells\"*/]; \n\t\tspellz = game.packs.filter(c => iS.includes(c.collection));\n\t\tfor (const s of spellz) {\n\t\t\tconst index = (await s.getIndex({fields: [\"system.level.value\",\"system.slug\",\"system.traits\",\"system.ritual\",\"uuid\",\"system.area\",\"system.duration\",\"system.range\",\"system.time\"]})).filter(f => !f.system.traits.value.includes(\"cantrip\") && !(f.system.ritual ??= false) && !f.system.traits.value.includes(\"focus\"));\n\t\t\tindex.forEach( x => {\n\t\t\t\tx.compendium = s.collection;\n\t\t\t\tspellS.push(x);\n\t\t\t});\n\t\t}\n\t\tif ( picks[4] !== \"No filter\" ) { spellS = spellS.filter(s => s.system.traits.rarity === picks[4].toLowerCase()); }\n\t}\n\n\t//Treasures\n\tif (picks[0] === \"Treasures\") {\n\t\tconst type = \"treasure\";\n\t\tawait RRI(type,false);\n\t\tawait Loot(type);\n\t}\n\n\t// Permanents\n\tif (picks[0] === \"Permanents\") {\n\t\tconst type = \"permanent\";\n\t\tawait RRI(type,false);\n\t\tawait Loot(type);\n\t}\n\n\t//Consumbales\n\tif (picks[0] === \"Consumables\") {\n\t\tconst type = \"consumable\";\n\t\tawait RRI(type,false);\n\t\tawait Loot(type);\n\t}\n\n\tasync function RRI(type,exclude) {\n\t\tif (exclude) {\n\t\t\ttreasures = treasures.filter(m => !m.system.slug.includes(\"scroll-of-\") && !m.system.slug.includes(\"wand-of-continuation-\") && !m.system.slug.includes(\"wand-of-legerdemain-\") && !m.system.slug.includes(\"wand-of-reaching-\") && !m.system.slug.includes(\"wand-of-widening-\") && !m.system.slug.includes(\"magic-wand-\"));\n\t\t\tconst random = Math.floor(Math.random() * treasures.length);\n\t\t\touput.push({name: treasures[random].name, id: treasures[random]._id, slug:treasures[random].system.slug, compendium: treasures[random].compendium, uuid: treasures[random].uuid});\n\t\t}\n\t\telse if ( type === \"permanent\" ) {\n\t\t\tif(Noan(picks[1])) { return ui.notifications.warn(\"Level of at least 0 must be entered\");}\n\t\t\tconst treasure = items.filter(t => t.type === \"armor\" || t.type === \"weapon\" || t.type === \"equipment\" || t.type === \"backpack\" || t.system.traits.value.includes(\"wand\") );\n\t\t\ttreasures = treasure.filter( l => l.system.level.value === picks[1] && !l.system.traits.value.includes(\"consumable\") );\n\t\t\tif ( picks[4] !== \"No filter\" ) { treasures = treasures.filter( r => r.system.traits.rarity === picks[4].toLowerCase() || (r.system.slug?.includes(\"magic-wand\") && picks[4] !== \"Unique\")); }\n\t\t\tif (treasures.length === 0) { return ui.notifications.info(`There are no ${picks[4].toLowerCase()} ${picks[0].toLowerCase()} at level ${picks[1]}`); }\n\t\t\titemArray.forEach( () => {\n\t\t\t\tconst random = Math.floor(Math.random() * treasures.length);\n\t\t\t\trandomItems.push({name: treasures[random].name, id: treasures[random]._id, slug:treasures[random].system.slug, compendium: treasures[random].compendium, uuid: treasures[random].uuid})\n\t\t\t});\n\t\t}\n\t\telse if ( type === \"consumable\") {\n\t\t\tif(Noan(picks[1])) { return ui.notifications.warn(\"Level of at least 0 must be entered\");}\n\t\t\tconst treasure = items.filter(t => ( t.type === \"consumable\" || t.system.traits.value.includes(\"consumable\") ) && !t.system.traits.value.includes(\"wand\"));\n\t\t\ttreasures = treasure.filter( l => l.system.level.value === picks[1] );\n\t\t\tif ( picks[4] !== \"No filter\" ) { treasures = treasures.filter( r => r.system.traits.rarity === picks[4].toLowerCase() || (r.system.slug?.includes(\"scroll-of-\") && picks[4] !== \"Unique\")); }\n\t\t\tif (treasures.length === 0) { return ui.notifications.info(`There are no ${picks[4].toLowerCase()} ${picks[0].toLowerCase()} at level ${picks[1]}`); }        \n\t\t\titemArray.forEach( () => {\n\t\t\t\tconst random = Math.floor(Math.random() * treasures.length);\n\t\t\t\trandomItems.push({name: treasures[random].name, id: treasures[random]._id, slug:treasures[random].system.slug, compendium: treasures[random].compendium, uuid: treasures[random].uuid})\n\t\t\t});\n\t\t}\n\t\telse if ( type === \"treasure\" ) {\n\t\t\ttreasures = items.filter(t => t.type === \"treasure\");\n\t\t\tif ( Noan(picks[2]) ) { \n\t\t\t\tui.notifications.info(\"No center range was entered, random treasures selected\");\n\t\t\t\titemArray.forEach( () => {\n\t\t\t\t\tlet random = Math.floor(Math.random() * treasures.length);\n\t\t\t\t\trandomItems.push({name: treasures[random].name, slug: treasures[random].system.slug, id: treasures[random]._id, compendium: treasures[random].compendium, uuid: treasures[random].uuid});\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (picks[2] < 1 && !Noan(picks[2] ) ) { return ui.notifications.warn(\"A value greater than 1 needs to be entered for range\")}\n\t\t\telse {\n\t\t\t\tlet denomination = \"sp\";\n\t\t\t\tlet value = Math.round(picks[2]);;\n\t\t\t\tconst range = await Ranges(Math.round(picks[2]));\n\t\t\t\tif (Math.round(picks[2]) >= 10) { \n\t\t\t\t\tdenomination = \"gp\";\n\t\t\t\t\tvalue = Math.round(picks[2] / 10);\n\t\t\t\t} \n\t\t\t\ttreasures = treasures.filter(f => range.includes(f.system.price.value.sp) || range.includes(f.system.price.value.gp*10) );\t\t\n\t\t\t\tif (treasures.length === 0) { return ui.notifications.warn(`There are no treasures within 50% of ${value}${denomination}`); }\n\t\t\t\t\n\t\t\t\titemArray.forEach( () => {\n\t\t\t\t\tlet random = Math.floor(Math.random() * treasures.length);\n\t\t\t\t\trandomItems.push({name: treasures[random].name, id: treasures[random]._id, slug:treasures[random].system.slug, compendium: treasures[random].compendium, uuid: treasures[random].uuid})\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tasync function Ranges(x) {\n\t\tconst lowEnd = Math.round(x * 0.5);\n\t\tconst highEnd = Math.round(x * 1.5);\n\t\tconst range = [];\n\t\tfor (let i = lowEnd; i <= highEnd; i++) {\n\t\t\trange.push(i);\n\t\t}\n\t\treturn range;\n\t}\n\n\tfunction Noan(x) {\n\treturn x !== x;\n\t};\n\n\tasync function Loot(type) {\n\t\tfor ( const r of randomItems ) {\n\t\t\tconst slug = r.slug;\n\t\t\tif(slug !== null && slug.includes(\"magic-wand\")){\n\t\t\t\tconst level = parseInt(slug.substr(11,1));\n\t\t\t\tconst spells = spellS.filter(l => l.system.level.value === level);\n\t\t\t\tconst randomSpell = spells[Math.floor(Math.random() * spells.length)] ?? spells[Math.floor(Math.random() * spells.length)];\n\t\t\t\toutput.push({ name: `Wand of ${randomSpell.name} (Rank ${level})`, uuid: randomSpell.uuid, sid: r.id, sc: r.compendium, level, scrollUUID: r.uuid});\n\t\t\t}\n\t\t\telse if(slug !== null && slug.includes(\"scroll-of-\")){\n\t\t\t\tlet level = parseInt(r.slug.substr(10,1));\n\t\t\t\tif (r.slug.length === 25) {\n\t\t\t\t\tlevel = parseInt(r.slug.substr(10,2));\n\t\t\t\t}\n\t\t\t\tconst spells = spellS.filter(l => l.system.level.value === level);\n\t\t\t\tconst randomSpell = spells[Math.floor(Math.random() * spells.length)] ?? spells[Math.floor(Math.random() * spells.length)];\n\t\t\t\toutput.push({ name: `Scroll of ${randomSpell.name} (Rank ${level})`, uuid: randomSpell.uuid, sid: r.id, sc: r.compendium, level, scrollUUID: r.uuid});\n\t\t\t}\n\t\t\telse if (slug !== null && slug.includes(\"wand-of-continuation-\")) {\n\t\t\t\tconst level = parseInt(r.slug.substr(21,1));\n\t\t\t\tconst spells = spellS.filter( f => f.system.level.value === level && (f.system.duration.value === \"10 minutes\" || f.system.duration.value === \"1 hour\") && (f.system.time?.value === \"1\" || f.system.time?.value === \"2\") );\n            \tif ( spells.length === 0 ) { \n\t\t\t\t\tawait RRI(type,true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst specWand = \"cont\";\n\t\t\t\t\tconst rSpell = spells[Math.floor(Math.random() * spells.length)];\n            \t\toutput.push({ name: `Wand of Continuation ${rSpell.name} (Rank ${level})`, uuid: rSpell.uuid, sid: wandIds[level], sc: \"pf2e.equipment-srd\", level, scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[level]}`, sWUUID: r.uuid, specWand });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (slug !== null && slug.includes(\"wand-of-legerdemain-\")) {\n\t\t\t\tconst level = parseInt(r.slug.substr(20,1));\n\t\t\t\tconst specWand = \"leger\";\n\t\t\t\tconst spells = spellS.filter(l => l.system.level.value === level);\n\t\t\t\tconst rSpell = spells[Math.floor(Math.random() * spells.length)];\n            \toutput.push({ name: `Wand of Legerdemain ${rSpell.name} (Rank ${level})`, uuid: rSpell.uuid, sid: wandIds[level], sc: \"pf2e.equipment-srd\", level, scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[level]}`, sWUUID: r.uuid, specWand });\n\t\t\t}\n\n\t\t\telse if (slug !== null && slug.includes(\"wand-of-reaching-\")) {\n\t\t\t\tconst level = parseInt(r.slug.substr(17,1));\n\t\t\t\tconst spells = spellS.filter( f => f.system.level.value === level && (f.system.range?.value.includes(\"feet\") || f.system.range?.value.includes(\"touch\")) && (f.system.time?.value === \"1\" || f.system.time?.value === \"2\") );\n            \tif ( spells.length === 0 ) { \n\t\t\t\t\tawait RRI(type,true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst specWand = \"reach\";\n\t\t\t\t\tconst rSpell = spells[Math.floor(Math.random() * spells.length)];\n            \t\toutput.push({ name: `Wand of Reaching ${rSpell.name} (Rank ${level})`, uuid: rSpell.uuid, sid: wandIds[level], sc: \"pf2e.equipment-srd\", level, scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[level]}`, sWUUID: r.uuid, specWand });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (slug !== null && slug.includes(\"wand-of-widening-\")) {\n\t\t\t\tconst level = parseInt(r.slug.substr(17,1));\n\t\t\t\tconst spells = spellS.filter( f => f.system.level.value === level && f.system.duration.value === \"\" && ((f.system.area?.value > 10 && f.system.area?.type === \"burst\") || (f.system.area?.type === \"cone\" || f.system.area?.type === \"line\")) && (f.system.time.value === \"1\" || f.system.time.value === \"2\") );\n            \tif ( spells.length === 0 ) { \n\t\t\t\t\tawait RRI(type,true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst specWand = \"wide\";\n\t\t\t\t\tconst rSpell = spells[Math.floor(Math.random() * spells.length)];\n            \t\toutput.push({ name: `Wand of Widening ${rSpell.name} (Rank ${level})`, uuid: rSpell.uuid, sid: wandIds[level], sc: \"pf2e.equipment-srd\", level, scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[level]}`, sWUUID: r.uuid, specWand });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { output.push(r) }\n\t\t}\n\t}\n\n\tif ( picks[5] === \"Message\" ) {\n\t\tlet content = \"\";\n\t\tfor ( const o of output ) {\n\t\t\tcontent += `<p>@UUID[${o.uuid}]{${o.name}}</p>`\n\t\t}\n\t\tawait ChatMessage.create({flavor: `<strong>Random ${picks[0]}</strong><br>`,content, speaker: {alias:'GM'}, whisper:[game.user.id]});\n\t\tui.notifications.info(\"Check chat message. Hold alt when dragging and dropping to mystify items\");\n\t}\n\telse {\n\t\tlet a;\n\t\tif ( picks[5] === \"Generated Loot Actor\" ) {\n\t\t\tif (!game.actors.some( n => n.name === \"Generated Loot\")) {\n\t\t\t\tawait Actor.create({name:\"Generated Loot\",type:\"loot\",img:\"icons/containers/chest/chest-reinforced-steel-red.webp\"});\n\t\t\t}\n\t\t\ta = game.actors.getName(\"Generated Loot\");\n\t\t}\n\t\t\n\t\tif ( picks[5] === \"Party Actor\" ) {\n\t\t\tif ( game.actors.filter( p => p.type === \"party\" ).length > 1 ) {\n\t\t\t\ta = await MyDialog(\"party\");\n\t\t\t}\n\t\t\telse { \n\t\t\t\ta = game.actors.find(p => p.type === \"party\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( picks[5] === \"Existing Loot Actor\" ) {\n\t\t\tif ( game.actors.filter( p => p.type === \"loot\" ).length > 1 ) {\n\t\t\t\ta = await MyDialog(\"loot\");\n\t\t\t}\n\t\t\telse { \n\t\t\t\ta = game.actors.find(p => p.type === \"loot\" );\n\t\t\t}\n\t\t}\n\t\tif ( a === undefined ) { return }\n\t\tconst stuff = [];\n\t\tfor ( const o of output ) {\n\t\t\tif ( o.sid === undefined ) {\n\t\t\t\tconst rI = (await fromUuid(o.uuid)).toObject()\n\t\t\t\tstuff.push(rI);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstuff.push(await createSpellScrollWand(o.scrollUUID, o.uuid, o.level, o.name, o.sWUUID, o.specWand));\n\t\t\t}\n\t\t}\n\t\tif (stuff.length > 0) {\n\t\t\tconst updates = await a.createEmbeddedDocuments(\"Item\",stuff);\n\t\t\tif ( picks[6] ) { await a.updateEmbeddedDocuments(\"Item\", updates.map(u => ({_id: u.id, \"system.identification.status\": \"unidentified\" }))); }\n\t\t}\n\t\ta.sheet.render(true);\n\t}\n\n\tasync function MyDialog(type) {\n\t\tlet options = \"\";\n\t\tfor (const plac of game.actors.filter( f => f.type === type )) {\n\t\t\toptions += `<option value=${plac.id}>${plac.name}</option>`\n\t\t}\n\t\tconst myac = await Dialog.prompt({\n\t\t\ttitle: `Select ${type} actor`,\n\t\t\tcontent:`\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th width=\"70%\" style=\"text-align:center\">Please select an actor : </th>\n\t\t\t\t\t\t<td width=\"30%\"><select>${options}</select></td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t`,\n\t\t\tcallback: (html) => { return html[0].querySelector(\"select\").value },\n\t\t\trejectClose:false,\n\t\t},{width:\"200px\"});\n\t\treturn game.actors.get(myac);\n\t}\n\n\tasync function createSpellScrollWand(scrollUUID, uuid, level, name, sWUUID, specWand, temp = false ) {\n        const spell = (await fromUuid(uuid))?.toObject();\n        if (!spell) return null;\n        if ( specWand === \"reach\" ) {\n            if ( spell.system.range.value !== \"touch\" ) {\n                const split = spell.system.range.value.split(\" \");\n                split[0] = `${parseInt(split[0]) + 30}`;\n                spell.system.range.value = split.join(\" \");\n            }\n            else {\n                spell.system.range.value === \"30 feet\";\n            }\n        }\n        if ( specWand === \"wide\" ) {\n            if ( spell.system.area.type === \"burst\" ) {\n                spell.system.area.value += 5;\n            }\n            if ( spell.system.area.type !== \"burst\") {\n                if ( spell.system.area.value > 15 ) {\n                    spell.system.area.value += 10;\n                }\n                else { spell.system.area.value += 5; }\n            }\n        }\n        if ( specWand === \"cont\" ) {\n            const split = spell.system.duration.value.split(\" \");\n            split[0] = `${parseInt(split[0]) * 1.5}`;\n            spell.system.duration.value = split.join(\" \");\n        }\n\n        if (level === false) level = spell.system.level.value;\n\n        scrolls = await fromUuid(scrollUUID);\n\n        const scroll = scrolls?.toObject();\n        if (!scroll) return null;\n\n        spell.system.location.heightenedLevel = level;\n\n        scroll.name = name;\n        scroll.system.temporary = temp;\n        scroll.system.spell = spell;\n        scroll.system.traits.rarity = spell.system.traits.rarity;\n        scroll.system.traits.value = [...new Set(scroll.system.traits.value.concat(spell.system.traits.traditions).concat(spell.system.traits.value))];\n            \n        const sourceId = spell.flags.core?.sourceId;\n        if (sourceId && sWUUID === undefined) scroll.system.description.value = `@UUID[${uuid}]\\n<hr />${scroll.system.description.value}`;\n        if ( sWUUID !== undefined ) {\n            const w = (await fromUuid(sWUUID)).toObject();\n\t\t\tscroll.system.price = w.system.price;\n\t\t\tscroll.system.description.value = `@UUID[${uuid}]\\n<hr />${w.system.description.value}`;\n\t\t\tif ( specWand !== \"leger\" ) {\n\t\t\t\tif ( scroll.system.spell.system.time.value === \"2\" ) { scroll.system.spell.system.time.value = \"3\" }\n\t\t\t\tif ( scroll.system.spell.system.time.value === \"1\" ) { scroll.system.spell.system.time.value = \"2\" }\n\t\t\t}\n        }\n        return scroll;\n    }\n\n\tasync function quickDialog({data, title = `Quick Dialog`} = {}) {\n\t\tdata = data instanceof Array ? data : [data];\n\t\n\t\treturn await new Promise(async (resolve) => {\n\t\tlet content = `\n\t\t\t<table style=\"width:100%\">\n\t\t\t${data.map(({type, label, options}, i) => {\n\t\t\tif(type.toLowerCase() === `select`)\n\t\t\t{\n\t\t\treturn `<tr><th style=\"width:80%;font-size:13px\"><label>${label}</label></th><td style=\"width:20%\"><select id=\"${i}qd\">${options.map((e,i)=> `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n\t\t\t}else if (type.toLowerCase() === `checkbox`){\n\t\t\treturn `<tr><th style=\"width:80%;font-size:13px\"><label>${label}</label></th><td style=\"width:20%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n\t\t\t} else {\n\t\t\treturn `<tr><th style=\"width:80%;font-size:13px\"><label>${label}</label></th><td style=\"width:20%\"><input type=\"${type}\" style=\"border:solid 1px black\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n\t\t\t}\n\t\t\t}).join(``)}\n\t\t</table>`;\n\t\n\t\tawait new Dialog({\n\t\ttitle, content,\n\t\tbuttons : {\n\t\t\tOk : { label : `Ok`, callback : (html) => {\n\t\t\t\tLootGenerator();\n\t\t\t\tresolve(Array(data.length).fill().map((e,i)=>{\n\t\t\t\tlet {type} = data[i];\n\t\t\t\tif (type.toLowerCase() === `select`)\n\t\t\t\t{\n\t\t\t\treturn html.find(`select#${i}qd`).val();\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\tswitch(type.toLowerCase())\n\t\t\t\t\t{\n\t\t\t\t\t\tcase `text` :\n\t\t\t\t\t\tcase `password` :\n\t\t\t\t\t\tcase `radio` :\n\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].value;\n\t\t\t\t\t\tcase `checkbox` :\n\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].checked;\n\t\t\t\t\t\tcase `number` :\n\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].valueAsNumber;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\t\t\t}},\n\t\t\tClose: { \n\t\t\t\tlabel: \"Close\",\n\t\t\t}\n\t\t},\n\t\tclose: () => {},\n\t\tdefault : 'Ok',\n\t\t},{width:\"auto\"})._render(true);\n\t\tdocument.getElementById(\"0qd\").focus();\n\t\t});\n\t}\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Loot Generator.js\" - Fetched on 2024-06-05T17:22:21.770Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Loot Generator","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"aw2yfjChMESd5p53","actorIds":[],"author":"WXP54R4SGRWI2rEr","command":"/* \nContributed by Uprooted Grunt (steev@2d12.com)\n\nUsage: A token with a melee weapon in inventory must be selected to run this macro.  Select the weapon to be shifted (by default, only includes melee weapons with Shifting runes, but select Blade Ally to show all melee weapons), then choose the weapon you wish to shift the weapon into.  Click OK to shift.\nNote that if the selected token doesn't have any weapons with Shifting runes, Blade Ally will be automatically checked and disabled, under the assumption that this is what is happening.\nThe macro will create a new instance of that weapon, copy all materials and runes onto it, delete the original weapon, and make a chat message showing the action taken.\nFilters exist for rarity/complexity of the weapons chosen.  You can default those choices by updating the six variables below to be \"\" or \"checked\" accordingly.\n\nSlightly modified to work with findIndex by the macro fairies.\nNow fully maintained by the macro fairies.\n*/\n\nif (!actor){ return ui.notifications.warn(\"No PC Token Selected\"); }\nif (!token.actor.itemTypes.weapon.some(a => a.isMelee && a.system.runes.property.includes(\"shifting\")) && !token.actor.itemTypes.feat.some(s => s.slug === \"divine-ally\")) { return ui.notifications.warn(\"You do not possess a shifting weapon and do not have a Divine Ally\"); }\n\nlet defaultSimple=\"checked\";\nlet defaultMartial=\"checked\";\nlet defaultAdvanced=\"\";\nlet defaultCommon=\"checked\";\nlet defaultUncommon=\"\";\nlet defaultRare=\"\";\n\nconst macroActor = token.actor;\n\nconst CompendiumID = \"pf2e.equipment-srd\";\nconst pack = game.packs.get(CompendiumID);\nconst docs = (await pack.getIndex({fields:[\"system.traits\",\"system.level\",\"system.runes\",\"system.range\",\"system.usage\",\"system.slug\",\"system.category\"]})).filter(t => t.type === \"weapon\" && t.system.level.value <= actor.level && t.system.range === null && !t.system.traits.value.includes(\"magical\") && !t.system.traits.value.includes(\"bomb\") && !t.system.traits.value.includes(\"vehicular\") && t.system.runes.potency === 0);\ndocs.sort((a, b) => {\n\tif (a.name < b.name) {\n    return -1;\n  }\n  if (a.name > b.name) {\n    return 1;\n  }\n  return 0;\n});\n\nlet weapons = macroActor.itemTypes.weapon.filter(a => a.isMelee && a.system.runes.property.includes(\"shifting\"));\n\nlet allWeapons = macroActor.itemTypes.weapon.filter(a => a.isMelee);\n\nif (allWeapons.length === 0) { return ui.notifications.warn(\"A valid token with a melee weapon must be selected for this macro to function.\")}\n\nlet weaponList = \"\";\nweapons.forEach((item)=> {\n\tweaponList += '<option value=\"' + item.name + '\">' + item.name + '</option>';\n});\n\nlet allWeaponList = \"\";\nallWeapons.forEach((item)=> {\n\tallWeaponList += '<option value=\"' + item.name + '\">' + item.name + '</option>';\n});\n\nconst formContent = `\n<input type=\"checkbox\" id=\"usingBladeAlly\" name=\"usingBladeAlly\"><label for=\"usingBladeAlly\">Blade Ally Weapon</label><br />\n<div align=\"center\">FROM: <select name=\"weapon\" id=\"weapon\">` + weaponList + `</select></div>\n<table border=0\"><tr>\n<td><input type=\"checkbox\" id=\"simpleWeapons\" name=\"simpleWeapons\" `+defaultSimple+`><label for=\"simpleWeapons\">Simple</label></td>\n<td><input type=\"checkbox\" id=\"martialWeapons\" name=\"martialWeapons\" `+defaultMartial+`><label for=\"martialWeapons\">Martial</label></td>\n<td><input type=\"checkbox\" id=\"advancedWeapons\" name=\"advancedWeapons\" `+defaultAdvanced+`><label for=\"advancedWeapons\">Advanced</label></td></tr>\n<tr><td><input type=\"checkbox\" id=\"commonWeapons\" name=\"commonWeapons\" `+defaultCommon+`><label for=\"commonWeapons\">Common</label></td>\n<td><input type=\"checkbox\" id=\"uncommonWeapons\" name=\"uncommonWeapons\" `+defaultUncommon+`><label for=\"uncommonWeapons\">Uncommon</label></td>\n<td><input type=\"checkbox\" id=\"rareWeapons\" name=\"rareWeapons\" `+defaultRare+`><label for=\"rareWeapons\">Rare</label></td></tr></table>\n<div align=\"center\">TO: <select name=\"shifting\" id=\"shifting\"><option value=\"default\">TBD</option></select></div><br />\n`;\n\nlet d = new Dialog ({\n title: \"Select Weapon to Shift\",\n content: formContent,\n buttons: {\n\tok: {\n\t\ticon: '<i class=\"fa-solid fa-arrow-right-arrow-left\"></i>',\n\t\tlabel: \"Shift\",\n\t\tcallback: (html) => { \n\t\t\titemSelectedCallback(allWeapons.find(t=>t.name === html.find('[name=\"weapon\"]')[0].value), (html.find('[name=\"shifting\"]')[0].value), false);\n\t\t\t},\n\t\t},\n    original: {\n        icon: '<i class=\"fa-solid fa-arrow-rotate-left\"></i>',\n        label: \"Original\",\n        callback: (html) => { \n\t\t\titemSelectedCallback(allWeapons.find(t=>t.name === html.find('[name=\"weapon\"]')[0].value), (html.find('[name=\"shifting\"]')[0].value), true);\n\t\t\t},\n    },    \n\tcancel: {\n\t\ticon: '<i class=\"fas fa-times\"></i>',\n\t\tlabel: \"Cancel\",\n\t\t}\n\t},\n    default: \"ok\",\n render: (html) => {\n\thandleUpdates(html);\n\tCheckForShiftingWeapons(html);\n\tUpdateInventoryWeapons(html);\n\tUpdateAvailableOptions(html);},\n default: \"cancel\"\n}).render(true);\n\n/*\nFUNCTION CheckForShiftingWeapons\nThis function checks to see if there are any weapons with a Shifting rune on the selected token.  If there is not, defaults the Blade Ally checkbox to checked and disabled.\n*/\nfunction CheckForShiftingWeapons(html)\n{\n\tif (weaponList.length === 0 && token.actor.itemTypes.feat.some(s => s.slug === \"divine-ally\"))\n\t\t{\n\t\t\thtml.find('[name=\"usingBladeAlly\"]')[0].checked = true;\n\t\t\thtml.find('[name=\"usingBladeAlly\"]')[0].disabled = true;\n\t\t}\n\tif (weaponList.length !== 0 && !token.actor.itemTypes.feat.some(s => s.slug === \"divine-ally\")) {\n\t\thtml.find('[name=\"usingBladeAlly\"]')[0].disabled = true;\n\t}\n}\n\n/*\nFUNCTION UpdateInventoryWeapons\nThis function updates the dropdown on the dialog to show all weapons or just those with Shifting runes, based on the status of the Blade Ally checkbox.\n*/\nasync function UpdateInventoryWeapons(html)\n{\n\tlet useAllWeapons = html.find('[name=\"usingBladeAlly\"]')[0].checked || weaponList.length === 0;\n\tif (useAllWeapons)\n\t\thtml.find('[name=\"weapon\"]')[0].innerHTML = allWeaponList;\n\telse\n\t\thtml.find('[name=\"weapon\"]')[0].innerHTML = weaponList;\t\n}\n\n/*\nFUNCTION handleUpdates\nThis function adds onChange handlers for the various checkboxes and dropdowns in the dialog box.\n*/\nasync function handleUpdates(html)\n{\n\thtml.find('[name=\"usingBladeAlly\"]').on(\"change\", function(){UpdateInventoryWeapons(html)});\n\thtml.find('[name=\"weapon\"]').on(\"change\",function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"simpleWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"martialWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"advancedWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"commonWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"uncommonWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n\thtml.find('[name=\"rareWeapons\"]').on(\"change\", function(){UpdateAvailableOptions(html)});\n}\n\n/*\nFUNCTION UpdateAvailableOptions\nThis function updates the lower dropdown based on the filters and selected weapon to shift from.\n*/\nfunction UpdateAvailableOptions(html)\n{\n\tlet selectedText = html.find('[name=\"weapon\"]')[0].value; \n\tlet selected = allWeapons.find(t=>t.name === selectedText);\n\tlet filterSimple = html.find('[name=\"simpleWeapons\"]')[0].checked;\n\tlet filterMartial = html.find('[name=\"martialWeapons\"]')[0].checked;\n\tlet filterAdvanced = html.find('[name=\"advancedWeapons\"]')[0].checked;\n\tlet filterCommon = html.find('[name=\"commonWeapons\"]')[0].checked;\n\tlet filterUncommon = html.find('[name=\"uncommonWeapons\"]')[0].checked;\n\tlet filterRare = html.find('[name=\"rareWeapons\"]')[0].checked;\n\t\n\tlet entries = docs.filter(i => i.system.usage.value === selected.system.usage.value && i.system.slug !== selected.system.slug);\n\tentries = entries.filter(i => (i.system.category === \"simple\" && filterSimple) || (i.system.category === \"martial\" && filterMartial) || (i.system.category === \"advanced\" && filterAdvanced === true));\n\tentries = entries.filter(i=> (i.system.traits.rarity === \"common\" && filterCommon) || (i.system.traits.rarity === \"uncommon\" && filterUncommon) || (i.system.traits.rarity === \"rare\" && filterRare));\n\t\n\tlet newWeapons = \"\";\n\tentries.forEach((item)=> {\n\t\tnewWeapons += '<option value=\"' + item._id + '\">' + item.name + '</option>';\n\t\t});\n\t\n\thtml.find('[name=\"shifting\"]')[0].innerHTML = newWeapons;\t\t\t\n}\n\n/*\nFUNCTION itemSelectedCallback\nThis is where the magic happens.  Create a new object from the selected weapon to shift into, copy all runes, materials, and equipped status from the original weapon onto it.  Add the new object to the token's actor.  Delete the old object.  Display a message to the chat.\n*/\nasync function itemSelectedCallback(weaponToShift, newWeaponID, revert)\n{\n    let originalItemName = weaponToShift.name;\n    let itemObject;\n    if (!revert) {\n\t    let itemToMove = await pack.getDocument(newWeaponID);\n\t    itemObject = await itemToMove.toObject();\n\t    itemObject.system.material = weaponToShift.system.material;\n\t    itemObject.system.runes = weaponToShift.system.runes;\n    }\n    if (revert) { \n\t\tif (weaponToShift.flags.pf2e.originalItemData !== undefined){\n        itemObject = weaponToShift.flags.pf2e.originalItemData;\n\t\t}\n\t\telse{ return ui.notifications.warn(\"This is the original weapon\");}\n    }\n\n\tlet equippedStatus = weaponToShift.system.equipped;\n\n\tlet nw = await macroActor.createEmbeddedDocuments('Item',[itemObject]);\n\tif (weaponToShift.flags.pf2e.originalItemData === undefined && !revert){\n\t\tawait nw[0].setFlag(\"pf2e\",\"originalItemData\",(await weaponToShift.toObject()));\n\t}\n\tif (weaponToShift.flags.pf2e.originalItemData !== undefined && !revert) {\n\t\tawait nw[0].setFlag(\"pf2e\",\"originalItemData\",weaponToShift.flags.pf2e.originalItemData);\n\t}\n\t// This line is needed as a separate call, because updating the equipped status on \n\t// the createEmbeddedDocuments call was immediately overwritten somewhere else in the \n\t// PF2E code\n\tawait macroActor.updateEmbeddedDocuments('Item',[{_id:nw[0]._id,'system.equipped':equippedStatus}]);\n\t\t\t\t\t\n\tlet nin = nw[0].name;\n\tawait macroActor.deleteEmbeddedDocuments('Item', macroActor.items.filter(value=> (value.name === weaponToShift.name)).map(i=>i.id));\t\n\n// One possible improvement here is the card-content, which is a copy-paste from the Shifting rune's description.  Perhaps there's a way to bring that in directly?\t\n\t\tlet chatcontent = `\n\t<div class=\"pf2e chat-card item-card\">\n\t\t<header class=\"card-header flexrow\">\n\t\t\t<img src=\"systems/pf2e/icons/actions/OneAction.webp\" title=\"Shifting Weapon\" width=\"36\" height=\"36\">\n\t\t\t<h3>Shifting Weapon</h3>\n\t\t</header>\n\t\t<section class=\"item-properties tags\">\n\t\t\t<span class=\"tag tooltipsered\" data-trait=\"manipulate\" data-description=\"PF2E.TraitDescriptionManipulate\">Manipulate</span>\n\t\t\t<hr class=\"vr\">\n\t\t\t<span class=\"tag tag_alt tooltipstered\" data-slug=\"magical\" data-description=\"PF2E.TraitDescriptionMagical\">Magical</span>\n\t\t\t<span class=\"tag tag_alt tooltipstered\" data-trait=\"\" data-description=\"PF2E.TraitDescriptionTransmutation\">Transmutation</span>\n\t\t</section>\n\t\t<section class=\"card-content\">\n\t\t\t<p>\n\t\t\tThe weapon takes the shape of another melee weapon that requires the same number of hands to wield. The weapon's runes and any precious material it's made of apply to the weapon's new shape. Any property runes that can't apply to the new form are suppressed until the item takes a shape to which they can apply.\n\t\t\t</p>\n\t\t</section>\n\t\t<hr>\n\t\t<p>\n\t\t\t`+originalItemName+` shifts into `+nin+`.\n\t\t</p>\t\n\t</div>\n\t`;\n\t\n\tlet user = ChatMessage.getSpeaker(token.actor);\n\tChatMessage.create({\n\t\t\tspeaker: user,\n\t\t\ttype:0,\n\t\t\tcontent: chatcontent\n\t\t});\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/weaponshifting.js\" - Fetched on 2024-06-05T17:22:21.773Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT weaponshifting","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"bmAstkMpMc2BzpZX","actorIds":[],"author":"HtChkVZfvqtViTu3","command":"/*\nBased on the macro Contributed by ArthurTrumpet\nmodified by darkim\n\nUses the built in Battle medicine immunity effect to track who has healed whom.\nPlayer selects the token being healed, and chooses the healer from the drop down.\nThe effect icon won't appear on the token, as you can potentially be battle medicined several times, and it would just clutter up the token. \nIf you want to show the icons, update the variable showIcons on line #2 to true.\nImmunity duration is set depending on several factors. Default is 24 hours. \nIf healed by an Investigator with the Forensic Medicine methodology, it is 1 hour. \nA character with godless healing feat will get a 1 hour immunity.\nThe macro will set an effect on the medic to indicate if they have used this ability (or whether it is not currently available). \nThe duration is automatically set depending on the Medicine skill level of the medic.\n\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst bm_UUID = 'Compendium.pf2e.feat-effects.2XEYQNZTCGpdkyR6'; //Battle medicine Immunity effect\nconst showIcons = true;\n\nif (!token) {\n    ui.notifications.error(\"No token selected!\");\n} else {\n    main();\n}\n\nfunction CheckFeat(slug, healer) {\n    return healer.itemTypes.feat.some((i) => i.slug === slug);\n}\n\nasync function main(html) {\n    const message = game.messages.contents.reverse().find( m => m.flags.treat_wounds_battle_medicine?.id === token.id);\n    if (message === undefined) {\n        ui.notifications.info(\"Wrong token selected!\");\n    } else {\n        const bmEffect = (await fromUuid(bm_UUID)).toObject();\n        bmEffect.system.tokenIcon.show = showIcons; //Potential for lots of effects to be on a token. Don't show icon to avoid clutter\n        bmEffect.flags.core ??= {};\n        bmEffect.flags.core.sourceId = bm_UUID;\n\n        const applicator = game.actors.get(message.flags.treat_wounds_battle_medicine.healerId);\n        const bmBatonUsed = message.flags.treat_wounds_battle_medicine.bmBatonUsed;\n\n        bmEffect.name = \"Battle Medicine by \" + applicator.name;\n        bmEffect.img = applicator.prototypeToken.texture.src;\n        const isgodless = CheckFeat('godless-healing', token.actor); //godless healing affects the patient, not the healer\n        const isForensic = CheckFeat('forensic-medicine-methodology', applicator);\n\n        if (isForensic || isgodless || bmBatonUsed) {\n            bmEffect.system.duration.unit = \"hours\";\n        }\n\n        await token.actor.createEmbeddedDocuments(\"Item\", [bmEffect]);\n        ui.notifications.info(token.actor.name + \" is now immune to Battle Medicine by \" + applicator.name);\n    }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/BM Immunity CD.js\" - Fetched on 2024-06-05T17:22:21.774Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT BM Immunity CD","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"daqFwFcdzp8lA9hM","actorIds":[],"author":"IYMFaVT3iSHjD9a4","command":"/*\nThis is a macro designed to facilitate building a dual class item for the Dual Class Variant Rule.\nSimply select your 2 classes and the macro will create an item you can drag and drop onto your character sheet.\nThis will need to be run by a GM or someone with the ability to create items in the system.\nLook for the created class item in the items tab.\n*/\n\nconst packKeys = [\"pf2e.classes\"] //array of pack key strings\nconst classesData = [] //array of classData that will be built from the array of packs\nconst clPacks = game.packs.filter( p => packKeys.includes(p.collection) )\nfor ( const pack of clPacks ) { classesData.push(...(await pack.getIndex())) }\nif ( classesData.some(t => t.type !== \"class\") ) return void ui.notifications.warn(\"One of the inputted packKeys is not a classes Compendium\");\nconst classes = classesData.map( n => n.name );\nconst qDData = [\n  { label: `Choose your 1st Class : `, type: `select`, options: classes },\n  { label: `Choose your 2nd Class : `, type: `select`, options: classes }\n];\n\nconst chosenClasses = await quickDialog({ data: qDData, title: `Dual Class item creator` });\n\nconst class1 = await fromUuid(classesData.find(n => n.name === chosenClasses[0]).uuid);\nconst class2 = await fromUuid(classesData.find(n => n.name === chosenClasses[1]).uuid);\n\nif (class1 === class2) { return ui.notifications.warn(\"You cannot select the same class twice\"); }\n\nconst dClassObj = Object.assign({}, class1);\nObject.defineProperty(dClassObj, 'system', {\n  value: duplicate(class1.system),\n  configurable: true,\n  writeable: true\n});\n\nconst rE = {\n  \"domain\": \"all\",\n  \"key\": \"RollOption\",\n  \"option\": `class:${class2.system.slug}`,\n  \"priority\": 0\n};\n\nconst dClass = dClassObj;\n\ndClass.name = `${class1.name} - ${class2.name}`;\n\n//Attacks\nif (class2.system.attacks.advanced > dClass.system.attacks.advanced) { dClass.system.attacks.advanced = class2.system.attacks.advanced }\nif (class2.system.attacks.martial > dClass.system.attacks.martial) { dClass.system.attacks.martial = class2.system.attacks.martial }\nif (class2.system.attacks.simple > dClass.system.attacks.simple) { dClass.system.attacks.simple = class2.system.attacks.simple }\nif (class2.system.attacks.unarmed > dClass.system.attacks.unarmed) { dClass.system.attacks.unarmed = class2.system.attacks.unarmed }\nif (dClass.system.attacks.martial <= dClass.system.attacks.other.rank) {\n  if (class2.system.attacks.other.rank === dClass.system.attacks.other.rank) {\n    let mashed = `${dClass.system.attacks.other.name}, ${class2.system.attacks.other.name}`\n    mashed = mashed.replace(\"and \", \"\")\n    dClass.system.attacks.other.name = [...new Set(mashed.split(','))].join(',');\n  }\n  if (class2.system.attacks.other.rank > dClass.system.attacks.other.rank) { dClass.system.attacks.other.name = class2.system.attacks.other.name; dClass.system.attacks.other.rank = class2.system.attacks.other.rank; }\n}\nif (dClass.system.attacks.martial >= class2.system.attacks.other.rank && dClass.system.attacks.martial >= dClass.system.attacks.other.rank) { dClass.system.attacks.other.rank = 0; dClass.system.attacks.other.name = \"\"; }\n\n//Class DC\nif (class2.system.classDC > dClass.system.classDC) { dClass.system.classDC = class2.system.classDC }\n\n//Defenses\nif (class2.system.defenses.heavy > dClass.system.defenses.heavy) { dClass.system.defenses.heavy = class2.system.defenses.heavy }\nif (class2.system.defenses.light > dClass.system.defenses.light) { dClass.system.defenses.light = class2.system.defenses.light }\nif (class2.system.defenses.heavy > dClass.system.defenses.medium) { dClass.system.defenses.medium = class2.system.defenses.medium }\nif (class2.system.defenses.unarmored > dClass.system.defenses.unarmored) { dClass.system.defenses.unarmored = class2.system.defenses.unarmored }\n\n//Description\ndClass.system.description.value = `${dClass.system.description.value} ${class2.system.description.value}`;\n\n//HP\nif (class2.system.hp > dClass.system.hp) { dClass.system.hp = class2.system.hp }\n\n//Items\nObject.entries(class2.system.items).forEach(i => {\n  if (Object.values(dClass.system.items).some(x => x.uuid === i[1].uuid && x.level <= i[1].level)) { return }\n  if (Object.values(dClass.system.items).some(x => x.uuid === i[1].uuid && x.level > i[1].level)) { return Object.values(dClass.system.items).find(x => x.uuid === i[1].uuid).level = i[1].level }\n  else { dClass.system.items[i[0]] = i[1]; }\n});\n\n//Key Ability\nclass2.system.keyAbility.value.forEach(v => {\n  if (dClass.system.keyAbility.value.includes(v)) { return }\n  dClass.system.keyAbility.value.push(v);\n});\n\n//Perception\nif (class2.system.perception > dClass.system.perception) { dClass.system.perception = class2.system.perception }\n\n//Rules\ndClass.system.rules.push(rE);\nclass2.system.rules.forEach(r => {\n  if (dClass.system.rules.includes(r)) { return }\n  dClass.system.rules.push(r);\n});\ndClass.system.rules.forEach((r, i) => {\n  if (r.path === undefined) { return }\n  const check = r.path.split('.');\n  if (check.includes(\"data\") && check.includes(\"martial\") && check.includes(\"rank\") && dClass.system.attacks.martial >= r.value) {\n    dClass.system.rules.splice(i, 1);\n  }\n});\n\n//Saving Throws\nif (class2.system.savingThrows.fortitude > dClass.system.savingThrows.fortitude) { dClass.system.savingThrows.fortitude = class2.system.savingThrows.fortitude }\nif (class2.system.savingThrows.reflex > dClass.system.savingThrows.reflex) { dClass.system.savingThrows.reflex = class2.system.savingThrows.reflex }\nif (class2.system.savingThrows.will > dClass.system.savingThrows.will) { dClass.system.savingThrows.will = class2.system.savingThrows.will }\n\n//Skill Feat Levels\nclass2.system.skillFeatLevels.value.forEach(v => { dClass.system.skillFeatLevels.value.push(v) });\ndClass.system.skillFeatLevels.value = [...new Set(dClass.system.skillFeatLevels.value)].sort((a, b) => { return a - b; });\n\n//Skill Increase Levels\nclass2.system.skillIncreaseLevels.value.forEach(v => { dClass.system.skillIncreaseLevels.value.push(v) });\ndClass.system.skillIncreaseLevels.value = [...new Set(dClass.system.skillIncreaseLevels.value)].sort((a, b) => { return a - b; });\n\n//Trained Skills\nif (class2.system.trainedSkills.additional > dClass.system.trainedSkills.additional) { dClass.system.trainedSkills.additional = class2.system.trainedSkills.additional }\nclass2.system.trainedSkills.value.forEach(v => {\n  if (dClass.system.trainedSkills.value.includes(v)) { return }\n  dClass.system.trainedSkills.value.push(v);\n});\n\n//Set the image of the Class\ndClass.img = \"systems/pf2e/icons/spells/guidance.webp\";\n\nawait Item.create(dClass);\nui.notifications.info(`A new item called ${dClass.name} has been created in the game's items tab. Drag and drop to an actor sheet to create a Dual Class Character. System's Dual Class variant must be enabled for this to work properly.`);\n\nasync function quickDialog({ data, title = `Quick Dialog` } = {}) {\n  data = data instanceof Array ? data : [data];\n\n  return await new Promise(async (resolve) => {\n    let content = `\n      <table style=\"width:100%\">\n      ${data.map(({ type, label, options }, i) => {\n      if (type.toLowerCase() === `select`) {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e, i) => `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n      }\n      else if (type.toLowerCase() === `checkbox`) {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n      }\n      else {\n        return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n      }\n    }).join(``)}\n      </table>`;\n\n    await new Dialog({\n      title, content,\n      buttons: {\n        Ok: {\n          label: `Ok`, callback: (html) => {\n            resolve(Array(data.length).fill().map((e, i) => {\n              let { type } = data[i];\n              if (type.toLowerCase() === `select`) {\n                return html.find(`select#${i}qd`).val();\n              }\n              else {\n                switch (type.toLowerCase()) {\n                  case `text`:\n                  case `password`:\n                  case `radio`:\n                    return html.find(`input#${i}qd`)[0].value;\n                  case `checkbox`:\n                    return html.find(`input#${i}qd`)[0].checked;\n                  case `number`:\n                    return html.find(`input#${i}qd`)[0].valueAsNumber;\n                }\n              }\n            }));\n          }\n        }\n      },\n      default: 'Ok'\n    })._render(true);\n    document.getElementById(\"0qd\").focus();\n  });\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Dual Class.js\" - Fetched on 2024-06-05T17:22:21.768Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Dual Class","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"dtBld38AU3mA7Wfr","actorIds":[],"author":"PF7wapriIFKeZnhD","command":"/*\nThis Macro is to be used in conjunction with the Spellstrike Macro.\nYou simply run this macro with the token selected.\nIt will then prompt you for a spell in a Spellcasting Entry based off of intelligence to be your Standby Spell.\nCertain exceptions will need to be monitored.\nIf you would like to change the Standby Spell, simply run the macro again.\nYou can clear your Standby Spell and Entry by choosing 'Clear Standby Spell' entry in the dropdown.\n*/\n\nif (canvas.tokens.controlled.length !== 1) { return void ui.notifications.warn(\"You must select 1 token that's a Magus or has the Magus Dedication!\"); }\nif (token.actor.class.slug !== \"magus\" && token.actor.flags.pf2e.rollOptions.all[\"class:magus\"] === undefined && !token.actor.itemTypes.feat.some(f => f.slug === \"magus-dedication\")) { return void ui.notifications.warn(\"The selected token is not a Magus or does not possess the Magus Dedication!\"); }\nif (token.actor.itemTypes.feat.some(f => f.slug === \"magus-dedication\") && !token.actor.itemTypes.feat.some(f => f.slug === \"spellstriker\")) { return void ui.notifications.warn(\"Token with Magus Dedication does not possess the Spellstriker feat!\"); }\nif (!token.actor.itemTypes.feat.some(f => f.slug === \"standby-spell\")) { return void ui.notifications.warn(\"Selected token does not possess the Standby Spell feat!\"); }\n\nconst ess = token.actor.itemTypes.feat.some(f => f.slug === 'expansive-spellstrike');\n\nconst spells = await spellList(actor, ess);\n\nif (spells.length === 0) { return void ui.notifications.warn(\"You have no spells that can be assigned as a standby spell.\") }\n\nif (spells.some(s => s.flags.pf2e.standbySpell)) {\n  const options = spells.filter(c => !c.flags.standbySpell).map(n => [n.slug, `${n.name} (${n.spellcasting.name})`] );\n  options.push([\"clear\", \"Clear Standby Spell\"]);\n  const flagged = spells.find(s => s.flags.pf2e.standbySpell);\n  const choice = await choose( options, prompt = `Replace your Standby Spell (${flagged.name}) : `);\n  if (choice === \"clear\") {\n    const flagged1 = token.actor.itemTypes.spell.find(s => s.flags.pf2e.standbySpell);\n    await flagged1.unsetFlag(\"pf2e\",\"standbySpell\");\n    return ui.notifications.info(`Standby Spell cleared`);\n  }\n  const spell = spells.find(f => f.slug === choice);\n  await flagged.unsetFlag(\"pf2e\",\"standbySpell\");\n  await spell.setFlag(\"pf2e\",\"standbySpell\",true);\n}\n\nelse {\n  const options = spells.map(n => [n.slug, `${n.name} (${n.spellcasting.name})`] );\n  const choice1 = await choose( options, prompt = `Choose your Standby Spell : `);\n  const spell = spells.find(f => f.slug === choice1);\n  await spell.setFlag(\"pf2e\",\"standbySpell\",true);\n}\n\n\n/*\n  Choose\n    Send an array of options for a drop down choose menu. (Single)\n    returns a promise (value is chosen element of array) \n  options = [`display_return_value`, ...] or [[return_value , `display`],...],\n  prompt = `display_prompt_question` \n*/\nasync function choose(options = [], prompt = ``){\n  return new Promise((resolve) => {\n    let dialog_options = (options[0] instanceof Array)\n      ? options.map(o => `<option value=\"${o[0]}\">${o[1]}</option>`).join(``)\n      : options.map(o => `<option value=\"${o}\">${o}</option>`).join(``);\n  \n    let content = `\n    <table style=\"width=100%\">\n      <tr><th>${prompt}</th></tr>\n      <tr><td><select id=\"choice\" autofocus>${dialog_options}</select></td></tr>\n    </table>`;\n  \n    new Dialog({\n      content, \n      buttons : { OK : {label : `OK`, callback : async (html) => { resolve(html.find('#choice').val()); } } }\n    },{width:\"auto\"}).render(true);\n  });\n}\n\nasync function spellList(actor, ess) {\n  // A bunch of these should be excluded because they are not AoE spells, but there area bunch of AoE spells\n  // with multiple area choices and the system encodes these as no area, so we consider no area as AoE and then\n  // fix the mistakes with this list.\n  const blacklist = new Set([\n    \"celestial-accord\",\n    \"shattering-gem\",\n    \"entangle-fate\",\n    \"behold-the-weave\",\n    \"compel-true-name\",\n    \"foul-miasma\",\n    \"invoke-the-harrow\",\n    \"rewrite-memory\",\n    \"subconscious-suggestion\",\n    \"excise-lexicon\",\n    \"enthrall\",\n    \"mind-reading\",\n    \"mirecloak\",\n    \"mask-of-terror\",\n    \"hallucination\",\n    \"hyperfocus\",\n    \"pact-broker\",\n    \"death-knell\",\n    \"sudden-recollection\",\n    \"favorable-review\",\n    \"litany-of-self-interest\",\n    \"suggestion\",\n    \"command\",\n    \"dj-vu\",\n    \"charming-touch\",\n    \"charm\",\n    \"possession\",\n    \"cornucopia\",\n    \"delay-affliction\",\n    \"heal-companion\",\n    \"natures-bounty\",\n    \"rebuke-death\",\n    \"wholeness-of-body\",\n    \"revival\"\n  ]);\n\n  // ESS, in addition to AoE spells, extends \"spell attacks\" to \"harmful spells that target a creature\".\n  // Most harmful spells that target a creature are attacks, but some aren't.  These are they:\n  const harmfulNonAttacks = new Set(['force-barrage', 'force-fang']);\n  const undead = [...game.user.targets.values()].some(t => t.actor.traits.has('undead'));\n  if (undead) harmfulNonAttacks.add('heal');\n  // Don't allow healing damage spells, unless they are also vitality and there is an undead target\n  const healing = (spell, data) => data.damage?.[0]?.kinds.has('healing') &&\n    !(undead && spell.traits.has('vitality'));\n\n  // Spells that ESS allows us to use, beyond spell attacks\n  const essAllowed = (spell, data) => harmfulNonAttacks.has(data.slug) || (\n    !data.target.value.includes('willing') && !healing(spell, data) && (\n      (data.target.value.includes(\"creature\") && data.hasDamage) ||\n      ([\"line\", \"cone\", \"burst\", undefined].includes(data.area?.type) && (data.hasDamage || data.isSave))\n    )\n  );\n  // \"1\", \"2\", \"2 to 2 rounds\", \"1 or 2\", etc.\n  const actionsAllowed = /^[12]( (or|to) .*)?$/;\n\n  const spells = [];\n  for (const e of actor.itemTypes.spellcastingEntry.filter(r => r.system.prepared?.value !== \"items\" && r.isPrepared && r.attribute === \"int\")) {\n    for (const spell of e.spells) {\n      const spellChatData = await spell.getChatData();\n      const isStrikeable = (spell.isAttack || (ess && essAllowed(spell, spellChatData))) && actionsAllowed.test(spell.system.time?.value) && !blacklist.has(spell.slug) && !spell.isCantrip;\n      if (!isStrikeable) continue;\n      spells.push(spell)\n    }\n  }\n  spells.sort((a, b) => {\n    if (a.lvl === b.lvl)\n      return a.name.toUpperCase().localeCompare(b.name.toUpperCase(), undefined, {sensitivity: \"base\"});\n      return a.lvl - b.lvl;\n  });\n\n  return spells;\n};\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Assign Standby Spell.js\" - Fetched on 2024-06-05T17:22:21.767Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Assign Standby Spell","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"eIVW0bmWOObndVAo","actorIds":[],"author":"9kHW6SOYYHN6acTv","command":"// Sets prototype tokens to show name and HP on hover\nconst actorUpdate = game.actors.map(e => ({\n    _id: e.id,\n    \"token.displayBars\": CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    \"token.displayName\": CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    \"token.bar1\": {attribute: \"attributes.hp\"},\n    \"token.bar2\": {attribute: null}\n}));\nawait Actor.updateDocuments(actorUpdate);\nui.notifications.info(\"PROTOTYPE TOKENS UPDATED\");\n// Sets scene tokens to show name and HP on hover\nlet scene = game.scenes.active;\nlet tokenUpdates = scene.tokens.map(e => ({\n    _id: e.id,\n    displayBars: CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    displayName: CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER,\n    bar1: {attribute: \"attributes.hp\"},\n    bar2: {attribute: null}\n}));\nawait scene.updateEmbeddedDocuments(\"Token\", tokenUpdates);\nui.notifications.info(`TOKENS UPDATED on scene: ${scene.name}`);\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Token names and hp on hover.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Token names and hp on hover","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"ebWwjgl4POMHm7J7","actorIds":[],"author":"qanRKVWcNe5EPaPi","command":"//=================================================\n//          Research Task Template\n// Author: Zael, Variant Rules\n// A simple macro for displaying Research Tasks\n// for the Research Variant Rule.\n//=================================================\n\n\n//=================================================\n//          Parameters (Edit this Section)\n//=================================================\n\n// Main Information\nlet reasearchName = `Research Title`;\nlet researchLevel = `1`;\nlet researchDescription = `Research Description.`;\nlet researchIcon = `icons/svg/d20-black.svg`;\n\n// Traits (Leave a Trait Blank to Hide It)\nlet researchTraitA = `Trait`;\nlet researchTraitB = `Trait`;\nlet researchTraitC = `Trait`;\nlet researchTraitD = ``;\nlet researchTraitE = ``;\n\n//Tasks (Leave a Task Name Blank to Hide It)\n// Task One Information\nlet researchTaskOneName = `Task One`;\nlet researchTaskOneDesc = `Task One Description.`;\nlet researchTaskOneMaxRP = `15`;\nlet researchTaskOneCheckA = `skill`;\nlet researchTaskOneCheckB = `skill`;\nlet researchTaskOneCheckC = `skill`;\nlet researchTaskOneCheckD = `skill`;\n\n// Task Two Information\nlet researchTaskTwoName = `Task Two`;\nlet researchTaskTwoDesc = `Task Two Description.`;\nlet researchTaskTwoMaxRP = `20`;\nlet researchTaskTwoCheckA = `skill`;\nlet researchTaskTwoCheckB = `skill`;\nlet researchTaskTwoCheckC = `skill`;\nlet researchTaskTwoCheckD = `skill`;\n\n// Task Three Information\nlet researchTaskThreeName = `Task Three`;\nlet researchTaskThreeDesc = `Task Three Description.`;\nlet researchTaskThreeMaxRP = `10`;\nlet researchTaskThreeCheckA = `skill`;\nlet researchTaskThreeCheckB = `skill`;\nlet researchTaskThreeCheckC = `skill`;\nlet researchTaskThreeCheckD = `skill`;\n\n// Task Four Information\nlet researchTaskFourName = ``;\nlet researchTaskFourDesc = `Task Four Description.`;\nlet researchTaskFourMaxRP = `5`;\nlet researchTaskFourCheckA = `skill`;\nlet researchTaskFourCheckB = `skill`;\nlet researchTaskFourCheckC = `skill`;\nlet researchTaskFourCheckD = `skill`;\n\n// Research Points (Leave a Reward Blank to Hide It)\nlet fiveRPreward = `Event or Reward A.`;\nlet tenRPreward = `Event or Reward B.`;\nlet fifteenRPreward = `Event or Reward C.`;\nlet twentyRPreward = `Event or Reward D.`;\nlet twentyfiveRPreward = `Event or Reward E.`;\nlet thirtyRPreward = `Event or Reward F.`;\nlet fourtyRPreward = ``;\nlet fiftyRPreward = ``;\n\n//=================================================\n//\n//                     WARNING!\n//\n//=================================================\n\n//=================================================\n//\n//  Message Assembly (Do Not Edit This Section)\n//\n//=================================================\n\n// Process Level and DC\nlet ProcessedDC = Math.round(14 + (1.3*researchLevel));\nlet ProcessedDCHard = Math.round(ProcessedDC + 2);\nlet ProcessedDCVeryHard = Math.round(ProcessedDC + 5);\nlet ProcessedDCIncrediblyHard = Math.round(ProcessedDC + 10);\nlet ProcessedDCEasy = Math.round(ProcessedDC - 2);\nlet ProcessedDCVeryEasy = Math.round(ProcessedDC - 5);\nlet ProcessedDCIncrediblyEasy = Math.round(ProcessedDC - 10);\n\n\n// Correct Empty Traits\n// Trait Correction A\nif (researchTraitA ===\"\"){\n    traitA = ``;\n    console.log('Trait A skipped.');\n} else {\n    traitA = `\n    <span class=\"tag tooltipstered\" data-trait=\"${researchTraitA}\" data-description=\"PF2E.TraitDescription${researchTraitA}\">${researchTraitA}</span>`;\n}\n\n// Trait Correction B\nif (researchTraitB ===\"\"){\n    traitB = ``;\n    console.log('Trait B skipped.');\n} else {\n    traitB = `\n    <span class=\"tag tooltipstered\" data-trait=\"${researchTraitB}\" data-description=\"PF2E.TraitDescription${researchTraitB}\">${researchTraitB}</span>`;\n}\n\n// Trait Correction C\nif (researchTraitC ===\"\"){\n    traitC = ``;\n    console.log('Trait C skipped.');\n} else {\n    traitC = `\n    <span class=\"tag tooltipstered\" data-trait=\"${researchTraitC}\" data-description=\"PF2E.TraitDescription${researchTraitC}\">${researchTraitC}</span>`;\n}\n\n// Trait Correction D\nif (researchTraitD ===\"\"){\n    traitD = ``;\n    console.log('Trait D skipped.');\n} else {\n    traitD = `\n    <span class=\"tag tooltipstered\" data-trait=\"${researchTraitD}\" data-description=\"PF2E.TraitDescription${researchTraitD}\">${researchTraitD}</span>`;\n}\n\n// Trait Correction E\nif (researchTraitE ===\"\"){\n    traitE = ``;\n    console.log('Trait E skipped.');\n} else {\n    traitE = `\n    <span class=\"tag tooltipstered\" data-trait=\"${researchTraitE}\" data-description=\"PF2E.TraitDescription${researchTraitE}\">${researchTraitE}</span>`;\n}\n\n// Setup Traits\nlet researchTraits = `<div class=\"tags\">` + traitA + traitB + traitC + traitD + traitE + `</div>`;\n\n//Correct Research Point Rewards if absent\n// 5 RP\nif (fiveRPreward ===\"\"){\n    fiveReward = ``;\n    console.log('Reward A skipped.');\n} else {\n    fiveReward = `<strong style=\"text-align:left;font-size:80%;\">5 Research Points:</strong> </i>${fiveRPreward}</i></p>`;\n}\n\n// 10 RP\nif (tenRPreward ===\"\"){\n    tenReward = ``;\n    console.log('Reward B skipped.');\n} else {\n    tenReward = `<p><strong style=\"text-align:left;font-size:80%;\">10 Research Points:</strong> </i>${tenRPreward}</i></p>`;\n}\n\n// 15 RP\nif (fifteenRPreward ===\"\"){\n    fifteenReward = ``;\n    console.log('Reward C skipped.');\n} else {\n    fifteenReward = `<p><strong style=\"text-align:left;font-size:80%;\">15 Research Points:</strong> </i>${fifteenRPreward}</i></p>`;\n}\n\n// 20 RP\nif (twentyRPreward ===\"\"){\n    twentyReward = ``;\n    console.log('Reward D skipped.');\n} else {\n    twentyReward = `<p><strong style=\"text-align:left;font-size:80%;\">20 Research Points:</strong> </i>${twentyRPreward}</i></p>`;\n}\n\n// 25 RP\nif (twentyfiveRPreward ===\"\"){\n    twentyfiveReward = ``;\n    console.log('Reward E skipped.');\n} else {\n    twentyfiveReward = `<p><strong style=\"text-align:left;font-size:80%;\">25 Research Points:</strong> </i>${twentyfiveRPreward}</i></p>`;\n}\n\n// 30 RP\nif (thirtyRPreward ===\"\"){\n    thirtyReward = ``;\n    console.log('Reward F skipped.');\n} else {\n    thirtyReward = `<p><strong style=\"text-align:left;font-size:80%;\">30 Research Points:</strong> </i>${thirtyRPreward}</i></p>`;\n}\n\n// 40 RP\nif (fourtyRPreward ===\"\"){\n    fourtyReward = ``;\n    console.log('Reward G skipped.');\n} else {\n    fourtyReward = `<p><strong style=\"text-align:left;font-size:80%;\">40 Research Points:</strong> </i>${fourtyRPreward}</i></p>`;\n}\n\n// 50 RP\nif (fiftyRPreward ===\"\"){\n    fiftyReward = ``;\n    console.log('Reward H skipped.');\n} else {\n    fiftyReward = `<p><strong style=\"text-align:left;font-size:80%;\">50 Research Points:</strong> </i>${fiftyRPreward}</i></p>`;\n}\n\n// Check Task Names and Hide the Task if Blank\nif (researchTaskOneName ===\"\") {\n    taskOne = ``;\n    console.log('Task One skipped.');\n} else {\n    taskOne = `\n    <hr>\n    <p><strong style=\"text-align:left;font-size:120%;\">${researchTaskOneName}</strong></p>\n    <p><i style=\"padding:15px;text-align:left;font-size:80%;\">${researchTaskOneDesc}</i></p>\n    <br><div data-visibility=\"gm\"><i style=\"padding:15px;text-align:left;font-size:80%;\"><strong>Maximum RP:</strong> ${researchTaskOneMaxRP}</i></div>\n    <p>@Check[type:${researchTaskOneCheckA}|dc:${ProcessedDCVeryEasy}|basic:true]</p>\n    <p>@Check[type:${researchTaskOneCheckB}|dc:${ProcessedDCEasy}|basic:true]</p>\n    <p>@Check[type:${researchTaskOneCheckC}|dc:${ProcessedDC}|basic:true]</p>\n    <p>@Check[type:${researchTaskOneCheckD}|dc:${ProcessedDCHard}|basic:true]</p>\n    `;\n}\n\n// Task Two\nif (researchTaskTwoName ===\"\") {\n    taskTwo = ``;\n    console.log('Task Two skipped.');\n} else {\n    taskTwo = `\n    <hr>\n    <p><strong style=\"text-align:left;font-size:120%;\">${researchTaskTwoName}</strong></p>\n    <p><i style=\"padding:15px;text-align:left;font-size:80%;\">${researchTaskTwoDesc}</i></p>\n    <br><div data-visibility=\"gm\"><i style=\"padding:15px;text-align:left;font-size:80%;\"><strong>Maximum RP:</strong> ${researchTaskTwoMaxRP}</i></div>\n    <p>@Check[type:${researchTaskTwoCheckA}|dc:${ProcessedDCEasy}|basic:true]</p>\n    <p>@Check[type:${researchTaskTwoCheckB}|dc:${ProcessedDC}|basic:true]</p>\n    <p>@Check[type:${researchTaskTwoCheckC}|dc:${ProcessedDCHard}|basic:true]</p>\n    <p>@Check[type:${researchTaskTwoCheckD}|dc:${ProcessedDCHard}|basic:true]</p>\n    `;\n}\n\n// Task Three\nif (researchTaskThreeName ===\"\") {\n    taskThree = ``;\n    console.log('Task Three skipped.');\n} else {\n    taskThree = `\n    <hr>\n    <p><strong style=\"text-align:left;font-size:120%;\">${researchTaskThreeName}</strong></p>\n    <p><i style=\"padding:15px;text-align:left;font-size:80%;\">${researchTaskThreeDesc}</i></p>\n    <br><div data-visibility=\"gm\"><i style=\"padding:15px;text-align:left;font-size:80%;\"><strong>Maximum RP:</strong> ${researchTaskThreeMaxRP}</i></div>\n    <p>@Check[type:${researchTaskThreeCheckA}|dc:${ProcessedDC}|basic:true]</p>\n    <p>@Check[type:${researchTaskThreeCheckB}|dc:${ProcessedDC}|basic:true]</p>\n    <p>@Check[type:${researchTaskThreeCheckC}|dc:${ProcessedDCHard}|basic:true]</p>\n    <p>@Check[type:${researchTaskThreeCheckD}|dc:${ProcessedDCVeryHard}|basic:true]</p>\n    `;\n}\n\n// Task Four\nif (researchTaskFourName ===\"\") {\n    taskFour = ``;\n    console.log('Task Four skipped.');\n} else {\n    taskFour = `\n    <hr>\n    <p><strong style=\"text-align:left;font-size:120%;\">${researchTaskFourName}</strong></p>\n    <p><i style=\"padding:15px;text-align:left;font-size:80%;\">${researchTaskFourDesc}</i></p>\n    <br><div data-visibility=\"gm\"><i style=\"padding:15px;text-align:left;font-size:80%;\"><strong>Maximum RP:</strong> ${researchTaskFourMaxRP}</i></div>\n    <p>@Check[type:${researchTaskFourCheckA}|dc:${ProcessedDC}|basic:true]</p>\n    <p>@Check[type:${researchTaskFourCheckB}|dc:${ProcessedDCHard}|basic:true]</p>\n    <p>@Check[type:${researchTaskFourCheckC}|dc:${ProcessedDCVeryHard}|basic:true]</p>\n    <p>@Check[type:${researchTaskFourCheckD}|dc:${ProcessedDCIncrediblyHard}|basic:true]</p>\n    `;\n}\n\n// Complete Tasks\nlet completeTasks = taskOne + taskTwo + taskThree + taskFour;\n\n// Establish Rewards List\nlet completeRewards = fiveReward + tenReward + fifteenReward + twentyReward + twentyfiveReward + thirtyReward + fourtyReward + fiftyReward;\n\n// Create Message Text\nlet taskText = `\n    <p><img src=\"${researchIcon}\" alt=\"Research Icon\" style=\"vertical-align:middle;border:0px;width:40px;height:40px;\">&nbsp;&nbsp;<strong style=\"vertical-align:middle;text-align:center;font-size:140%;\">${reasearchName}</strong></p>\n    <div style=\"text-align: right;\"><strong style=\"font-size:90%;\">Library ${researchLevel}</strong></div>\n    <hr>` + \n    researchTraits + `\n    <p><i style=\"padding:15px;text-align:left;font-size:80%;\">${researchDescription}</i></p>` +\n    completeTasks + `\n    <br>\n    <div data-visibility=\"gm\">\n    <hr>` + completeRewards + `\n    </div>\n    `;\n\n\n// Post Message to Chat\nChatMessage.create({\n   user: game.user._id,\n   speaker: ChatMessage.getSpeaker(),\n   content: taskText\n});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Research Template.js\" - Fetched on 2024-06-05T17:22:21.778Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Research Template","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"fK2T1eptnVEJVJFn","actorIds":[],"author":"YrECRZAsneokY9AQ","command":"/*\nBased on the macro by bipedalshark and WesBelmont and Allalinor.\nupdated by darkim, Dalvyn, and julie.winchester\n\nRecall Knowledge\nThis macro will roll several knowledge checks if no target is selected.\nIf one ore more targets are selected it will only roll the relevant knowledge skills and compare the result to the DC.\nHandles lore skills (as far as possible)\nHandles Cognitive Mutagen and other Bonus effects\nShould pick up most single target trait based mods automatically now if predicates are set properly.\n\nLimitations:\n* Does not handle assurance.\n* Does not handle things like bardic knowledge.\n*/\n\n/**\n * Check wether the current actor has a feature.\n *\n * @param {string} slug\n * @returns {boolean} true if the feature exists, false otherwise\n */\nconst checkFeat = (slug) =>\n    token.actor.items\n      .filter((item) => item.type === 'feat')\n      .some((item) => item.slug === slug);\n   \n\nactor = token?.actor ?? actor;\nif (!actor) {\n    return ui.notifications.error(\"No selected token or assigned character\");\n}\n\nif (!game.modules.get(\"xdy-pf2e-workbench\")?.active) {\n    return ui.notifications.error(\"This Macro requires PF2e Workbench module\");\n}\n\nconst HAS_DUBIOUS_KNOWLEDGE = checkFeat('dubious-knowledge');\nconst SKILL_OPTIONS = [\"arcana\", \"crafting\", \"medicine\", \"nature\", \"occultism\", \"religion\", \"society\"];\n\nconst IDENTIFY_SKILLS = {\n    aberration: [\"occultism\"],\n    astral: [\"occultism\"],\n    animal: [\"nature\"],\n    beast: [\"arcana\", \"nature\"],\n    celestial: [\"religion\"],\n    construct: [\"arcana\", \"crafting\"],\n    dragon: [\"arcana\"],\n    elemental: [\"arcana\", \"nature\"],\n    ethereal: [\"occultism\"],\n    fey: [\"nature\"],\n    fiend: [\"religion\"],\n    fungus: [\"nature\"],\n    giant: [\"society\"],\n    humanoid: [\"society\"],\n    monitor: [\"religion\"],\n    ooze: [\"occultism\"],\n    plant: [\"nature\"],\n    spirit: [\"occultism\"],\n    undead: [\"religion\"],\n};\nconst RANK_COLORS = [\"#443730\", \"#171f69\", \"#3c005e\", \"#5e4000\", \"#5e0000\"];\nconst RANK_NAMES = [\"UNTRAINED\", \"TRAINED\", \"EXPERT\", \"MASTER\", \"LEGENDARY\"];\nconst OUTCOMES = [\n    \"<span style='color:red'>CrFail</span>\",\n    \"<span style='color:orange'>Fail</span>\",\n    \"<span style='color:royalblue'>Suc</span>\",\n    \"<span style='color:green'>CrSuc</span>\",\n];\nconst DC_MODS = [-5, -2, 0, 2, 5, 10, \"-\", \"-\", \"-\"];\nconst FIRST_DC_INDEX = {\n    common: 2,\n    uncommon: 3,\n    rare: 4,\n    unique: 5,\n};\n\n// Get token skills infos by simulating fake rolls\n// ===============================================\n\nconst tokenSkills = {};\nconst loreSkills = [];\nconst appliedModifiers = [];\nfor (const skill in actor.skills) {\n    let fakeRoll;\n    const rank = actor.skills[skill].rank;\n    const rollOptions = [\n        ...actor.getRollOptions([\"all\", \"skill-check\"]),\n        \"action:recall-knowledge\",\n        `action:recall-knowledge:${skill}`,\n        \"skill-check\",\n        `skill:rank:${rank}`,\n    ];\n    if (game.user.targets.size === 1) {\n        const traits = game.user.targets.first().actor.traits;\n        traits.forEach(t => { rollOptions.push(`target:trait:${t}`) });\n    }\n\n    await actor.skills[skill].roll({\n        callback: (res) => {\n            fakeRoll = res;\n        },\n        createMessage: false,\n        skipDialog: true,\n        extraRollOptions: rollOptions,\n    });\n    const fakeRollDieResult = fakeRoll.dice[0].values[0];\n\n    // find conditional RK modifiers\n    const conditionalModifiers = [];\n    const coreSkill = actor.skills[skill];\n    const recallKnowledgeModifiers =\n        coreSkill?.modifiers.filter((mod) => mod.predicate.includes(\"action:recall-knowledge\")) ?? [];\n    for (const mod of recallKnowledgeModifiers) {\n        mod.predicate.test(rollOptions) ? appliedModifiers.push(mod.slug) : conditionalModifiers.push(mod);\n    }\n\n    if (coreSkill?.lore) loreSkills.push(skill);\n    tokenSkills[skill] = {\n        conditionalModifiers: conditionalModifiers,\n        label: coreSkill?.label ?? \"NO SKILL\",\n        modifier: fakeRoll.total - fakeRollDieResult,\n        rank,\n    };\n}\n\n// Global d20 roll used for all skills\n// ===================================\n\nconst globalRoll = (await new Roll(\"1d20\").roll({ async: true })).total;\nconst rollColor = globalRoll == 20 ? \"green\" : globalRoll == 1 ? \"red\" : \"royalblue\";\n\n// Skill list output\n// =================\n\nconst skillListOutput = (title, skills) => {\n    let output = `<table><tr><th>${title}</th><th>Prof</th><th>Mod</th><th>Result</th></tr>`;\n    for (const skill of skills) {\n        const { label, modifier, rank } = tokenSkills[skill];\n        const adjustedResult = globalRoll + modifier;\n        output += `<tr><th>${label}</th>\n            <td class=\"tags\"><div class=\"tag\" style=\"background-color: ${RANK_COLORS[rank]}; white-space:nowrap\">${\n            RANK_NAMES[rank]\n        }</td>\n            <td>${modifier >= 0 ? \"+\" : \"\"}${modifier}</td>\n            <td><span style=\"color: ${rollColor}\">${adjustedResult}</span></td></tr>`;\n    }\n    output += \"</table>\";\n    return output;\n};\n\n// Conditional modifier output\n// ==========================\n\nconst conditionalModifiersOutput = (skills) => {\n    // Find unique modifiers that are never successfully applied for any skill or lore to inform user\n    const allModifiers = skills.map((s) => tokenSkills[s].conditionalModifiers).flat();\n    const uniqModifiers = [...new Map(allModifiers.map((mod) => [mod.slug, mod])).values()];\n    const exclModifiers = uniqModifiers.filter((mod) => !appliedModifiers.includes(mod.slug));\n    if (exclModifiers.length === 0) return \"\";\n\n    let output = `<table style=\"font-size: 12px\"><tr><th>Potential Modifiers</th><th>Mod</th></tr>`;\n    for (const mod of exclModifiers) {\n        const { label, signedValue, source } = mod;\n        output += `<tr><td><a class=\"content-link\" draggable=\"true\" data-uuid=\"${source}\"><i class=\"fas fa-suitcase\"></i>${label}</a></td><td>${signedValue}</td></tr>`;\n    }\n    output += \"</table>\";\n    return output;\n};\n\n// Creating output\n// ===============\n\nlet output = `<strong>Recall Knowledge</strong> (Roll: <span style=\"color: ${rollColor}\">${globalRoll}</span>)`;\n\nif (game.user.targets.size < 1) {\n    // No target - roll all Recall Knowledge and lore skills\n\n    const allRKSkills = [...SKILL_OPTIONS, ...loreSkills];\n    output += skillListOutput(\"Skill\", allRKSkills);\n    output += conditionalModifiersOutput(allRKSkills);\n} else {\n    // Target - roll corresponding Recall Knowledge skills and lore skills\n\n    for (const target of game.user.targets) {\n        const targetActor = target.actor;\n        if (!targetActor?.isOfType(\"creature\", \"hazard\")) continue;\n\n        const level = targetActor.level;\n        const targetTraits = targetActor.traits;\n        const rarity = targetActor.rarity;\n\n        let levelDC;\n        if (level > 20) {\n            levelDC = level * 2;\n        } else {\n            levelDC = 14 + level + (level < 0 ? 0 : Math.floor(level / 3));\n        }\n\n        output += `<br/><strong>vs. ${targetActor.name}</strong>`;\n\n        // Primary skills\n\n        const dcIndex = FIRST_DC_INDEX[rarity];\n        const DCs = DC_MODS.slice(dcIndex, dcIndex + 4).map((dc) => (typeof dc === \"number\" ? dc + levelDC : \"-\"));\n\n        output += \"<table><tr><td></td><td></td><td>\";\n        output +=\n            \"<th style='text-align:center'>1st</th><th style='text-align:center'>2nd</th><th style='text-align:center'>3rd</th><th style='text-align:center'>4th</th></tr>\";\n        output += \"<tr><th>Skill</th><td></td><td></td>\";\n        DCs.forEach(\n            (dc) => (output += `<th style='text-align:center'>${typeof dc === \"number\" ? \"DC \" + dc : \"-\"}</th>`)\n        );\n        output += \"</tr>\";\n\n        let primarySkills = new Set();\n        for (const trait in IDENTIFY_SKILLS) {\n            if (targetTraits.has(trait)) {\n                for (const primarySkill of IDENTIFY_SKILLS[trait]) {\n                    primarySkills.add(primarySkill);\n                }\n            }\n        }\n\n        for (const skill of primarySkills) {\n            const { label, modifier, rank } = tokenSkills[skill];\n            const adjustedResult = globalRoll + modifier;\n\n            output += `<tr><th>${label}\n                </th><td class=\"tags\"><div class=\"tag\" style=\"background-color: ${RANK_COLORS[rank]}; white-space:nowrap\">${RANK_NAMES[rank]?.[0]}</td>\n                <td><span style=\"color: ${rollColor}; text-align: center\">${adjustedResult}</span></td>`;\n\n            for (const dc of DCs) {\n                if (typeof dc !== \"number\") {\n                    output += \"<td style='text-align:center'>-</td>\";\n                    continue;\n                }\n                const diff = adjustedResult - dc;\n                let success = diff >= 10 ? 3 : diff >= 0 ? 2 : diff <= -10 ? 0 : 1;\n                if (globalRoll == 20 && success < 3) success++;\n                else if (globalRoll == 1 && success > 0) success--;\n                output += `<td style=\"text-align:center; vertical-align:middle\">${OUTCOMES[success]}</td>`;\n            }\n            output += \"</tr>\";\n        }\n        output += \"</table>\";\n\n        // Lore skill DCs\n\n        const loreDCs = DC_MODS.slice(dcIndex - 2, dcIndex + 4).map((dc) =>\n            typeof dc === \"number\" ? dc + levelDC : \"-\"\n        );\n\n        output += \"<table><tr><th>Lore Skill DCs</th>\";\n        output += \"<th>1st</th><th>2nd</th><th>3rd</th><th>4th</th><th>5th</th><th>6th</th></tr>\";\n        output += \"<tr><th>Unspecific</th>\";\n        loreDCs.slice(1).forEach((dc) => (output += `<td style=\"text-align:center\">${dc}</td>`));\n        output += \"<td>-</td></tr><tr><th>Specific</th>\";\n        loreDCs.forEach((dc) => (output += `<td style=\"text-align:center\">${dc}</td>`));\n        output += \"</tr></table>\";\n\n        // Lore skills\n\n        output += skillListOutput(\"Lore Skill\", loreSkills);\n        output += conditionalModifiersOutput([...primarySkills, ...loreSkills]);\n        if (HAS_DUBIOUS_KNOWLEDGE) {\n            output += `<br>${token?.name ?? actor.name} has @UUID[Compendium.pf2e.feats-srd.Item.1Bt7uCW2WI4sM84P]{Dubious Knowledge}`\n        }\n    }\n}\n\n// Notification and chat card\n// ==========================\n\nui.notifications.info(`${token?.name ?? actor.name} tries to remember if they've heard something related to this.`);\nawait ChatMessage.create({\n    user: game.userId,\n    type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n    content: output,\n    whisper: game.users.contents.flatMap((user) => (user.isGM ? user.id : [])),\n    visible: false,\n    blind: true,\n    speaker: ChatMessage.getSpeaker(),\n    flags: { \"xdy-pf2e-workbench.minimumUserRole\": CONST.USER_ROLES.GAMEMASTER },\n});\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Recall_Knowledge.js\" - Fetched on 2024-06-05T17:22:21.777Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Recall_Knowledge","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"fWk5nq0Uww05pzle","actorIds":[],"author":"fC6gbSXQzxgTfTMY","command":"/*\nDemoralize\nThis macro will make an intimidation check vs the target.\n\n\nThis Macro works just like the system's Demoralize macro, except for the following additions:\n* Checks if the target is temporarily immune\n* Checks if the target is immune to any traits\n* Checks the 30ft range limit\n* Option to use Intimidating Glare or to select a language\n* Uses base system action with modified traits and predicates\n* Option to apply Frightened and Demoralize immunity\n* Support for Intimidating Glare-like abilities\n\noriginal implementation by darkium\nrework by kromko\n\n// jQuery handling was based on the example in Community wiki\n// https://foundryvtt.wiki/en/development/api/dialog#fruitpromptjs\n\n*/\n\n/**\n* Wrapper for the DSN Hook. If DSN is enabled, waits for the physical dice to stop rolling (unless the roll has assurance) \n*\n* @param {Promise<Object>} rollPromise Promise of roll results\n*/\nfunction dsnHook(rollPromise) {\n    if (game.modules.get(\"dice-so-nice\")?.active){\n        return rollPromise.then(async results=> {\n            await Promise.all(results.map(r=> {\n                // Check if we are using assurance\n                if (r.message.getFlag('pf2e', 'context.options').includes('substitute:assurance'))\n                    return Promise.resolve(true);\n                return game.dice3d.waitFor3DAnimationByMessageID(r.message.id);\n                }\n            ));\n            return results;\n        });\n    } else {\n        return rollPromise;\n    }\n}\n \nfunction isImmune(actor, trait){\n    return actor.system.attributes.immunities.some(i => i.type === trait);\n}\n\nif (canvas.tokens.controlled.length != 1){\n    return ui.notifications.warn('You need to select exactly one token to perform Demoralize.');\n}\n\n// Ignoring Reach for the Sky / Tut-Tu / Beast Dynamo Howl / Deimatic Display as they use a single check for all targets\nconst multitargetFeats = ['dazzling-display', 'frightening-appearance', 'terrifying-howl', 'flash-your-badge', 'terrible-transformation', 'menacing-prowess'];\nconst demoralizeMultitarget = _token.actor.items.find(item => multitargetFeats.includes(item.slug));\n\nif (game.user.targets.size == 0){\n    return ui.notifications.warn('You must target at least one token.');\n} \nelse if (game.user.targets.size > 1 && !demoralizeMultitarget){\n    return ui.notifications.warn('You don\\'t have an ability that lets you target more than one token, or the macro doesn\\'t recognize it');\n}\nconst actor = _token.actor;\nconst targets = game.user.targets;\n\nconst respectHiddenNames = game.settings.get(\"pf2e\", \"metagame_tokenSetsNameVisibility\");\nconst hideActorName = respectHiddenNames && !_token.document.playersCanSeeName;\nconst actorName = !hideActorName ? _token.name : 'Unknown';\n\nconst actorChatName = !hideActorName ? actorName : `Unknown <span data-visibility=\"gm\">(${_token.name})</span>`;\n\nconst likeIntimidatingGlare = ['intimidating-glare', 'dark-fields-kitsune', 'elemental-embellish', 'frilled-lizardfolk'];\nconst intimidatingGlare = _token.actor.items.find(item => likeIntimidatingGlare.includes(item.slug));\n\nconst likeVersatilePerformance = ['versatile-performance', 'fancy-moves'];\nconst versatilePerformance = _token.actor.items.find(item => likeVersatilePerformance.includes(item.slug));\n\nlet languages = actor.system.details.languages.value\n    .map(l => ({id:l, name:game.i18n.localize(`PF2E.Actor.Creature.Language.${l}`)}));\nlanguages.sort((a,b) => a.name.localeCompare(b.name));\n\nlet selectedMode = await new Promise(resolve => {\n    let content = `<form><table>`;\n    if(versatilePerformance){\n        content +=`\n        <tr><td><label for=\"usePerformance\">${versatilePerformance.name}</label></td>\n        <td><input type=\"checkbox\" name=\"usePerformance\" checked /></td></tr>`;\n    }\n    if(intimidatingGlare){\n        content +=`\n        <tr><td><label for=\"useGlare\">${intimidatingGlare.name}</label></td>\n        <td><input type=\"checkbox\" name=\"useGlare\" checked /></td></tr>`;\n    }\n    content += `<tr><td><label for=\"selectLanguage\">Select Language</label></td>\n          <td><select name=\"selectLanguage\" ${intimidatingGlare ? \"disabled\" : \"\"}>`;\n\n    for (let i = 0; i < languages.length; i++){\n      content += `\n      <option value=\"${languages[i].id}\" ${languages[i].id == 'common' ? ' selected' : ''}>${languages[i].name}</option>`\n    };\n\n    content += `\n          </select></td></tr></table>\n        </form>`;\n\n    const handleCheckbox = (event) => {\n        const targetElement = event.currentTarget;\n        const checked = targetElement.checked;\n        const formElement = $(targetElement).parents('form');\n\n        const selectLanguage = formElement?.find('[name=\"selectLanguage\"]');\n        selectLanguage.prop( \"disabled\", checked );\n    }\n    new Dialog({\n        title: `How would you like to demoralize your targets?`,\n        content: content,\n        buttons: {\n            Select: {\n                label: 'Boo!', \n                callback: (html) => {\n                    let skill = html.find('[name=\"usePerformance\"]')?.[0]?.checked ? 'performance' : 'intimidation';\n                    let result = html.find('[name=\"useGlare\"]')[0]?.checked ? \n                    ({mode:'visual', skill}) : ({mode:'auditory', skill, lang:html.find('[name=\"selectLanguage\"]').val(), });\n                    resolve(result)\n                    }\n                }\n            },\n            render: (html) => html.on('change', 'input[type=\"checkbox\"]', handleCheckbox),close: () => resolve(undefined)\n        }\n    ).render(true)\n});\n\nif(!selectedMode)\n    return ui.notifications.warn('Demoralize was interrupted');\n\nconst baseAction = game.pf2e.actions.get('demoralize');\n// prepare traits and modifiers\nlet actionOptions = {traits:baseAction.traits, modifiers:baseAction.modifiers, statistic: selectedMode.skill};\n;\nif(selectedMode.mode == 'visual'){\n    actionOptions.traits = [...actionOptions.traits.filter(t=> t!='auditory'), 'visual'];\n    actionOptions.modifiers = actionOptions.modifiers.filter(m=> !m.label.includes(\"Unintelligible\"));\n}\n\nlet rollResults = targets.map(target =>{\n    const hideTargetName = respectHiddenNames && !target.document.playersCanSeeName;\n    const targetName = !hideTargetName ? target.name : 'Unknown';\n    const targetChatName = !hideTargetName ? targetName : `Unknown <span data-visibility=\"gm\">(${target.name})</span>`;\n\n    let baseResult = {\n        targetTokenId: target.id,\n        targetName: targetName,\n        targetChatName: targetChatName\n    }\n\n    // check for demoralize cooldown\n    let cooldown = target.actor.itemTypes.effect.find(e=> e.slug === 'demoralize-immunity' && e.flags?.demoralize?.source === actor.id)\n    if(cooldown){\n        return new Promise(resolve => resolve({\n            ...baseResult,\n            outcome: 'invalid',\n            flavor: `${targetChatName}: Immune (${cooldown.system.remaining ?? 'temporary'})`\n        }));\n    }\n\n    // check for target distance\n    if(target.distanceTo(_token) > 30){\n        return new Promise(resolve => resolve({\n            ...baseResult,\n            outcome: 'invalid',\n            flavor: `${targetChatName}: Too far`\n        }));\n    }\n\n    // Check for trait immunity\n    let immunity = actionOptions.traits.find(trait => isImmune(target.actor, trait));\n    if(immunity){\n        return new Promise(resolve => resolve({\n            ...baseResult,\n            outcome: 'immune',\n            flavor: `${targetChatName}: Immune to <div class=\"tags\" style=\"display:inline;\"><div class=\"tag\">${game.i18n.localize(`PF2E.Trait${immunity[0].toUpperCase()+immunity.slice(1)}`)}</div></div>.`\n        }));\n    }\n\n    // We make a variant action.\n    let action;\n    if(selectedMode.mode == 'visual'){\n        action = baseAction.toActionVariant({\n            traits: actionOptions.traits,\n            modifiers: actionOptions.modifiers,\n            statistic: actionOptions.statistic\n        });\n        return dsnHook( action.use({actor: actor, target:target})).then(r=> ({\n            ...baseResult,\n            outcome:r?.[0].outcome,\n            flavor: `${targetChatName}: ${game.i18n.localize(`PF2E.Check.Result.Degree.Check.${r?.[0].outcome}`)}`\n        }));\n        \n    } else {\n        if (!target.actor.system.details.languages.value.includes(selectedMode.lang)){\n            action = baseAction.toActionVariant({\n                rollOptions: [...baseAction.rollOptions, 'action:demoralize:unintelligible'],\n                statistic: actionOptions.statistic\n            }); \n            return dsnHook( action.use({actor: actor, target:target})).then(r=> ({\n                ...baseResult,\n                outcome:r?.[0].outcome,\n                flavor: `${targetChatName}: ${game.i18n.localize(`PF2E.Check.Result.Degree.Check.${r?.[0].outcome}`)} (doesn't speak the language)`\n            }));\n        } else {\n            action = baseAction.toActionVariant({statistic: actionOptions.statistic});\n            return dsnHook( action.use({actor: actor, target:target})).then(r=> ({\n                ...baseResult,\n                outcome:r?.[0].outcome,\n                flavor: `${targetChatName}: ${game.i18n.localize(`PF2E.Check.Result.Degree.Check.${r?.[0].outcome}`)} (speaks the language)`\n            }));\n        }\n    }\n})\n\nrollResults = await Promise.all(rollResults);\n\nlet summary = '';\nif(rollResults.length == 1){\n    summary = selectedMode.mode === 'visual' ?\n        `${actorChatName} tries to demoralize ${rollResults[0].targetChatName} with ${intimidatingGlare.name}.` :\n        `${actorChatName} tries to demoralize ${rollResults[0].targetChatName} in ${languages.find(l=>l.id == selectedMode.lang).name}.`;\n    summary += `<hr>${rollResults[0].flavor.split(': ').pop()}`\n} else {\n    summary = selectedMode.mode === 'visual' ?\n    `${actorChatName} tries to demoralize targets with ${intimidatingGlare.name}.` :\n    `${actorChatName} tries to demoralize targets in ${languages.find(l=>l.id == selectedMode.lang).name}.`;\n    summary += '<hr>';\n    summary += rollResults.map(r=>r.flavor).join('<br>');\n}\nif (game.modules.get('xdy-pf2e-workbench')?.active) { \n    // Extract the Macro ID from the asynomous benefactor macro compendium.\n    const macroName = `Demoralize Immunity CD`;\n    const macroId = (await game.packs.get('xdy-pf2e-workbench.asymonous-benefactor-macros')).index.find(n => n.name === macroName)?._id;\n    summary += `<hr>@Compendium[xdy-pf2e-workbench.asymonous-benefactor-macros.${macroId}]{Click to apply effects and immunity}`;\n} else {\n    summary += `<hr>Workbench Module not active! Effects have to be applies manually.`;\n}\n\nChatMessage.create({\n    user: game.user.id,\n    type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n    content: summary,\n    speaker: ChatMessage.getSpeaker(),\n    flags: {demoralize:{\n        sourceTokenId:_token.id,\n        sourceName: actorName,\n        results: rollResults.map(r => ({\n            outcome:r.outcome, \n            targetTokenId:r.targetTokenId, \n            targetName:r.targetName\n        })),\n    }}\n});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Demoralize.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Demoralize","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"gFdVvLBOobc5SrlW","actorIds":[],"author":"wiDvReTRFa7gtjvd","command":"// After starting the encounter and rolling initiative, GM selects TOKENS who were avoiding notice\n// Macro automatically assigns visibility based on stealth initiative and perception DCs.\n// Find the person who is observing in the 1st column, then move across to see what they can see.\n// Once combat has started you can manually alter the visibility.\n// Click any visibility state to increase, and control click to decrease (observed, hidden, unnoticed, undetected)\n// Please change the variable 'colourScheme' to select which colours are displayed.\n// CURRENT LIMITATIONS: Eidolons & Animal Companions are not tracked as they dont appear in the combat tracker.\n// If run after the combat has started, dont select any tokens and just manually adjust visibility\n\nconst colourScheme = \"alternate\"; //Choices are standard, alternate, none. alternate MIGHT be colourblind compatible.\nconst visibility = [\"observed\", \"hidden\", \"undetected\", \"unnoticed\"]; // Change these if using non-English language\nconst notStartedError = `You must start the encounter first`; // Change this if using non-English language\n\nlet visColours = [\"\", \"\", \"\", \"\"];\nswitch (colourScheme) {\n    case \"alternate\":\n        visColours = [\"\", \"#ccbb44\", \"#66ccee\", \"#ee6677\"]; // Feel free to change these hexcodes to your preference\n        break;\n    case \"standard\":\n        visColours = [\"\", \"#ccbb44\", \"#228833\", \"#ee6677\"];\n}\n\nconst combatants = game.combat.combatants.contents.map(i => ({\n    actorId: i.actorId,\n    initiative: i.initiative,\n    isNPC: i.isNPC,\n    name: i.name,\n    perceptionDC: i.actor.perception.dc.value,\n    avoidingNotice: false\n}));\n\nconst tokens = canvas.tokens.controlled;\n\nif (combatants.length === 0) {\n    ui.notifications.error(notStartedError);\n} else {\n\n    let buttonId = 1;\n\n    for (let element of tokens) { //selected tokens are avoidingNotice\n        let thisPlayer = combatants.find(c => c.actorId == element.actor.id);\n        if (thisPlayer) { // Eidolons and Animal companions dont appear in the combat tracker.\n            thisPlayer.avoidingNotice = true;\n        }\n    }\n\n    let template = `\n      <head>\n      <style>\n      table, th, td {\n        border: 1px solid black;\n      }\n      </style>\n      </head>\n    `;\n\n    template = template + `\n    <script>\n      function changeVisibility (btn, visibilityStr, visColoursStr) {\n//this is awful. Had to pass in as strings instead of arrays. It works, but needs fixing\n        let visibility = visibilityStr.split(',');\n        let visColours = visColoursStr.split(',');\n        let label = document.getElementById(btn).innerHTML;\n        let currentVis = visibility.indexOf(label);\n        if (event.ctrlKey){\n            if (currentVis != 0) { \n                currentVis = currentVis - 1;\n            }\n        }\n        else {\n            if (currentVis != visibility.length-1) { \n                currentVis = currentVis + 1;\n            }\n        }\n        document.getElementById(btn).innerHTML = visibility[currentVis];\n        document.getElementById(btn).style.backgroundColor = visColours[currentVis];\n      }\n    </script>\n    `;\n\n    template = template + `<table>`;\n\n    //set up 1st row, which is empty then the names of the combatants in each subsequent column.\n    template = template + `<tr>`;\n    template = template + '<th> </th>' //empty first cell. Can this have a description of the columns/rows?\n    for (var i = 0; i < combatants.length; i++) {\n        template = template + '<th>' + combatants[i].name + '</th>';\n    }\n    template = template + '</tr>';\n\n\n    //go through each combatant one at a time, and do the stealth/perception comparisons\n    for (var j = 0; j < combatants.length; j++) {\n        template = template + '<tr>';\n        template = template + '<td>' + combatants[j].name + '</td>';\n        for (var k = 0; k < combatants.length; k++) {\n            if (j === k) {\n                template = template + '<td> </td>'; //combatant doesnt need to observe themself\n            } else if (combatants[k].avoidingNotice === true) {\n                if (combatants[k].initiative < combatants[j].perceptionDC) {\n                    template = addVisButton(template, 1, buttonId); //hidden                 \n                    buttonId = buttonId + 1;\n                } else {\n                    if (combatants[k].initiative > combatants[j].initiative) {\n                        template = addVisButton(template, 3, buttonId); //unnoticed\n                        buttonId = buttonId + 1;\n                    } else {\n                        template = addVisButton(template, 2, buttonId); //undetected\n                        buttonId = buttonId + 1;\n                    }\n                }\n            } else {\n                template = addVisButton(template, 0, buttonId); //observed\n                buttonId = buttonId + 1;\n            }\n        }\n        template = template + '</tr>';\n    }\n\n    template = template + '</table>';\n\n    new Dialog({\n        title: \"Relative Visibility\",\n        content: template,\n        buttons: {\n            cancel: {\n                label: \"Close\",\n            },\n        },\n    }, {\n        width: 'auto',\n        height: 'auto'\n    }).render(true);\n\n\n}\n\n\nfunction addVisButton(template, visState, buttonId) {\n    template = template + '<td><button style=\"background-color:';\n    template = template + visColours[visState] + ';\" id=';\n    template = template + buttonId + ' onclick=\"changeVisibility(this.id, \\'' + visibility + '\\', \\'' + visColours + '\\')\">' + visibility[visState] + '</button></td>';\n    return template;\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Avoid Notice.js\" - Fetched on 2024-06-05T17:22:21.774Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Avoid Notice","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"hrq1NFWQvSa0f3kM","actorIds":[],"author":"nU9k6PxTWvh6Q9cI","command":"/* Contributed by cepvep */\n\n// Displayed in this order.\nconst condition_list = {\n\t// condition name: display name\n\t\"blinded\": \"Blinded\",\n\t\"broken\": \"Broken\",\n\t\"clumsy\": \"Clumsy\",\n\t\"concealed\": \"Concealed\",\n\t\"confused\": \"Confused\",\n\t\"controlled\": \"Controlled\",\n\t\"dazzled\": \"Dazzled\",\n\t\"deafened\": \"Deafened\",\n\t\"doomed\": \"Doomed\",\n\t\"drained\": \"Drained\",\n\t\"dying\": \"Dying\",\n\t\"encumbered\": \"Encumbered\",\n\t\"enfeebled\": \"Enfeebled\",\n\t\"fascinated\": \"Fascinated\",\n\t\"fatigued\": \"Fatigued\",\n\t\"flat-footed\": \"Flat-Footed\",\n\t\"fleeing\": \"Fleeing\",\n\t// \"friendly\": \"Friendly\",\n\t\"frightened\": \"Frightened\",\n\t\"grabbed\": \"Grabbed\",\n\t//\"helpful\": \"Helpful\",\n\t\"hidden\": \"Hidden\",\n\t//\"hostile\": \"Hostile\",\n\t\"immobilized\": \"Immobilised\",\n\t// \"indifferent\": \"Indifferent\",\n\t\"invisible\": \"Invisible\",\n\t// \"observed\": \"Observed\",\n\t\"paralyzed\": \"Paralysed\",\n\t\"persistent-damage\": \"Persistent Damage\",\n\t\"petrified\": \"Petrified\",\n\t\"prone\": \"Prone\",\n\t\"quickened\": \"Quickened\",\n\t\"restrained\": \"Restrained\",\n\t\"sickened\": \"Sickened\",\n\t\"slowed\": \"Slowed\",\n\t\"stunned\": \"Stunned\",\n\t\"stupefied\": \"Stupefied\",\n\t\"unconscious\": \"Unconscious\",\n\t// \"undetected\": \"Undetected\",\n\t// \"unfriendly\": \"Unfriendly\",\n\t// \"unnoticed\": \"Unnoticed\",\n\t\"wounded\": \"Wounded\",\n\t// Add more options to your hearts content here.\n}\n\nconst options = Object.entries(condition_list)\n    .map(([conditionName, displayName]) => [`<option value=\"${conditionName}\">${displayName}</option>`])\n    .join()\n\nconst content = `<form>\n    <div class=\"form-group\">\n        <label>Condition:</label>\n        <select name=\"condition-selector\">${options}</select>\n    </div>\n</form>`\n\nnew Dialog({\n    title: \"Condition Selector\",\n    content,\n    buttons: {\n        ok: {\n            label: \"<span class='pf2-icon'>1</span> Add condition\",\n            callback: (html) => {\n                const condition = html.find(\"[name=condition-selector]\")[0].value;\n\tconsole.log(condition);\t\t\t\n                        token.actor.toggleCondition(condition);\n                }\n        },\n        cancel: {\n            label: \"<span class='pf2-icon'>R</span> Cancel\"\n        }\n    },\n    default: \"cancel\",\n}).render(true);\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Apply Conditions.js\" - Fetched on 2024-06-05T17:22:21.774Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Apply Conditions","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"iai3pBxKh593vUoH","actorIds":[],"author":"Xcp85PDaYXZY0kfm","command":"const Database = {\n  Actors: game.actors.size,\n  Items: game.items.size,\n  Messages: game.messages.size,\n  Scenes: game.scenes.size,\n  Journals: game.journal.size,\n  Tables: game.tables.size,\n};\nChatMessage.create({content: JSON.stringify(Database, null, 2) });\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/How Much Stuff.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT How Much Stuff","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"j4i5JobyJTFE10E3","actorIds":[],"author":"LKiFvSh1IZNvk9sG","command":"/*\nThis macro targets tokens within a template with some borrowed code from Idle's Toolbelt module.\n- Hover over template\n- Choose tokens' alliance to target\n- Tokens with the chosen alliance will be targeted\n*/\n\nif ( canvas.templates.hover === null ) { return ui.notifications.info(\"Please hover mouse over template before executing macro. Must be in Measurement Controls to do this\"); }\nconst template = canvas.templates.hover;\nconst hlId = template.highlightId;\nconst hL = canvas.grid.getHighlightLayer(hlId);\n\nconst toks = await Dialog.wait({\n    title:\"Tokens to select:\",\n    buttons: {\n        all: {\n            label: \"All\",\n            callback: () => { return FilterTargets(\"all\") },   \n        },\n        opp: {\n            label: \"Opposition\",\n            callback: () => { return FilterTargets(\"opposition\") },\n        },\n        nopp: {\n            label: `Opposition/Neutral`,\n            callback: () => { return FilterTargets(\"!party\") },\n        },\n        party: {\n            label: \"Party\",\n            callback: () => { return FilterTargets(\"party\") },\n        }\n    },\n    close: () => { return \"close\" }\n});\nif (toks === \"close\") { return }\nawait game.user.updateTokenTargets(toks);\n\nfunction FilterTargets (type) {\n    const ids = [];\n    let tokens = [];\n    if ( type === \"all\" ) {\n        tokens = canvas.tokens.placeables.filter( t => t.bounds.overlaps(template.bounds) );\n    }\n    else if ( type === \"!party\" ) {\n        tokens = canvas.tokens.placeables.filter( t => t.bounds.overlaps(template.bounds) && t.actor.alliance !== \"party\" );\n    }\n    else {\n        tokens = canvas.tokens.placeables.filter( t => t.bounds.overlaps(template.bounds) && t.actor.alliance === type );\n    }\n    for ( const tk of tokens ) {\n        const gs = canvas.grid.size;\n        const ds = canvas.dimensions.size;\n        const tpos = [];\n        for (let h = 0; h < tk.document.height; h++) {\n            const tx = Math.floor(tk.x / gs) * gs;\n            const ty = Math.floor(tk.y / gs) * gs;\n            const y = ty + h * gs;\n            tpos.push(`${tx}.${y}`);\n            if (tk.document.width > 1) {\n                for (let w = 1; w < tk.document.width; w++) {\n                    tpos.push(`${tx + w * gs}.${y}`)\n                }\n            }\n        }\n\n        for (const p of tpos) {\n            if (!hL.positions.has(p)) {\n                continue\n            }\n            const [gx, gy] = p.split('.').map(s => Number(s));\n            const destination = {\n                x: gx + ds * 0.5,\n                y: gy + ds * 0.5,\n            }\n            if (destination.x < 0 || destination.y < 0) continue;\n\n            if ( template.document.flags.pf2e?.origin?.traits.includes(\"auditory\") && !template.document.flags.pf2e?.origin?.traits.includes(\"visual\") && !CONFIG.Canvas.polygonBackends[\"sound\"].testCollision(template.center, destination,{type:\"sound\",mode:\"any\"})) {\n                ids.push(tk.id);\n                break;\n            }\n            else if ( template.document.flags.pf2e?.origin?.traits.includes(\"visual\") && template.document.flags.pf2e?.origin?.traits.includes(\"auditory\") && !CONFIG.Canvas.polygonBackends[\"sight\"].testCollision(template.center, destination,{type:\"sight\",mode:\"any\"}) && !CONFIG.Canvas.polygonBackends[\"sound\"].testCollision(template.center, destination,{type:\"sound\",mode:\"any\"})) {\n                ids.push(tk.id);\n                break;\n            }\n            else if ( template.document.flags.pf2e?.origin?.traits.includes(\"visual\") && !template.document.flags.pf2e?.origin?.traits.includes(\"auditory\") && !CONFIG.Canvas.polygonBackends[\"sight\"].testCollision(template.center, destination,{type:\"sight\",mode:\"any\"})) {\n                ids.push(tk.id);\n                break;\n            }\n            else  if ( !CONFIG.Canvas.polygonBackends[\"move\"].testCollision(template.center, destination,{type:\"move\",mode:\"any\"})) {\n                ids.push(tk.id);\n                break;\n            }\n        }\n    }\n    return ids;\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Target tokens within a template.js\" - Fetched on 2024-06-05T17:22:21.772Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Target tokens within a template","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"jdmwhdJpxumYrfaQ","actorIds":[],"author":"eVK1DKqan5RPNFOk","command":"/*\nOne for All\nMacro rolls diplomacy as a normal Aid action (DC 15). \nAdditionally, it checks if the character is a Wit Swashbuckler and the roll is sufficiently high to gain Panache.\n\nEverything that affects the Aid action (for example, 'action:aid' predicate) or Diplomacy check, should affect this macro.\n\nThe roll is considered Panache-granting if the character is a Wit Swashbuckler \n(+1 circumstance bonus if the character has Panache already)\n\nIt will also bump the crit success bonus to +3 if the actor has the Cooperative blade held in one hand.\n\nRespects Shift-clicking to skip roll dialog.\nAutomatically grants Panache.\n\nLimitations:\n* Always checks Aid DC 15\n* Does not bother with targeting the ally who is being aided, effect should\njust be dragged and dropped to that player\n*Ideally, Aid would also be an inline macro, and would automatically apply the correct bonus based\non the level of success. I would consider this a nice-to-have, but not necessary for the core function\n\n\noriginally created by chazpls\nrework by kromko\n*/\n\n\n/**\n* Wrapper for the DSN Hook. If DSN is enabled, waits for the physical dice to stop rolling (unless the roll has assurance) \n*\n* @param {Promise<Object>} rollPromise Promise of roll results\n*/\nfunction dsnHook(rollPromise) {\n  if (game.modules.get(\"dice-so-nice\")?.active) {\n    return rollPromise.then(async results => {\n      await Promise.all(results.map(r => {\n        // Check if we are using assurance\n        if (r.message.getFlag('pf2e', 'context.options').includes('substitute:assurance'))\n          return Promise.resolve(true);\n        return game.dice3d.waitFor3DAnimationByMessageID(r.message.id);\n      }\n      ));\n      return results;\n    });\n  } else {\n    return rollPromise;\n  }\n}\n\n\nif (!actor) {\n  return ui.notifications.warn(\"You must have an actor selected\");\n}\nconst oneForAll = token.actor.itemTypes.feat.find(f=>f.slug === 'one-for-all');\nif (!oneForAll) {\n  return ui.notifications.warn(\"Selected actor does not have the One for All feat\");\n}\n\nconst isWitSwashbuckler = actor.itemTypes.feat.some(f => f.slug === 'wit');\n\n//The cooperative blade item bumps the crit bonus to +3 on a critical success, even if you're not a master\nconst holdingCooperativeBlade = token.actor.items.some((item) => { return item.slug === 'cooperative-blade' && item.system.equipped.handsHeld === 1 })\n\n\n//sets the various crit bonuses for Aid, referenced in the chat output later\nif (token.actor.system.skills.dip.rank === 2 && holdingCooperativeBlade) {\n  critAidBonus = 3\n} else if (token.actor.system.skills.dip.rank < 3) {\n  critAidBonus = 2\n} else {\n  critAidBonus = token.actor.system.skills.dip.rank\n}\n\nlet rollResult = await dsnHook(game.pf2e.actions.get('aid')\n  .use({\n    event,\n    rollOptions: isWitSwashbuckler ? ['grants-panache'] : null,\n    notes: holdingCooperativeBlade ?\n      [{\n        outcome: ['criticalSuccess'],\n        title: 'Holding Cooperative Blade',\n        text: 'You grant your ally a +3 circumstance bonus to the triggering check instead of a +2 bonus.'\n      }] : null,\n      statistic: 'diplomacy'\n  })).then(r => r[0]);\n\nconst actorName = actor.name;\nconst targetName = game.user.targets.first()?.name ?? 'their ally';\n\nlet message = `<em>${actorName}</em> grants <em>${targetName}</em> `\n\nif (rollResult.outcome === 'criticalFailure') {\n  message += '<strong>-1</strong> circumstance penalty to the triggering check @UUID[Compendium.pf2e.other-effects.AHMUpMbaVkZ5A1KX].';\n}\nelse if (rollResult.outcome === 'failure') {\n  message += '<strong>no</strong> bonus to the triggering check.'\n}\nelse {\n  message += `<strong>+${rollResult.outcome === 'criticalSuccess' ? critAidBonus : 1}</strong> circumstance bonus to the triggering check @UUID[Compendium.pf2e.other-effects.AHMUpMbaVkZ5A1KX].`\n}\n\n// Check if viable for panache gain\nif (isWitSwashbuckler) {\n  const DCbyLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50];\n  const hardDC = DCbyLevel[token.actor.system.details.level.value] + 5;\n\n  if (rollResult.roll.total >= hardDC) {\n    message += `<br><em>${actorName}</em> gets @UUID[Compendium.pf2e.feat-effects.Item.uBJsxCzNhje8m8jj].`;\n\n    // Ownership should always be true, but just in case\n    // We also check if there is a panache already, just to avoid duplicates\n    if (actor.isOwner && !actor.itemTypes.effect.some(e=>e.slug ==='effect-panache')){\n      let panache = await fromUuid('Compendium.pf2e.feat-effects.Item.uBJsxCzNhje8m8jj');\n      await actor.createEmbeddedDocuments(\"Item\", [panache]);\n    }\n  }\n}\n\nChatMessage.create({\n  user: game.user.id,\n  type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n  content: `<strong>${oneForAll.name}</strong><hr /><p>${message}</p>`,\n  speaker: ChatMessage.getSpeaker(),\n});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/One_for_All.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT One_for_All","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"kErdNmeu12IpIwVx","actorIds":[],"author":"MlafW30gksy0OsOn","command":"//Contributed by LebombJames\n//This macro lets you quickly apply damage to many tokens after rolling reflex saves, for use with an AoE spell for example.\n\nfunction main() {\n    if (!game.user.isGM) {\n        ui.notifications.warn(\"You must be a GM in order to run this macro\");\n        return;\n    };\n    if (canvas.tokens.controlled.length < 1) {\n        ui.notifications.warn(\"Please select at least 1 token.\");\n        return;\n    };\n\n    const tokens = canvas.tokens.controlled;\n    let applyChanges = false;\n    let tokenCount = 0;\n\n    let content = `\n    <form>\n        <body>Select the result of each token's saving throw. You can also add a modifier to account for things like resistances or weaknesses.</body>\n        <div class=\"form-group\">\n            <label for=\"damage\">Damage</label>\n            <input type=\"number\" id=\"damage\" name=\"damage\" placeholder=0>\n        </div>\n        <hr>\n    `;\n\n    for (const token of tokens) {\n        content += `<div class=\"form-group\">\n            <label for=\"${tokenCount}-result\" style=\"min-width:100%;padding-right:7px\">${token.name}</label>\n            <select name=\"${tokenCount}-result\" id=\"${tokenCount}-result\">\n                <option value=\"no-damage\">No Damage</option>\n                <option value=\"half-damage\">Half Damage</option>\n                <option value=\"full-damage\">Full Damage</option>\n                <option value=\"double-damage\">Double Damage</option>\n            </select>\n            <label for=${tokenCount}-modifier style=\"text-align:right;padding-right:7px;\">Modifier</label>\n            <input type=\"number\" id=\"${tokenCount}-modifier\" name=\"${tokenCount}-modifier\" placeholder=0>\n        </div>\n        <hr>\n       `;\n\n        tokenCount += 1;\n    };\n\n    content += `</form>`;\n\n    function callback(html) {\n        const damage = parseInt(html.find(`[id=\"damage\"]`)[0].value);\n\n        tokens.forEach( (currentValue, index) => {\n            const token = tokens[index];\n            \n            const result = html.find(`[id=\"${index}-result\"]`)[0].options.selectedIndex;\n            const modifier = parseInt(html.find(`[id=\"${index}-modifier\"]`)[0].value) || 0;\n\n            switch (result) {\n                case 0: //no damage\n                    ui.notifications.info(`Applied no damage to ${currentValue.name}.`);\n                    break;\n                case 1: // half damage\n                    token.actor.applyDamage(((damage/2)+modifier), token);\n                    break;\n                case 2: // full damage\n                    token.actor.applyDamage(((damage)+modifier), token);\n                    break;\n                case 3: // double damage\n                    token.actor.applyDamage(((damage*2)+modifier), token);\n                    break;\n            };\n        }\n    )};\n\n    new Dialog({\n        title: \"Basic Save Resolver\",\n        content: content,\n        buttons: {\n            yes: {\n                icon: \"<i class='fas fa-check'></i>\",\n                label: `Apply Damage`,\n                callback: () => applyChanges = true\n            },\n        },\n        close: async html => {\n            if (!applyChanges) return;\n            callback(html);\n        }\n    }).render(true);\n};\nmain();\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Basic Save Resolver.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Basic Save Resolver","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"kxesBKjj344OaLas","actorIds":[],"author":"cJsL3ng5ZypcpAZc","command":"//This macro allows you to send scrolls and wands directly to chat as if you had clicked on them in your character sheet.\n//Also handles overcharging.\n\nnew Dialog({\n  title: \"Wand or Scroll?\",\n  buttons: {\n   w: {\n    label: \"Wand\",\n    callback: Wand,\n   },\n   s: {\n    label: \"Scroll\",\n    callback: Scroll,\n   },\n  },\n  default: \"s\",\n}).render(true);\n\nlet title;\n\nasync function Scroll() {  \n \n  title = `Cast a Scroll`\n \n  const scroll = actor.itemTypes.consumable.filter(s => s.system.category === \"scroll\" && s.isIdentified);\n  scroll.sort((a, b) => {\n    if (a.level === b.level)\n      return a.name\n      .toUpperCase()\n      .localeCompare(b.name.toUpperCase(), undefined, {\n        sensitivity: \"base\",\n      });\n    return a.level - b.level;\n  });\n \n  if (scroll.length === 0) { return ui.notifications.warn(\"You do don't have scrolls to cast from.\");}\n  const choiceS = await choose(scroll.flatMap(n => [[n.uuid, n.name]]),`Pick a Scroll`);\n  const chosen = scroll.find(x => x.uuid === choiceS);\n  await chosen.consume();\n}\n \nasync function Wand(){\n  let overcharge = false;\n  if (actor.itemTypes.consumable.some(s => s.system.category === \"wand\" && s.isIdentified && s.system.uses?.value === 0 && !actor.itemTypes.effect.some(e => e.slug === s.uuid))) {\n    overcharge = await Dialog.confirm({\n      title: \"Overcharge a wand?\",\n      yes: () => { return true },\n      no: () => { return false },\n      defaultYes: false\n    })\n  }\n  \n  title = `Cast a Wand`\n  let wand = [];\n  if (!overcharge) {\n    wand = actor.itemTypes.consumable.filter(s => s.system.category === \"wand\" && s.isIdentified && s.system.uses?.value > 0);\n    if (wand.length === 0) { return ui.notifications.warn(\"You do don't have wands to cast from.\");}\n  }\n  else {\n    wand = actor.itemTypes.consumable.filter(s => s.system.category === \"wand\" && s.isIdentified && s.system.uses?.value === 0 && !actor.itemTypes.effect.some(e => e.slug === s.uuid));\n    if (wand.length === 0) { return ui.notifications.warn(\"You do don't have wands to overcharge.\");}\n  }\n  wand.sort((a, b) => {\n    if (a.level === b.level)\n      return a.name\n      .toUpperCase()\n      .localeCompare(b.name.toUpperCase(), undefined, {\n        sensitivity: \"base\",\n      });\n    return a.level - b.level;\n  });\n  \n  const choiceW = await choose(wand.flatMap(n => [[n.uuid, n.name]]),`Pick a Wand`);\n  const chosen = await wand.find(x => x.uuid === choiceW);\n  const quantity = chosen.quantity;\n  if (chosen.quantity === 0 && actor.system.resources.heroPoints.value === 0) { return ui.notifications.warn(\"You have no hero points left\"); }\n  let fail = `${chosen.name} has been destroyed and the quantity has been reduced to zero in case you would like to try using a hero point on the flat check.<br><strong>Please remove the destroyed wand from your inventory or reuse the macro for proper reroll automation.</strong>`;\n  let success = `${chosen.name} is @UUID[Compendium.pf2e.conditionitems.Item.6dNUvdb1dhToNDj3] and needs to be repaired. If anyone tries to overcharge a wand when it's already been overcharged that day, the wand is automatically destroyed (even if it had been repaired) and no spell is cast.`;\n  if ( quantity === 0 && actor.system.resources.heroPoints.value > 0 ) {\n    fail = `Rerolled Flat Check and hero point deducted.<br>${chosen.name} has been destroyed and the quantity has been reduced to zero in case you would like to try using a hero point on the flat check.<br><strong>Please remove the destroyed wand from your inventory.</strong>`;\n    success = `Rerolled Flat Check and hero point deducted.<br>${chosen.name} is @UUID[Compendium.pf2e.conditionitems.Item.6dNUvdb1dhToNDj3] and needs to be repaired. If anyone tries to overcharge a wand when it's already been overcharged that day, the wand is automatically destroyed (even if it had been repaired) and no spell is cast.`;\n  }\n  if (quantity > 1) { return ui.notifications.warn(\"Stacked wands are not compatible with this macro.\") }\n  if (overcharge) {\n    const notes = [\n      {\"outcome\":[\"success\",\"criticalSuccess\"], \"selector\":\"flat-check\", \"text\":success},\n      {\"outcome\":[\"failure\",\"criticalFailure\"], \"selector\":\"flat-check\", \"text\":fail}\n    ];\n    const roll = await game.pf2e.Check.roll(new game.pf2e.StatisticModifier(`Attempting to overcharge ${chosen.name}`, []), {actor, options:[\"flat-check\"], type: 'flat-check', dc: { value: 10 }, notes});\n    if (roll.options.degreeOfSuccess > 1) {\n      const effect = {\n        \"name\": `${chosen.name} is Broken and Overcharged`,\n        \"type\": \"effect\",\n        \"img\": \"systems/pf2e/icons/conditions/broken.webp\",\n        \"system\": {\n          \"description\": {\n            \"value\":`${chosen.name} is broken and needs to be repaired. If anyone tries to overcharge a wand when it's already been overcharged that day, the wand is automatically destroyed (even if it had been repaired) and no spell is cast.`\n          },\n          \"slug\": chosen.uuid,\n          \"level\": {\n            \"value\": chosen.level\n          },\n          \"duration\": {\n            \"value\": -1,\n            \"unit\": \"unlimited\",\n            \"sustained\": false,\n            \"expiry\":\"turn-start\"\n          },\n          \"tokenIcon\": {\n            \"show\": false\n          }\n        },\n      };\n      await actor.createEmbeddedDocuments(\"Item\", [effect]);\n      if ( quantity === 0 ) { await chosen.update({\"system.quantity\": 1}); }\n    }\n    else {\n        await chosen.update({\"system.quantity\": 0});\n    }\n    if ( quantity === 0) {\n        await actor.update({\"system.resources.heroPoints.value\": actor.system.resources.heroPoints.value-1});\n    }\n  }\n  await chosen.consume();\n}\n\nasync function choose(options = [], prompt = ``){\n  return new Promise((resolve) => {\n    let dialog_options = (options[0] instanceof Array)\n      ? options.map(o => `<option value=\"${o[0]}\">${o[1]}</option>`).join(``)\n      : options.map(o => `<option value=\"${o}\">${o}</option>`).join(``);\n    let content = `\n      <table style=\"width=100%\">\n        <tr><th>${prompt}</th></tr>\n        <tr><td><select id=\"choice\">${dialog_options}</select></td></tr>\n      </table>`;\n   \n    new Dialog({\n      content, title, \n      buttons : { OK : {label : `${title}`, callback : async (html) => { resolve(html.find('#choice').val()); } } },\n      default: 'OK',\n    }).render(true);\n  });\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Use Scroll or Wand.js\" - Fetched on 2024-06-05T17:22:21.772Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Use Scroll or Wand","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"q8iXqssTefDohIgM","actorIds":[],"author":"rZIW8lYyrhIBPtqa","command":"/* Original Author: ArthurTrumpet Modded by Symon S.\n This Macro gives you an easy way to add new named cooldown effects to actors.\n Enter your desired duration in either a numerical value or a roll, like 1d4(default).\n Choose your unit type from the drop down menu. I added minutes, hours, and days for things like abilities with hourly cooldowns, spells with 1 minute durations, and afflictions that do things in x days.\n*/\n\nconst effect = {\n    type: 'effect',\n    name: 'Countdown',\n    img: 'systems/pf2e/icons/spells/time-beacon.webp',\n    system: {\n      tokenIcon: {\n          show: true\n      },       \n      duration: {\n          value: 1,\n          unit: 'rounds',\n          sustained: false,\n          expiry: 'turn-start'\n      }\n    },\n  };\n\ncountdownEffect();\n\nfunction countdownEffect() {\n  const unitsn = [{value: \"rounds\", name: \"Rounds\"},{value: \"minutes\", name: \"Minutes\"}, {value: \"hours\", name: \"Hours\"}, {value: \"days\", name: \"Days\"}];\n  let units = '';\n  unitsn.forEach(u => { units += `<option value=\"${u.value}\">${u.name}</option>`; });\n  let template = `\n  <p>\n    Duration: <input id=\"countdowninput\" type=\"string\" style=\"width: 50px;\" value=\"1d4\">\n  </p>\n  <p>\n    Units: <select id=\"countdownunits\">${units}</select>\n  </p>\n  <p>\n    Name: <input id=\"countdownname\" type=\"string\" style=\"width: 100px;\" value=\"Countdown\">\n  </p> \n  <p>\n    <input type=\"checkbox\" id=\"cooldown\"/>\n    Cooldown (adds 1 to duration)\n  </p>\n  <p>\n    <input type=\"checkbox\" id=\"visible\"/>\n    Only Visible to GM\n  </p>\n  `;\n\n  new Dialog({\n    title: \"Countdown Effect\",\n    content: template,\n    buttons: {\n      ok: {\n        label: \"Apply\",\n        callback: (html) => {\n          main(html);\n        },\n      },\n      cancel: {\n        label: \"Cancel\",\n      },\n    },\n  }).render(true);\n}\n\nasync function main(html) {\n    let duration = html.find(\"#countdowninput\")[0].value;\n    const unit = html.find(\"#countdownunits\")[0].value;  \n    const isCooldown = html.find(\"#cooldown\")[0].checked; \n    effect.name = html.find(\"#countdownname\")[0].value;\n    effect.system.unidentified = html.find(\"#visible\")[0].checked;\n    let countdownNumber = \"\";\n    if (duration.includes(\"d\")) {\n        countdownNumber = new Roll(duration).roll({ async : false }).total;\n    } else {\n        countdownNumber = duration;\n    }\n    if (isCooldown) {countdownNumber = parseInt(countdownNumber) +1};\n    \n    effect.system.duration.unit = unit;\n    effect.system.duration.value = countdownNumber;\n    await token.actor.createEmbeddedDocuments(\"Item\", [effect]);\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Modded Countdown Cooldown.js\" - Fetched on 2024-06-05T17:22:21.771Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Modded Countdown Cooldown","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"r2tlbMbHwL5FlTag","actorIds":[],"author":"dwxNry3eL9VTQnSm","command":"/*\nContributed by ArthurTrumpet\nUses the built in Battle medicine immunity effect to track who has healed whom.\nGM selects the token being healed, and chooses the healer from the drop down.\nThe effect icon won't appear on the token, as you can potentially be battle medicined several times, and it would just clutter up the token. \nIf you want to show the icons, update the variable showIcons on line #2 to true.\nImmunity duration is set depending on several factors. Default is 24 hours. \nIf healed by an Investigator with the Forensic Medicine methodology, it is 1 hour. \nA character with godless healing feat will get a 1 hour immunity.\nA character with the Medic dedication can heal someone who is immune. \nThe macro will set an effect on the medic to indicate if they have used this ability (or whether it is not currently available). \nThe duration is automatically set depending on the Medicine skill level of the medic.\nTo remove an effect, right click it in the effect tracker (top right of the screen) as per normal\n*/\n\nconst bm_UUID = 'Compendium.pf2e.feat-effects.2XEYQNZTCGpdkyR6'; //Battle medicine Immunity effect\nconst showIcons = false;\n\nif (!token) {\n    ui.notifications.error(\"No token selected!\");\n} else {\n    battlemedicineEffect();\n}\n\nfunction CheckFeat(slug, healer) {\n    if (healer.items.find((i) => i.slug === slug && i.type === 'feat')) {\n        return true;\n    }\n    return false;\n}\n\nfunction battlemedicineEffect() {\n\n    let playersNames = canvas.tokens.placeables.filter(pc => pc.actor.hasPlayerOwner && pc.actor.type === \"character\" && pc.actor.itemTypes.feat.some(x => x.slug === 'battle-medicine')).map(pc => pc.actor.name);\n    let playerNameList = '';\n    playersNames.map((el) => {\n        playerNameList += `<option value=\"${el}\">${el}</option>`;\n    });\n\n    let template = `\n  <p>Character performing Battle Medicine: <select id=\"playerName\">${playerNameList}</select></p> \n  `;\n\n    new Dialog({\n        title: \"Battle Medicine Tracking\",\n        content: template,\n        buttons: {\n            ok: {\n                label: \"Apply\",\n                callback: (html) => {\n                    main(html);\n                },\n            },\n            cancel: {\n                label: \"Cancel\",\n            },\n        },\n    }).render(true);\n}\n\nasync function main(html) {\n    const bmEffect = (await fromUuid(bm_UUID)).toObject();\n    bmEffect.system.tokenIcon.show = showIcons; //Potential for lots of effects to be on a token. Don't show icon to avoid clutter\n    bmEffect.flags.core ??= {};\n    bmEffect.flags.core.sourceId = bm_UUID;\n\n    const applicator = game.actors.getName(html.find(\"#playerName\")[0].value);\n    bmEffect.name = \"BM by \" + applicator.name;\n//it was here\n    const isMedic = CheckFeat('medic-dedication', applicator);\n    const isgodless = CheckFeat('godless-healing', token.actor); //godless healing affects the patient, not the healer\n    const isForensic = CheckFeat('forensic-medicine-methodology', applicator);\n    // check if the person being healed is currently immune. If so, check if healer is a medic\n    var isImmune = token.actor.itemTypes.effect.find(obj => {\n        return obj.name === bmEffect.name\n    })\n\n    if (isImmune) {\n        if (isMedic) {\n            var medicCooldown = applicator.itemTypes.effect.find(obj => {\n                return obj.name === \"Medic dedication used\"\n            })\nconsole.log(\"Starting\");\n            if (medicCooldown) {\n                ui.notifications.warn(actor.name + \" is currently immune to Battle Medicine by \" + applicator.name);\n                return;\n            } else {\n                if (applicator.skills.medicine.rank > 2) {\n                    bmEffect.data.duration.unit = \"hours\"; //Cooldown of Medic Dedication depends on medicine skill rank\n                }\n                bmEffect.name = \"Medic dedication used\";\nbmEffect.img = \"Icons/first-aid-kit.svg\";\n                await applicator.createEmbeddedDocuments(\"Item\", [bmEffect]);\n                ui.notifications.info(applicator.name + \" has now used their Medic Dedication to Battle Medicine \" + actor.name);\n                return;\n            }\n        } else {\n            ui.notifications.warn(actor.name + \" is currently immune to Battle Medicine by \" + applicator.name);\n            return;\n        }\n    }\n\n    if (isForensic || isgodless) {\n        bmEffect.data.duration.unit = \"hours\";\n    }\n    bmEffect.img = applicator.img;\n    await token.actor.createEmbeddedDocuments(\"Item\", [bmEffect]);\n    ui.notifications.info(token.actor.name + \" is now immune to Battle Medicine by \" + applicator.name);\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/BattleMedicineImmunity.js\" - Fetched on 2024-06-05T17:22:21.775Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT BattleMedicineImmunity","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"s1MyehnQ4Cq6zEmp","actorIds":[],"author":"NuBWj5mPEJVhVIKs","command":"/*\nOriginally contributed by Mother of God.\nUpdated and maintained by darkim.\nThis Macro works just like the system's Treat Wounds macro, except for the following additions:\n- Adds Battle Medicine integration\n- Checks for targets and immunities of targets\n- Provides option for applying the immunity effect to the healed target\n- Adds the ability to roll with assurance\n- Shows the assurance roll result during option selection\n- Adds automated godless healing integration\n- Adds Forensic Medicine integration\n- Shows the Medic Dedication healing bonus during option selection\n- Shows tooltips for many of the options during option selection\n- Removes any skill that is not applicable if you have Chirurgeon and/or Natural Medicine (if you don't have medicine trained)\n- Fires off a warning notification if Medicine is not trained and you do not possess a feat/feature that allows you to roll a different skill.\n- Adds the ability to use the macro with clever improviser.\n- Checks if the Healer is having healer's tools in the inventory.\n- Provide information to the user that Expanded Healer's Tools have to be held with 2h to gain it's bonus.\n- Supports the Spell Stitcher feat from Magus+.\n*/\n\n/**\n * Check wether the current actor has a feature.\n *\n * @param {string} slug\n * @returns {boolean} true if the feature exists, false otherwise\n */\n const checkFeat = (slug) =>\n token.actor.items\n   .filter((item) => item.type === 'feat')\n   .some((item) => item.slug === slug);\n\n/**\n* Check if any itemType feat of the actor matches a slug (and optionally a name)\n*\n* @param {string} slug Slug of the feature to search\n* @param {string} name Optional name of the feature\n* @returns {boolean} true if the actor has a matching item feat\n*/\nconst checkItemTypeFeat = (slug, name) =>\n token.actor.itemTypes.feat.some(\n   (feat) => feat.slug === slug && (!name || feat.name === name)\n );\n\n/**\n* Check if any itemType equipment of the actor matches a slug (and optionally checks in how many hands it is held)\n*\n* @param {string} slug Slug of the equipment to search\n* @param {int} hands Number of hands the item shall be held\n* @returns {boolean} true if the actor has a matching item equipment\n*/\nconst checkItemPresent = (slug, hands) =>\ntoken.actor.itemTypes.equipment.some(\n (equipment) => equipment.slug === slug && (!hands || equipment.handsHeld === hands)\n);\n\n/**\n* Wrapper for the DSN Hook. It will only use the hook if the non-buggy setting is not enabled.\n*\n* @param {Object} code code which will be executed\n*/\nfunction dsnHook(code) {\n  if (game.modules.get(\"dice-so-nice\")?.active && !game.settings.get(\"dice-so-nice\", \"immediatelyDisplayChatMessages\") && game.user.getFlag(\"dice-so-nice\", \"settings.enabled\") &&\n    !game.modules.get(\"df-manual-rolls\")?.active) {\n    Hooks.once('diceSoNiceRollComplete', code);\n  } else {\n    code();\n  }\n}\n\n/**\n* Get the available roll options\n*\n* @param {Object} options\n* @param {boolean} options.isRiskySurgery Is this a risky surgery?\n* @returns {string[]} All available roll options\n*/\nconst getRollOptions = ({ isRiskySurgery } = {}) => [\n ...token.actor.getRollOptions(['all', 'skill-check', 'medicine']),\n 'action:treat-wounds',\n // This conditionally adds some elements to the available options\n // If there are more cases like this, it might be good to rewrite this with\n // if(...){....push(...)}\n ...(isRiskySurgery ? ['risky-surgery'] : []),\n];\n\n/* Get DamageRoll */\nconst DamageRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"DamageRoll\"));\nconst CheckRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"CheckRoll\"));\n\n/**\n* Get the formula for healing and the success label\n*\n* @param {Object} options\n* @param {0|1|2|3} options.success Level of success\n* @param {boolean} options.useMagicHands Actor uses the feat magic-hands\n* @param {boolean} options.useMortalHealing Actor uses the feat mortal healing\n* @param {boolean} options.isRiskySurgery Actor uses the feat risky surgery \n* @param {string} options.bonusString Bonus String for this throw\n* @param {number} options.spellStitcherBonus Extra healing received from Spell Stitcher (Magus+)\n* @returns {{healFormula: string, successLabel: string}} Dice heal formula and success label\n*/\nconst getHealSuccess = ({\n success,\n useMagicHands,\n useMortalHealing,\n isRiskySurgery,\n bonusString,\n spellStitcherBonus,\n}) => {\n let healFormula;\n let successLabel;\n switch (success) {\n   case 0:\n     healFormula = '1d8';\n     successLabel = 'Critical Failure';\n     break;\n   case 1:\n     successLabel = 'Failure';\n     break;\n   case 2:\n     if (isRiskySurgery) {\n       healFormula = useMagicHands ? `4d10${bonusString}` : `4d8${bonusString}`;\n       successLabel = 'Success with risky surgery';\n     } else if (useMortalHealing) {\n       // Mortal Healing (can't have a deity) + Magic Hands (must have a deity) is not possible.\n       healFormula = `4d8${bonusString}`;\n       successLabel = 'Success with mortal healing';\n     } else {\n       healFormula = useMagicHands ? `2d10${bonusString}` : `2d8${bonusString}`;\n       successLabel = 'Success';\n     }\n     if (spellStitcherBonus > 0) {\n       healFormula += `+${spellStitcherBonus}`;\n     }\n     break;\n   case 3:\n     healFormula = useMagicHands ? `4d10${bonusString}` : `4d8${bonusString}`;\n     if (spellStitcherBonus > 0) {\n       healFormula += `+${2 * spellStitcherBonus}`;\n     }\n     successLabel = 'Critical Success';\n     break;\n   default:\n     ui.notifications.warn(`Success value of ${success} is not defined.`);\n }\n return {\n   healFormula,\n   successLabel,\n };\n};\n\n/**\n* Perform a roll on treating wounds\n*\n* @param {Object} options\n* @param {number} options.DC\n* @param {number} options.bonus Bonus on this roll\n* @param {number} options.med Medical skill\n* @param {boolean} options.isRiskySurgery Is a risky surgery\n* @param {boolean} options.useMortalHealing Uses mortal healing\n* @param {boolean} options.assurance Has assurance\n* @param {number} options.bmtw bmtw\n* @param {Object} options.target current target\n* @param {Object} options.immunityEffect the immunity effect  \n* @param {string} options.immunityMacroLink the immunity Macro Link\n* @param {number} options.spellStitcherBonus The bonus healing received from Spell Stitcher (Magus+)\n*/\nconst rollTreatWounds = async ({\n DC,\n bonus,\n med,\n isRiskySurgery,\n useMortalHealing,\n useMagicHands,\n assurance,\n bmtw,\n target,\n immunityEffect,\n immunityMacroLink,\n usedBattleMedicsBaton,\n spellStitcherBonus,\n}) => {\n const dc = {\n   value: DC,\n   visibility: 'all',\n };\n if (isRiskySurgery || useMortalHealing) {\n   dc.modifiers = {\n     success: 'one-degree-better',\n   };\n }\n const bonusString = bonus > 0 ? ` + ${bonus}` : '';\n const immunityMessage = `<strong>${target.name}</strong> is now immune to ${immunityEffect.name} for ${immunityEffect.system.duration.value} ${immunityEffect.system.duration.unit}.<br>${immunityMacroLink}`;\n\n  if (assurance) {\n    const aroll = await new CheckRoll(\n      `10 + ${med.modifiers.find((m) => m.type === 'proficiency').modifier}`\n    ).roll({ async: true });\n    ChatMessage.create({\n      user: game.user.id,\n      type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n      flavor: `<strong>Assurance Roll: ${\n        med.label[0].toUpperCase() + med.label.substring(1)\n      }</strong> vs DC ${DC}<br><small>Do not apply any other bonuses, penalties, or modifiers</small><br>`,\n      roll: aroll,\n      speaker: ChatMessage.getSpeaker(),\n    });\n\n    const atot = aroll.total - DC;\n\n    const success = atot >= 10 ? 3 : atot >= 0 ? 2 : atot <= -10 ? 0 : 1;\n\n    const { healFormula, successLabel } = getHealSuccess({\n      success,\n      useMagicHands,\n      useMortalHealing,\n      isRiskySurgery,\n      bonusString,\n      spellStitcherBonus,\n    });\n\n    if (isRiskySurgery) {\n      ChatMessage.create({\n        user: game.user.id,\n        type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n        flavor: `<strong>Damage Roll: Risky Surgery</strong>`,\n        roll: await new DamageRoll('{1d8}[slashing]').roll({ async: true }),\n        speaker: ChatMessage.getSpeaker(),\n      });\n    }\n    let healRoll = 0;\n    if (healFormula !== undefined) {\n      const rollType = success > 1 ? 'Healing' : 'Damage';\n      healRoll = await new DamageRoll(`(${healFormula})[${rollType.toLowerCase()}]`).roll({\n        async: true,\n      });\n      my_message = `<strong>${rollType} Roll: ${bmtw}</strong> (${successLabel})`;\n\n      healRoll.toMessage({\n        flavor: `${my_message}<br>${immunityMessage}`,\n        speaker: ChatMessage.getSpeaker(),\n        flags: {\n          \"treat_wounds_battle_medicine\": {\n            id: target.id,\n            dos: success,\n            healerId: token.actor.id,\n            healing: healRoll._total,\n            bmBatonUsed: usedBattleMedicsBaton,\n          }\n        }\n      });\n    } else {\n      ChatMessage.create({\n        user: game.user.id,\n        type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n        flavor: `No healing done.<br>${immunityMessage}`,\n        speaker: ChatMessage.getSpeaker(),\n        flags: {\n          \"treat_wounds_battle_medicine\": {\n            id: target.id,\n            dos: success,\n            healerId: token.actor.id,\n            healing: healRoll._total,\n            bmBatonUsed: usedBattleMedicsBaton,\n          }\n        }\n      });\n    }\n  } else {\n    med.check.roll({\n      dc: dc,\n      event: event,\n      extraRollOptions: getRollOptions({ isRiskySurgery: isRiskySurgery }),\n      callback: async (roll) => {\n        const { healFormula, successLabel } = getHealSuccess({\n          success: roll.options.degreeOfSuccess,\n          useMagicHands,\n          useMortalHealing,\n          isRiskySurgery,\n          bonusString,\n          spellStitcherBonus,\n        });\n        if (isRiskySurgery) {\n          ChatMessage.create({\n            user: game.user.id,\n            type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n            flavor: `<strong>Damage Roll: Risky Surgery</strong>`,\n            roll: await new DamageRoll('1d8[slashing]').roll({ async: true }),\n            speaker: ChatMessage.getSpeaker(),\n          });\n        }\n        let healRoll = 0;\n        if (healFormula !== undefined) {\n          const rollType = roll.options.degreeOfSuccess > 1 ? 'Healing' : 'Damage';\n          const my_message = `<strong>${rollType} Roll: ${bmtw}</strong> (${successLabel})`;\n          healRoll = await new DamageRoll(`(${healFormula})[${rollType.toLowerCase()}]`).roll(\n            { async: true }\n          );\n\n          dsnHook(() => {\n            healRoll.toMessage({\n              flavor: `${my_message}<br>${immunityMessage}`,\n              speaker: ChatMessage.getSpeaker(),\n              flags: {\n                \"treat_wounds_battle_medicine\": {\n                  id: target.id,\n                  dos: roll.options.degreeOfSuccess,\n                  healerId: token.actor.id,\n                  healing: healRoll._total,\n                  bmBatonUsed: usedBattleMedicsBaton,\n                }\n              }\n            });\n          });\n        } else {\n          dsnHook(() => {\n            ChatMessage.create({\n              user: game.user.id,\n              type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n              flavor: `No healing done.<br>${immunityMessage}`,\n              speaker: ChatMessage.getSpeaker(),\n              flags: {\n                \"treat_wounds_battle_medicine\": {\n                  id: target.id,\n                  dos: roll.options.degreeOfSuccess,\n                  healerId: token.actor.id,\n                  healing: healRoll._total,\n                  bmBatonUsed: usedBattleMedicsBaton,\n                }\n              }\n            });\n          });\n        }\n      },\n    });\n  }\n};\n\nasync function applyChanges($html) {\n for (const token of canvas.tokens.controlled) {\n   var med = token.actor.skills.medicine;\n\n   if (!med) {\n     ui.notifications.warn(\n       `Token ${token.name} does not have the medicine skill`\n     );\n     continue;\n   }\n   const hasWardMedic = checkFeat('ward-medic');\n   const useBattleMedicine =\n     parseInt($html.find('[name=\"useBattleMedicine\"]')[0]?.value) === 1;\n   const bmtw = useBattleMedicine ? 'Battle Medicine' : 'Treat Wounds';\n   const maxTargets = useBattleMedicine? 1 : hasWardMedic? 2**(med.rank-1): 1;\n   if (game.user.targets.size > maxTargets){\n     ui.notifications.warn(`Too many targets (${game.user.targets.size}) for ${bmtw}. You can select a maximum of ${maxTargets} targets.`);\n     continue;\n   }\n   const useHealingPlaster = $html.find('[name=\"useHealingPlaster\"]')[0]?.checked;\n   const useBuiltInTools = $html.find('[name=\"useBuiltInTools\"]')[0]?.checked;\n   if (useBuiltInTools) {\n     // skip the following else/if.\n   } else if (!useBattleMedicine && useHealingPlaster === false ){\n     ui.notifications.warn(`You can't ${bmtw} without Healer's Tools or a Healing Plaster.`);\n     continue;\n   } else if (useBattleMedicine && useHealingPlaster !== undefined) {\n     ui.notifications.warn(`You can't use ${bmtw} without Healer's Tools.`);\n     continue;\n   }\n   const { name } = token;\n   const level = token.actor.system.details.level.value;\n   const mod = parseInt($html.find('[name=\"modifier\"]').val()) || 0;\n   const assurance = $html.find('[name=\"assurance_bool\"]')[0]?.checked;\n   const requestedProf =\n     parseInt($html.find('[name=\"dc-type\"]')[0].value) || 1;\n   const hasMedicDedication = checkFeat('medic-dedication');\n   // Risky Surgery does not apply when Battle Medicine is used.\n   const isRiskySurgery = !useBattleMedicine &&\n     $html.find('[name=\"risky_surgery_bool\"]')[0]?.checked;\n   // Mortal Healing does not apply when Battle Medicine is used.\n   const useMortalHealing = !useBattleMedicine && \n     $html.find('[name=\"mortal_healing_bool\"]')[0]?.checked;\n   // Magic Hands do not apply when Battle Medicine is used.\n   const useMagicHands = !useBattleMedicine &&\n     checkFeat('magic-hands');\n   const useContinualRecovery = !useBattleMedicine &&\n     checkFeat('continual-recovery');\n   const usedBattleMedicsBaton = useBattleMedicine && \n     $html.find('[name=\"battle_medics_baton_held_bool\"]')[0]?.checked;\n   const bmUUID = 'Compendium.pf2e.feat-effects.2XEYQNZTCGpdkyR6';\n   const twUUID = 'Compendium.pf2e.feat-effects.Lb4q2bBAgxamtix5';\n   const immunityEffectUUID = useBattleMedicine ? bmUUID : twUUID;\n   let immunityMacroLink = ``;\n   if (game.modules.has('xdy-pf2e-workbench') && game.modules.get('xdy-pf2e-workbench').active) { \n     // Extract the Macro ID from the asynomous benefactor macro compendium.\n     const macroName = useBattleMedicine ? `BM Immunity CD`: `TW Immunity CD`;\n     const macroId = (await game.packs.get('xdy-pf2e-workbench.asymonous-benefactor-macros')).index.find(n => n.name === macroName)?._id;\n     immunityMacroLink = `@Compendium[xdy-pf2e-workbench.asymonous-benefactor-macros.${macroId}]{Apply ${bmtw} Immunity}`\n   } else {\n     ui.notifications.warn(`Workbench Module not active! Linking Immunity effect Macro not possible.`);\n   }\n   const forensicMedicine = checkFeat('forensic-medicine-methodology');\n\n   let spellStitcherBonus = 0;\n   if (checkFeat('spell-stitcher') && useBattleMedicine) {\n     if (token.actor.itemTypes.effect.some(obj => { return obj.slug === \"stance-arcane-cascade\" })) {\n       spellStitcherBonus = 1;\n       if (token.actor.class.slug === \"magus\" && checkFeat(\"weapon-specialization\")) {\n         spellStitcherBonus = 2;\n       };\n       if (token.actor.class.slug === \"magus\" && checkFeat(\"greater-weapon-specialization\")) {\n         spellStitcherBonus = 3;\n       }\n     }\n   }\n   const skill = $html.find('[name=\"skill\"]')[0]?.value;\n\n   // Handle Rule Interpretation\n   if (game.user.isGM) {\n     await game.settings.set(\n       'pf2e',\n       'RAI.TreatWoundsAltSkills',\n       $html.find('[name=\"strict_rules\"]')[0]?.checked\n     );\n   }\n\n   let usedProf = 0;\n   if (game.settings.get('pf2e', 'RAI.TreatWoundsAltSkills')) {\n     if (skill === 'cra') {\n       med = token.actor.skills.crafting;\n     }\n     if (skill === 'nat') {\n       med = token.actor.skills.nature;\n     }\n     if (skill === 'arc') {\n       med = token.actor.skills.arcana;\n     }\n     usedProf = requestedProf <= med.rank ? requestedProf : med.rank;\n   } else {\n     usedProf = requestedProf <= med.rank ? requestedProf : med.rank;\n     if (skill === 'cra') {\n       med = token.actor.skills.crafting;\n     }\n     if (skill === 'arc') {\n       med = token.actor.skills.arcana;\n       if (usedProf === 0) {\n         usedProf = 1;\n       }\n     }\n     if (skill === 'nat') {\n       med = token.actor.skills.nature;\n       if (usedProf === 0) {\n         usedProf = 1;\n       }\n     }\n   }\n   if (checkItemTypeFeat('clever-improviser') && usedProf === 0) {\n     usedProf = 1;\n   }\n   const medicBonus = hasMedicDedication ? (usedProf - 1) * 5 : 0;\n   const useBattleMedicineBonus = useBattleMedicine * level * forensicMedicine;\n   const magicHandsBonus = useMagicHands * level;\n\n   const showIcons = true;\n   const immunityEffect = (await fromUuid(immunityEffectUUID)).toObject();\n   immunityEffect.system.tokenIcon.show = showIcons; //Potential for lots of effects to be on a token. Don't show icon to avoid clutter\n   immunityEffect.flags.core ??= {};\n   immunityEffect.flags.core.sourceId = immunityEffectUUID;\n\n   for(let target of game.user.targets){\n     let targetActor = target.actor;\n\n     immunityEffect.name = useBattleMedicine ? `${bmtw} by ${name}`: `${bmtw}`;\n     const hasGodlessHealing = targetActor.items.filter((item) => item.type === 'feat').some((item) => item.system.slug === \"godless-healing\");\n     const godlessHealingBonus = hasGodlessHealing ? 5 : 0;\n\n     // check if the person being healed is currently immune. If so, check if healer is a medic\n     var isImmune = targetActor.itemTypes.effect.find(obj => {\n       return obj.name === immunityEffect.name\n     })\n     if (isImmune) {\n         if (useBattleMedicine && hasMedicDedication) {\n             var medicCooldown = token.actor.itemTypes.effect.find(obj => {\n                 return obj.name === \"Medic dedication used\"\n             })\n             if (medicCooldown) {\n                 ui.notifications.warn(targetActor.name + ` is currently immune to ${bmtw} by ` + token.name);\n                 continue;\n             } else {\n                 const applicatorImmunityEffect = (await fromUuid(immunityEffectUUID)).toObject();\n                 applicatorImmunityEffect.system.tokenIcon.show = showIcons; \n                 applicatorImmunityEffect.flags.core ??= {};\n                 applicatorImmunityEffect.flags.core.sourceId = immunityEffectUUID;\n                 if (token.actor.skills.medicine.rank > 2) {\n                   applicatorImmunityEffect.system.duration.unit = \"hours\"; //Cooldown of Medic Dedication depends on medicine skill rank\n                 }\n\n                 applicatorImmunityEffect.name = \"Medic dedication used\";\n                 await token.actor.createEmbeddedDocuments(\"Item\", [applicatorImmunityEffect]);\n                 ui.notifications.info(token.name + ` has now used their Medic Dedication to apply ${bmtw} to ` + targetActor.name);\n             }\n         } else {\n             ui.notifications.warn(targetActor.name + ` is currently immune to ${bmtw} by ` + token.name);\n             continue;\n         }\n     }\n\n     if (forensicMedicine || hasGodlessHealing) {\n       immunityEffect.system.duration.unit = \"hours\";\n     }\n     if (useContinualRecovery) {\n       immunityEffect.system.duration.unit = \"minutes\";\n       immunityEffect.system.duration.value = 10;\n     }\n     if (usedBattleMedicsBaton) {\n      immunityEffect.system.duration.unit = \"minutes\";\n      immunityEffect.system.duration.value = 60;\n      const applicatorImmunityEffect = (await fromUuid(immunityEffectUUID)).toObject();\n      applicatorImmunityEffect.system.tokenIcon.show = showIcons; \n      applicatorImmunityEffect.flags.core ??= {};\n      applicatorImmunityEffect.flags.core.sourceId = immunityEffectUUID;\n      applicatorImmunityEffect.system.duration.unit = \"minutes\";\n      applicatorImmunityEffect.system.duration.value = 60;\n      applicatorImmunityEffect.name = \"Battle Medic's Baton used\";\n      await token.actor.createEmbeddedDocuments(\"Item\", [applicatorImmunityEffect]);\n      ui.notifications.info(token.name + ` has now used their Battle Medic's Baton to apply ${bmtw} to ` + targetActor.name);\n    }\n     // does only work if both tokens have the same owner.\n     // await targetActor.createEmbeddedDocuments(\"Item\", [immunityEffect]);\n     // ui.notifications.info(targetActor.name + ` is now immune to ${bmtw} by ` + token.name);\n\n     // Roll for Treat Wounds/Battle Med\n     switch (usedProf) {\n       case 0:\n         ui.notifications.warn(\n           `${name} is not trained in Medicine and doesn't know how to ${bmtw}.`\n         );\n         break;\n       case 1:\n         rollTreatWounds({\n           DC: 15 + mod,\n           bonus: 0 + medicBonus + godlessHealingBonus + useBattleMedicineBonus + magicHandsBonus,\n           med,\n           isRiskySurgery,\n           useMortalHealing,\n           useMagicHands,\n           assurance,\n           bmtw,\n           target,\n           immunityEffect,\n           immunityMacroLink,\n           usedBattleMedicsBaton,\n           spellStitcherBonus,\n         });\n         break;\n       case 2:\n         rollTreatWounds({\n           DC: 20 + mod,\n           bonus: 10 + medicBonus + godlessHealingBonus + useBattleMedicineBonus + magicHandsBonus,\n           med,\n           isRiskySurgery,\n           useMortalHealing,\n           useMagicHands,\n           assurance,\n           bmtw,\n           target,\n           immunityEffect,\n           immunityMacroLink,\n           usedBattleMedicsBaton,\n           spellStitcherBonus,\n         });\n         break;\n       case 3:\n         rollTreatWounds({\n           DC: 30 + mod,\n           bonus: 30 + medicBonus + godlessHealingBonus + useBattleMedicineBonus + magicHandsBonus,\n           med,\n           isRiskySurgery,\n           useMortalHealing,\n           useMagicHands,\n           assurance,\n           bmtw,\n           target,\n           immunityEffect,\n           immunityMacroLink,\n           usedBattleMedicsBaton,\n           spellStitcherBonus,\n         });\n         break;\n       case 4:\n         rollTreatWounds({\n           DC: 40 + mod,\n           bonus: 50 + medicBonus + godlessHealingBonus + useBattleMedicineBonus + magicHandsBonus,\n           med,\n           isRiskySurgery,\n           useMortalHealing,\n           useMagicHands,\n           assurance,\n           bmtw,\n           target,\n           immunityEffect,\n           immunityMacroLink,\n           usedBattleMedicsBaton,\n           spellStitcherBonus,\n         });\n         break;\n       default:\n         ui.notifications.warn(\n           `${name} has an invalid usedProf value of ${usedProf}.`\n         );\n     }\n   }\n }\n}\n\n/**\n* Render the content for the dialog\n*\n* @param {Object} options\n* @param {boolean} options.hasChirurgeon Is the actor a chirurgeon\n* @param {boolean} options.hasNaturalMedicine Does the actor have natural medicine\n* @param {boolean} options.hasBattleMedicine Does the actor have battle medicine\n* @param {boolean} options.hasSpellStitcher Does the actor have Spell Stitcher (Magus+ feat)\n* @param {boolean} options.tmed Does the actor have medicine\n* @param {number} options.totalAssurance Assurance of the actor\n* @returns {string} The Dialog content\n*/\nconst renderDialogContent = ({\n hasChirurgeon,\n hasNaturalMedicine,\n hasBattleMedicine,\n hasSpellStitcher,\n tmed,\n totalAssurance,\n hasHealersTools,\n hasHealersToolsHeld,\n batonUsed,\n hasBattleMedicsBatonHeld,\n inCombat,\n}) => `\n <div>\n   Attempt to heal the target by 2d8 hp.<br>You have to hold healer's toolkit, or you are wearing them and have a hand free!<br>\n   <small>Hover the options for more information.</small>\n </div>\n <hr/>\n ${\n   !hasHealersTools \n     ? `<b>You don't have healer's toolkit on your character!</b>\n       ${\n         checkItemTypeFeat('built-in-tools')\n           ? `<form>\n             <div class=\"form-group\">\n               <label title=\"Are you wielding, wearing, or adjacent to your innovation?\">Is healer's toolkit one of your Built-In Tools?</label>\n               <input type=\"checkbox\" id=\"useBuiltInTools\" name=\"useBuiltInTools\" checked></input>\n             </div>\n           </form>`\n           : ``\n       }\n       <form>\n         <div class=\"form-group\">\n          <label title=\"Healing Plaster is a cantrip which can can replace healer's toolkit for Treat Wounds.\">Are you using Healing Plaster? <small>(only for Treat wounds)</small></label>\n           <input type=\"checkbox\" id=\"useHealingPlaster\" name=\"useHealingPlaster\"></input>\n         </div>\n       </form>`\n     : ``\n }\n ${\n   hasChirurgeon || hasNaturalMedicine || hasSpellStitcher\n     ? `<form>\n         <div class=\"form-group\">\n         <label title=\"Select the skill you want to use.\">Treat Wounds Skill:</label>\n           <select id=\"skill\" name=\"skill\">\n             ${tmed ? `<option value=\"med\">Medicine</option>` : ``}\n             ${hasChirurgeon ? `<option value=\"cra\">Crafting</option>` : ``}\n             ${hasNaturalMedicine ? `<option value=\"nat\">Nature</option>` : ``}\n             ${hasSpellStitcher ? `<option value=\"arc\">Arcana</option>` : ``}\n           </select>\n         </div>\n       </form>`\n     : ''\n }\n <form>\n     <div class=\"form-group\">\n         <select id=\"useBattleMedicine\" name=\"useBattleMedicine\">\n             <option value=\"0\">Treat Wounds</option>\n             ${\n               hasBattleMedicine\n                 ? `<option value=\"1\" ${inCombat ? 'selected' : ''}>Battle Medicine</option>`\n                 : ''\n             }\n         </select>\n     </div>\n </form>\n ${\n   checkFeat('forensic-medicine-methodology')\n     ? `<form>\n         <div class=\"form-group\">\n             <label title=\"When you use Battle Medicine, on a success the target recovers additional Hit Points equal to your level.\">Forensic Medicine Bonus applies when selecting Battle Medicine.</label>\n         </div>\n       </form>`\n     : ``\n }\n ${\n   (hasChirurgeon &&\n     (checkItemTypeFeat('assurance', 'Assurance (Crafting)') ||\n       checkItemTypeFeat('assurance-crafting'))) ||\n   (hasNaturalMedicine &&\n     (checkItemTypeFeat('assurance', 'Assurance (Nature)') ||\n       checkItemTypeFeat('assurance-nature'))) ||\n   (hasSpellStitcher &&\n     (checkItemTypeFeat('assurance', 'Assurance (Arcana)') ||\n       checkItemTypeFeat('assurance-arcana'))) ||\n   checkItemTypeFeat('assurance', 'Assurance (Medicine)') ||\n   checkItemTypeFeat('assurance-medicine')\n     ? `<form>\n     <div class=\"form-group\">\n         <label>Use Assurance? <small>This will beat DC ${totalAssurance}</small></label>\n         <input type=\"checkbox\" id=\"assurance_bool\" name=\"assurance_bool\"></input>\n     </div>\n </form>`\n     : ``\n }\n <form>\n     <div class=\"form-group\">\n         <label title=\"Select a target DC. Remember that you can't attempt a heal above your proficiency. Attempting to do so will downgrade the DC and amount healed to the highest you're capable of.\">Medicine DC:</label>\n         <select id=\"dc-type\" name=\"dc-type\">\n             <option value=\"1\" selected>Trained DC 15</option>\n         ${\n           checkFeat('medic-dedication') \n             ? ` <option value=\"2\">Expert DC 20, +15 Healing</option>\n                 <option value=\"3\">Master DC 30, +40 Healing</option>\n                 <option value=\"4\">Legendary DC 40, +65 Healing</option>`\n             : ` <option value=\"2\">Expert DC 20, +10 Healing</option>\n                 <option value=\"3\">Master DC 30, +30 Healing</option>\n                 <option value=\"4\">Legendary DC 40, +50 Healing</option>`\n         }\n         </select>\n     </div>\n </form>\n <form>\n     <div class=\"form-group\">\n         <label title=\"Any circumstance or other dc modifiers at your GMs decission.\">DC Modifier:</label>\n         <input id=\"modifier\" name=\"modifier\" type=\"number\"/>\n     </div>\n </form>\n ${\n   checkFeat('risky-surgery')\n     ? `<form>\n         <div class=\"form-group\">\n           <label title\"Will not be applied when using Battle Medicine.\">Risky Surgery</label>\n           <input type=\"checkbox\" id=\"risky_surgery_bool\" name=\"risky_surgery_bool\"></input>\n         </div>\n       </form>`\n     : ``\n }\n ${\n   checkFeat('mortal-healing')\n     ? `<form>\n         <div class=\"form-group\">\n           <label title=\"Target creature must not have regained Hit Points from divine magic in the past 24 hours.\n                         Will not be applied when using Battle Medicine.\">Mortal Healing</label>\n           <input type=\"checkbox\" id=\"mortal_healing_bool\" name=\"mortal_healing_bool\" checked></input>\n         </div>\n       </form>`\n     : ``\n }\n ${\n   game.user.isGM\n     ? `<form>\n         <div class=\"form-group\">\n           <label>Allow higher DC from alternate skills?</label>\n           <input type=\"checkbox\" id=\"strict_rules\" name=\"strict_rules\"${\n             game.settings.get('pf2e', 'RAI.TreatWoundsAltSkills')\n               ? ` checked`\n               : ``\n           }\n           ></input>\n         </div>\n       </form>`\n     : ``\n }\n ${\n  !batonUsed &&\n  hasBattleMedicsBatonHeld \n    ? `<form>\n        <div class=\"form-group\">\n          <label title=\"(Battle Medicine only) Target creature will only be immune for one hour instead of 24 hours to your Battle Medicine.\">Use Battle Medic's Baton:</label>\n          <input type=\"checkbox\" id=\"battle_medics_baton_held_bool\" name=\"battle_medics_baton_held_bool\"></input>\n        </div>\n      </form>`\n    : ``\n }\n ${\n   !hasHealersToolsHeld\n     ? `<b>Note: To gain the bonus of Healer's toolkit (if any), you have to set the Healer's toolkit to be WORN, due to how the item is implemented in the pf2e core system.</b>`\n     : ``\n }\n </form>\n`;\n\nif (canvas.tokens.controlled.length !== 1){\n ui.notifications.warn('You need to select exactly one token as the healer.');\n} else if (game.user.targets.size < 1){\n   ui.notifications.warn(`You must target at least one token.`);\n} else {\n const hasChirurgeon = checkFeat('chirurgeon');\n const hasNaturalMedicine = checkFeat('natural-medicine');\n const hasBattleMedicine = checkFeat('battle-medicine');\n const hasSpellStitcher = checkFeat('spell-stitcher'); ///< From Magus+, allows using Arcana for actions that normally require Medicine\n let tmed = token.actor.skills.medicine.rank > 0;\n if (\n   !tmed &&\n   !hasChirurgeon &&\n   !hasNaturalMedicine &&\n   !hasSpellStitcher &&\n   !checkItemTypeFeat('clever-improviser')\n ) {\n   ui.notifications.warn(\n     'Medicine is not trained and you do not possess a feat or feature to use another skill'\n   );\n } else {\n   let bmtw_skill = 0\n   if (tmed && (checkItemTypeFeat('assurance', 'Assurance (Medicine)') ||\n    checkItemTypeFeat('assurance-medicine'))) {\n     bmtw_skill = token.actor.skills.medicine;\n   } else if (hasChirurgeon && (checkItemTypeFeat('assurance', 'Assurance (Crafting)') ||\n    checkItemTypeFeat('assurance-crafting'))) {\n     bmtw_skill = token.actor.skills.crafting;\n   } else if (hasNaturalMedicine && (checkItemTypeFeat('assurance', 'Assurance (Nature)') ||\n    checkItemTypeFeat('assurance-nature'))) {\n     bmtw_skill = token.actor.skills.nature;\n   } else if (hasSpellStitcher && (checkItemTypeFeat('assurance', 'Assurance (Arcana)') ||\n    checkItemTypeFeat('assurance-arcana'))) {\n     bmtw_skill = token.actor.skills.arcana;\n   }\n   const hasHealersTools = checkItemPresent('healer-s-toolkit') || checkItemPresent('healers-toolkit') \n                           || checkItemPresent('healers-toolkit-expanded') || checkItemPresent('violet-ray')\n                           || checkItemPresent('marvelous-medicines') || checkItemPresent('marvelous-medicines-greater');\n   const hasHealersToolsHeld = !hasHealersTools || checkItemPresent('healer-s-toolkit', 0) || checkItemPresent('healers-toolkit', 0)\n                           || checkItemPresent('healers-toolkit-expanded', 0) || checkItemPresent('violet-ray', 2)\n                           || checkItemPresent('marvelous-medicines', 2) || checkItemPresent('marvelous-medicines-greater', 2);\n   const hasBattleMedicsBatonHeld = checkItemPresent('battle-medic-s-baton', 1) || checkItemPresent('battle-medics-baton', 1);\n   const batonUsed = token.actor.itemTypes.effect.find(obj => {\n      return obj.name === `Battle Medic's Baton used`\n   })\n   const inCombat = game.combats.active?.started;\n   const level = token.actor.system.details.level.value;\n   const totalAssurance = 10 + (bmtw_skill.rank * 2 + level);\n   const dialog = new Dialog({\n     title: 'Treat Wounds / Battle Medicine',\n     content: renderDialogContent({\n       hasChirurgeon,\n       hasNaturalMedicine,\n       hasBattleMedicine,\n       hasSpellStitcher,\n       tmed,\n       totalAssurance,\n       hasHealersTools,\n       hasHealersToolsHeld,\n       batonUsed,\n       hasBattleMedicsBatonHeld,\n       inCombat,\n     }),\n     buttons: {\n       yes: {\n         icon: `<i class=\"fas fa-hand-holding-medical\"></i>`,\n         label: 'Treat Wounds',\n         callback: applyChanges,\n       },\n       no: {\n         icon: `<i class=\"fas fa-times\"></i>`,\n         label: 'Cancel',\n       },\n     },\n     default: 'yes',\n   });\n   dialog.render(true);\n }\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Treat Wounds and Battle Medicine.js\" - Fetched on 2024-06-05T17:22:21.779Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Treat Wounds and Battle Medicine","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"s6cRbB1O255qprRg","actorIds":[],"author":"CQwvcoWTraz5i6tN","command":"/*\nWelcome to the Caster's Spellbook.\nThis macro was designed to facilitate casting spells from a\ncharacter with a large list of spells, like a dual class double caster\nbuild, or a caster with multiple spellcasting entries.\nThis macro will sort by the spellcasting entries, available spell ranks,\nand finally the spells you have at those ranks\nLeft clicking on the spell expends the slot/uses/focus point and\nposts the spell to the Chat Log.\nRight clicking on the spell pops open the spell edit sheet same as if you had edited\nthe spell from within your character sheet.\n*/\n\nif(canvas.tokens.controlled.length === 0) { return ui.notifications.warn(\"Please select a token\"); }\nif (canvas.tokens.controlled.length > 1) { return ui.notifications.warn(\"Please select only 1 token\"); }\nif (!token.actor.isSpellcaster) { return ui.notifications.warn(`${token.actor.name} is not a Spellcaster`); }\n\nconst script = async function Spells(id){\n  for (const token of canvas.tokens.controlled) {\n\t\tlet spells = [];\n\t\tlet buttons = {};\n\t\tconst spellData = await (token.actor.itemTypes.spellcastingEntry.find( i => i.id === id)).getSheetData();\n\t\tspellData.groups.forEach(sp => {\n\t\t\tif(!spellData.isRitual && !spellData.isPrepared && !spellData.isInnate && !spellData.isFocusPool && !spellData.isFlexible && sp.id !== \"cantrips\" && sp.uses?.value < 1) { return; }\n            if (sp.uses?.value !== undefined && sp.uses?.value === 0 ) { return; }\n\t\t\tsp.active.forEach((spa,index) => {\n\t\t\t\tif(spa === null) { return; }\n\t\t\t\tif(spa.expended) { return; }\n\t\t\t\tlet lvl = sp.id;\n\t\t\t\tif (lvl === \"cantrips\") { lvl = 0 }\n\t\t\t\tif(spa.spell.isFocusSpell && !spa.spell.isCantrip && token.actor.system.resources.focus.value === 0) { return; }\n\t\t\t\tlet type = '';\n\t\t\t\tif (spellData.isRitual) { type = 'ritual'}\n\t\t\t\tspells.push({name: spa.spell.name, spell: spa, lvl, type: type, index: index, sEId: spellData.id});\n\t\t\t});\n\t\t});\n\t\t\t\n\t\tspells.sort((a, b) => {\n\t\t\tif (a.lvl === b.lvl)\n\t\t\t\treturn a.name\n\t\t\t\t.toUpperCase()\n\t\t\t\t.localeCompare(b.name.toUpperCase(), undefined, {\n\t\t\t\tsensitivity: \"base\",\n\t\t\t});\n\t\t\treturn a.lvl - b.lvl;\n\t\t});\n\n\t\t\tif(spells.length === 0) { return ui.notifications.info(\"You have no spells available or are out of focus points\"); }\n\n\t\tawait Levels();\n\n\t\tasync function Levels() {\n\t\t\tbuttons = {};\n\t\t\tlet levels = [...new Set(spells.map(l => l.lvl))];\n\t\t\tlevels.forEach((index,value)=> {\n\t\t\t\t\tif (index === 0) { index = 'Cantrip'}\n\t\t\t\tasync function Filter(){\n\t\t\t\t\tif (index === 'Cantrip') { spells = spells.filter(c => c.spell.spell.isCantrip); }\n\t\t\t\t\telse{ spells = spells.filter(l => l.lvl === index); }\n\t\t\t\t}\n\t\t\t\tbuttons[value] = {label: index, callback: async () => { await Filter(); await Spell(); }}\n\t\t\t});\n\t\t\tawait Diag({title: \"Spell Rank?\", buttons});\n\t\t}\n\n\t\tasync function Spell() {\n\t\t\tbuttons = {};\n\t\t\tspells.forEach((value,index) => {\n\t\t        async function Consume(){\n\t\t\t    \tconst s_entry = token.actor.itemTypes.spellcastingEntry.find(e => e.id === value.sEId);\n\t\t\t    \tawait s_entry.cast(value.spell.spell,{slotId: value.index,rank: value.lvl,message: true})\n\t\t\t    };\n\t\t\t\tbuttons[index] = {label: value.name, value: value.spell.spell ,callback: async () => {  await Consume(); }}\n\t\t\t});\n\t\t\tawait Diag({title: \"Pick a Spell to Cast\", buttons});\n\t\t\tspells.forEach( async s => {\n        \t\tconst elements = document.getElementsByClassName(\"dialog-button\");\n        \t\tlet myElem1 = [...document.getElementsByClassName(\"app window-app dialog\")].pop();\n        \t\tmyElem1.style.display = \"flex\";\n        \t\tmyElem1.style.flexWrap = \"wrap\";\n        \t\tmyElem1.style.height = \"auto\";\n        \t\tmyElem1.style.width = \"200px\";\n        \t\tmyElem1.style.gap = \"5px 5px\";\n        \t\tlet myElem2 = [...document.getElementsByClassName(\"dialog-buttons\")].pop();\n        \t\tmyElem2.style.display = \"flex\";\n        \t\tmyElem2.style.flexFlow = \"column wrap\";\n        \t\tlet element;\n\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n          \t\t\tif (elements[i].innerText === s.name) {\n            \t\t\telement = elements[i];\n\t\t\t\t\t\telement.style.lineHeight = \"normal\";\n\t\t\t\t\t\tawait $(element).bind(\"contextmenu\", function () { \n        \t\t\t\t\ts.spell.spell.sheet.render(true);\n\t\t\t\t\t\t});\n          \t\t\t}\n      \t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\tasync function Diag({title,buttons,content} = {}) {\n\t\tawait new Promise((resolve) => {\n\t\t\tnew Dialog({\n\t\t\t\ttitle,\n\t\t\t\tbuttons,\n\t\t\t}).render(true);\n      setTimeout(resolve,10);\n\t\t});\n\t}\n }\n\n  \nlet content = `\n<style>\n  .psya-buttons {\n    margin: 0 auto;\n  }\n\n  .psya-buttons:hover {\n    background-color:#44c767;\n  }\n</style>\n<div><strong>Choose a Spellcasting Entry:</strong></div><script>${script}\n</script>`;\ntoken.actor.itemTypes.spellcastingEntry.forEach((value,index) => {\n\tconst test = value.getSheetData();\n\tif (test.isFocusPool && !test.levels.some(x => x.isCantrip) && token.actor.system.resources.focus.value === 0){ return; }\n  \tcontent = content + `<button name=\"button${index}\" class=\"psya-buttons ${index}\" type=\"button\" value=\"${value.name}\" onclick=\"Spells('${value.id}')\">${value.name}</button>`\n});  \n\nawait new Promise(async (resolve) => {\n    setTimeout(resolve,200);\n \tawait new Dialog({\n    \ttitle:\"Spellbook\",\n    \tcontent,\n    \tbuttons:{ Close: { label: \"Close\" } },\n    },{width: 210}).render(true);\n});\n\n\nlet myElem = [...document.getElementsByClassName(\"app window-app dialog\")].pop();\nif (myElem.style === undefined) { myElem = [...document.getElementsByClassName(\"app window-app dialog\")].pop(); }\nmyElem.style.resize = \"both\";\nmyElem.style.overflow = \"auto\";\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Casters Spellbook.js\" - Fetched on 2024-06-05T17:22:21.767Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Casters Spellbook","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"t07USBAl0VLh02dI","actorIds":[],"author":"Th4Op1U3mNGP8z7q","command":"//GM Group Perception Roller\n\nif ( !game.user.isGM ) { return ui.notifications.info(\"This is a GM only macro\") }\n\nconst exceptions = [\n\t\"vehicle\",\n\t\"loot\",\n\t\"hazard\",\n\t\"party\",\n];\nlet content = `<strong>Group Perception Roller</strong>\n\t\t<table>\n\t\t<tr>\n\t\t\t<th style=\"text-align:left\">Name</th>\n\t\t\t<th style=\"text-align:center\">Roll + Mod</th>\n\t\t\t<th style=\"text-align:center\">Total</th>\n\t\t</tr>`;\nfor ( const t of canvas.tokens.placeables) {\n\tif ( !exceptions.includes(t.actor.type) && t.actor.hasPlayerOwner ) {\n\t\tconst {result,total,dice} = await new Roll(`1d20 + ${t.actor.perception.mod}`).evaluate();\n\t\tconst userId = Object.keys(t.actor.ownership).find(f => f !== \"default\" && !game.users.get(f).isGM);\n\t\tconst userColor = game.users.get(userId)?.color ?? \"grey\";\n\t\tlet color = \"\";\n\t\tif ( dice[0].total === 1 ) {\n\t\t\tcolor = `;font-size:115%;color:red`;\n\t\t}\n\t\telse if ( dice[0].total === 20 ) {\n\t\t\tcolor = `;font-size:115%;color:green`;\n\t\t}\n\t\telse {\n\t\t\tcolor = `;color:blue`;\n\t\t}\n\t\tcontent += `\n\t\t\t<tr>\n\t\t\t<th style=\"color:${userColor};text-shadow: 1px 1px 1px black\">${t.actor.name}</th>\n\t\t\t<td style=\"text-align:center\">${result}</td>\n\t\t\t<th style=\"text-align:center${color}\">${total}</th>\n\t\t\t</tr>`;\n\t}\n}\ncontent += `</table>`;\n\nawait ChatMessage.create({\n\tcontent,\n\ttype: CONST.CHAT_MESSAGE_TYPES.WHISPER,\n\twhisper: [game.userId]\n});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Group Perception Roller.js\" - Fetched on 2024-06-05T17:22:21.769Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Group Perception Roller","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"tCSZXLLT5fS1B8em","actorIds":[],"author":"BhSsgXXgV9EDnM89","command":"/* Automatically get correct damage type for Arcane Cascade.\n\n By Trent#7043\n\n Looks for the most recent spell cast by the actor in the current scene and\n applies the Arcane Cascade effect to the actor with the damage type\n automatically selected based on the spell damage (remaster rules).  If the\n spell does multiple damage types, the choiceset dialog will still appear, but\n only the damage types from the spell will be present as choices.\n\n Remove an existing AC Effect when the new one is added.\n*/\n\nconst ACEffectUuid = 'Compendium.pf2e.feat-effects.Item.fsjO5oTKttsbpaKl';\n\nconst spell = game.messages.contents.findLast(m => \n  m.speaker.actor === actor.id && \n  m.flags.pf2e.origin?.type === 'spell' && \n  m.speaker.scene === game.scenes.active.id)?.item;\n\nif (!spell) {\n  ui.notifications.warn(\"You haven't cast a spell!\");\n  return;\n}\nconst dtypes = Object.values(spell.system.damage).map(d => d.type);\nconst effect = (await fromUuid(ACEffectUuid)).toObject();\nconst re = effect.system.rules.find(r => r.flag === 'stanceArcaneCascade');\nif (dtypes.length <= 1) {\n  // One or no damage, we know the type.\n  re.selection = dtypes[0] ?? 'force';\n} else {\n  // Multiple damage types, restrict choices to those done by spell.\n  re.choices = re.choices.filter(c => dtypes.includes(c.value));\n}\nawait actor.itemTypes.effect.find(e => e.flags.core?.sourceId === effect.flags.core.sourceId)?.delete();\nactor.createEmbeddedDocuments(\"Item\", [effect]);\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Automatic Arcane Cascade.js\" - Fetched on 2024-06-05T17:22:21.774Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Automatic Arcane Cascade","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"uEUAVdihL4dHQmt0","actorIds":[],"author":"YzwxayHTThP8WCEk","command":"/*\nThis is complete rewrite of the Eldritch Shot macro.\nTo use this macro, you just have to target someone and use it.\nAdded the ability to reroll using a hero point if available.\n*/\n\n\nEldritch_shot();\n\nasync function Eldritch_shot()\n{\n\t/* Throw warning if token is not selected*/\n\tif (canvas.tokens.controlled.length < 1) { return void ui.notifications.warn('No token is selected.'); }\n  if (canvas.tokens.controlled.length > 1) { return void ui.notifications.warn('Only 1 token should be selected'); }\n  if (game.user.targets.size < 1) { return void ui.notifications.warn('Please target a token'); }\n  if (game.user.targets.size > 1) { return void ui.notifications.warn('Eldritch Shot can only affect 1 target'); }\n\n\n  /* Check for eldritch archer dedication and warn if not present */\n  if (!token.actor.itemTypes.feat.some(e => e.slug === \"eldritch-archer-dedication\")) {\n    return void ui.notifications.warn('Does not have Eldritch Archer Dedication.');\n  }\n      \n  const DamageRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"DamageRoll\"));\n\n  /* New Spell getter*/\n  const spells = [];\n  for (const e of token.actor.itemTypes.spellcastingEntry) {\n    if (e.isRitual) { continue; }\n    if (e.system.prepared.value === \"items\") { continue }\n\t\tconst spellData = await e.getSheetData();\n    for(const group of spellData.groups) {\n      const isCantrip = group.id === \"cantrips\" ? true : false;\n      let i = 0;\n      for (const active of group.active) {\n        const index = i++;\n        if(active === null) { continue; }\n        let spell = active.spell;\n        if(!spell.system.traits.value.includes(\"attack\") || spell === null) { continue; }\n        const castRank = active.castRank ?? (await spell.getChatData()).castRank;\n        const {isAttack, isSave, description, save, slug, traits, formula} = await spell.getChatData({},{castRank});\n        let rank = `Rank ${castRank}`\n        if(spellData.isPrepared) {\n          rank += ` |Slot: ${index + 1}|`\n        }\n        let lvl = castRank+1;\n        const name = spell.name;\n        if(isCantrip) { \n          rank = `Cantrip ${castRank}`\n          lvl = 0;\n        }\n        if(spellData.isFocusPool) { \n          rank = `Focus ${castRank}`\n          lvl = 1;\n        }\n\t\t\t\tconst sname = `${name} ${rank} (${e.name})`;\n        spells.push({name: sname, castRank, sEId: spellData.id, slug, description, DC: save.value, spell, index, isSave, isAttack, basic: spell.system.defense.save?.basic ?? false, isCantrip, isFocus: spellData.isFocusPool, traits, save: save.type ?? \"\", lvl, formula, isExpended: active.expended ? true : false , isUseless: group.uses?.value < 1 ? true : false});\n      }\n    }\n\t};\n\tspells.sort((a, b) => {\n    if (a.lvl === b.lvl)\n      return a.name\n      .toUpperCase()\n      .localeCompare(b.name.toUpperCase(), undefined, {\n        sensitivity: \"base\",\n      });\n    return a.lvl - b.lvl;\n  });\n\n  if(spells.length === 0) { return void ui.notifications.info(\"You have no spells available\"); }\n  /* Get them bows baby */\n  const weapons = token.actor.itemTypes.weapon.filter(i => i.isEquipped && ['bow','crossbow'].includes(i.system.group) );\n  const map_weap = weapons.map(p => p.name);\n\n  /* Build dialog data */\n  const es_data = [\n    { label : `Choose a Spell : `, type : `select`, options : spells.filter(s => !s.isExpended && !s.isUseless).map(p => p.name) },\n    { label : `Bows : `, type : `select`, options : map_weap },\n    { label : `Reroll using hero point?`, type : `checkbox` }\n  ];\n        \t\n  /* Run dialog and alot data */\n  const spell_choice = await quickDialog({data : es_data, title : `Eldritch Shot`});\n\n  let last, mes;\n  if (spell_choice[2]) {\n    mes = game.messages.contents.findLast( lus => lus.getFlag(\"world\",\"macro.spellUsed\") !== undefined && lus.token.id === token.id);\n    if (mes === undefined) return void ui.notifications.warn(\"There are no previously cast spells or strike has already been rerolled\");\n    if (actor.system.resources.heroPoints.value === 0) { return void ui.notifications.warn(\"You have no hero points left\")}\n    last = mes.getFlag(\"world\",\"macro.spellUsed\");\n    last.spell = actor.itemTypes.spell.find(s => s.slug === last.slug);\n  }\n\t\t\n  /* Get the strike actions and roll strike */\n  const strike = token.actor.system.actions.find(a => a.type === 'strike' && a.label === spell_choice[1]);\n  const spc = last ?? spells.find(sp => sp.name === spell_choice[0]);\n  const s_entry = token.actor.itemTypes.spellcastingEntry.find(e => e.id === spc.sEId);\n\n  // Check for spell variants\n  if(spc.spell.hasVariants && spc.isAttack){\n    let spell_variants;\n    if (spc.spell.overlays.contents[0].system?.time !== undefined){\n      spell_variants = Array.from(spc.spell.overlays.entries(), ([id, ovl]) => ({name: spc.name + ovl.system.time.value, id: id, castRank: spc.castRank}));\n    }\n    else { \n      spell_variants = Array.from(spc.spell.overlays.entries(), ([id, ovl]) => ({name: ovl.name ?? spc.name, id: id, castRank: spc.castRank}));\n    }\n      \n    spell_variants.sort((a, b) => {\n      if (a.lvl === b.lvl)\n        return a.name\n        .toUpperCase()\n        .localeCompare(b.name.toUpperCase(), undefined, {\n          sensitivity: \"base\",\n        });\n        return a.lvl - b.lvl;\n    });\n          \n          \n    // Build dialog data\n    const ovr_data = [\n      { label : `Choose a Spell Variant:`, type : `select`, options : spell_variants.map(p => p.name) }\n    ];\n                 \n    // Query user for variant choice\n    const variant_choice = await quickDialog({data : ovr_data, title : `Variants Detected`});\n        \n    // Obtain the ID of the chosen variant, then use that ID to fetch the modified spell\n    const vrId = spell_variants.find(x => x.name === variant_choice[0]).id;\n    const variant = spc.spell.loadVariant({castRank:spc.castRank, overlayIds:[vrId]});\n    spc.spell = variant;\n  }\n\n  let pers, critt;\n  if ( !spell_choice[2] ) {\n    critt = (await strike.attack({ event, callback: async(x) =>  { await(game.messages.contents.findLast(m => m.speaker.token === _token.id)).setFlag(\"world\",\"macro.spellUsed\", spc); }})).degreeOfSuccess;\n  }\n  else {\n    await game.pf2e.Check.rerollFromMessage(mes,{heroPoint:1});\n    critt = game.messages.contents.findLast(r => r.isReroll).rolls[0].degreeOfSuccess;\n  }\n      \n  let ttags = '';\n  for (const t of spc.traits) {\n    ttags += `<span class=\"tag\" data-trait data-tooltip=${t.description}>${t.value[0].toUpperCase() + t.value.substring(1)}</span>`\n  }\n\n  let dos;\n  let hit = false\n\n  if (critt === 2) { dos = 'Success'; hit = true }\n  if (critt === 3) { dos = 'Critical Success'; hit = true}\n      \n  // Automated Animations insertion by MrVauxs\n  if (game.modules.get(\"autoanimations\")?.active) {\n    AutomatedAnimations.playAnimation(token, {name: spc.name}, { targets: [Array.from(game.user.targets)[0]], hitTargets: hit ? [Array.from(game.user.targets)[0]] : []})\n  }\n\n  let flavName = ` cast at Rank ${spc.castRank}`;\n  if (spc.isCantrip) { flavName = ` Cantrip ${spc.castRank}`; }\n  if (spc.isFocus) { flavName = ` Focus ${spc.castRank}`; }\n  let flavor = `<strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})`;\n  if (spc.slug === null) { flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Eldritch Shot</strong><br>${flavName} [Custom Spell] (${dos})`; }\n  if (spc.isSave) {\n    flavor += `<br>@Check[type:${spc.save}|dc:${spc.DC}|traits:damaging-effect,${spc.traits.map(v => v.value).join()}|basic:${spc.basic}]`;\n  }\n\n  if (spc.slug === \"acid-splash\" && critt === 3) {\n    if(spc.castRank < 3) { flavor += `[[/r 1[persistent,acid]]]` }\n    else if(spc.castRank > 2 && spc.castRank < 5) { flavor += `[[/r 2[persistent,acid]]]` }\n    else if(spc.castRank > 4 && spc.castRank < 7) { flavor += `[[/r 3[persistent,acid]]]` }\n    else if(spc.castRank > 6 && spc.castRank < 9) { flavor += `[[/r 4[persistent,acid]]]` }\n    else { flavor += `[[/r 5[persistent,acid]]]` }\n  }\n  if (spc.slug === 'ignition' && critt === 3) {\n    pers = Math.ceil(actor.level / 2);\n    if (spc.spell.name.includes('Melee')) {\n      pers += 'd6';\n    }\n    else {\n      pers += 'd4';\n    }\n    flavor += `[[/r ${pers}[persistent,fire]]]`\n  }\n  if (spc.slug === 'produce-flame' && critt === 3) {\n      pers = Math.ceil(actor.level / 2) + \"d4\";\n      flavor += `[[/r ${pers}[persistent,fire]]]`\n  }\n  if (spc.slug === 'ray-of-frost' && critt === 3) {\n      flavor += `@UUID[Compendium.pf2e.spell-effects.I4PsUAaYSUJ8pwKC]{Spell Effect: Ray of Frost}`\n  }\n  if (spc.slug === 'gouging-claw' && critt === 3) {\n      pers = Math.ceil(actor.level / 2) + \"d4\";\n      flavor += `[[/r ${pers}[persistent,bleed]]]`\n  }\n  if(spc.slug === 'holy-light' || spc.slug === 'moonlight-ray'){\n    if (game.user.targets.first().actor.traits.has('undead') || game.user.targets.first().actor.traits.has('fiend')) {\n      const spRD = spc.spell.getRollData({castRank: spc.castRank});\n      spc.roll = (await spRD.item.getDamage()).template.damage.roll;\n      spc.roll = new DamageRoll(`{(${spc.roll.terms[0].rolls[0]._formula})[${spc.roll.terms[0].rolls[0].type}],(${(spc.castRank-3)*2 + 5}d6)[spirit]}`);\n      flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})`;\n    }\n  }\n  if(spc.slug === 'chilling-darkness'){\n    if (game.user.targets.first().actor.traits.has('holy')) {\n      const spRD = spc.spell.getRollData({castRank: spc.castRank});\n      spc.roll = (await spRD.item.getDamage()).template.damage.roll;\n      spc.roll = new DamageRoll(`{(${spc.roll.terms[0].rolls[0]._formula})[${spc.roll.terms[0].rolls[0].type}],(${(spc.castRank-3)*2 + 5}d6)[spirit]}`);\n      flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})`;\n    }\n  }\n\n  if (game.modules.get('xdy-pf2e-workbench')?.active && !game.settings.get(\"xdy-pf2e-workbench\",\"autoRollDamageForStrike\")) { \n    if (critt === 2) { await strike.damage({ event }); }\n    if (critt === 3){ await strike.critical({ event }); }\n  }\n  if(!game.modules.has('xdy-pf2e-workbench') || !game.modules.get('xdy-pf2e-workbench')?.active) { \n    if (critt === 2) { await strike.damage({ event }); }\n    if (critt === 3){ await strike.critical({ event }); }\n  }\n\n  /* Chromatic Ray */\n  if(spc.slug === 'chromatic-ray' && critt >= 2) {\n    flavor = `<div class=\"tags\">${ttags}`;\n    let ds = '';\n    let dsc = '';\n    if (token.actor.itemTypes.feat.some(s => s.slug === 'dangerous-sorcery')) { \n      ds = ` + ${spc.castRank}`; \n      dsc = ` + ${spc.castRank * 2}`\n    }\n    const chroma = [\n      {d:`{30${ds}}[fire]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionFire\">Fire</span></div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>1.<strong>Red</strong> (fire) The ray deals 30 fire damage to the target. Double on a Critical.</p>`,dd:`(60${dsc})[fire]`},\n      {d:`{40${ds}}[acid]`,f:`<span class=\"tag\" data-trait=\"acid\" data-description=\"PF2E.TraitDescriptionAcid\">Acid</span></div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>2.<strong>Orange</strong> (acid) The ray deals 40 acid damage to the target. Double on a Critical.</p>`,dd:`(80${dsc})[acid]`},\n      {d:`(50${ds})[electricity]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionElectricity\">Electricity</span></div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>3.<strong>Yellow</strong> <br>(electricity) The ray deals 50 electricity damage to the target. Double on a Critical.</p>`,dd:`(100${dsc})[electricity]`},\n      {d:`(25${ds})[poison]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionPoison\">Poison</span></div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>4.<strong>Green</strong> (poison) The ray deals 25 poison damage to the target, double on a Critical, and the target must succeed at a @Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light,poison] or be @Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 1} for 1 minute (@Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 2} on a critical failure).</p>`,dd:`(50${dsc})[poison]`},\n      {f:`</div><strong><hr>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>5.<strong>Blue</strong> The ray has the effect of the @Compendium[pf2e.spells-srd.Petrify]{Petrify} spell. On a critical hit, the target is @Compendium[pf2e.conditionitems.Clumsy]{Clumsy 1} as long as its slowed by the petrify effect.<br>@Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light]</p>`},\n      {f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionEmotion\">Emotion</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionIncapacitation\">Incapacitation</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionMental\">Mental</span></div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>6.<strong>Indigo</strong> (emotion, incapacitation, mental) The ray has the effect of the @Compendium[pf2e.spells-srd.Confusion]{Confusion} spell. On a critical hit, it has the effect of @Compendium[pf2e.spells-srd.Warp Mind]{Warp Mind} instead.<br>@Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light,emotion,incapacitation,mental]</p>`},\n      {f:`</div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>7.<strong>Violet</strong> <br>The target is @Compendium[pf2e.conditionitems.Slowed]{Slowed} for 1 minute. It must also succeed at a @Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light] or be teleported 120 feet directly away from you (if there isnt room for it to appear there, it appears in the nearest open space); this is a teleportation effect.</p>`},\n      {f:`</div><hr><strong>Eldritch Shot</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>8.<strong>Intense Color</strong> The target is @Compendium[pf2e.conditionitems.Dazzled]{Dazzled} until the end of your next turn, or @Compendium[pf2e.conditionitems.Blinded]{Blinded} if your attack roll was a critical hit. Roll again and add the effects of another color (rerolling results of 8).</p>`},\n    ];\n    let chromaD = '1d4';\n    if (spc.castRank > 5) { \n      chromaD = '1d8';\n      chroma[0].d = `(40${ds})[fire]`;\n      chroma[0].dd = `(80${dsc})[fire]`;\n      chroma[0].f = chroma[0].f.replace('30','40');\n      chroma[1].d = `(50${ds})[acid]`;\n      chroma[1].dd = `(100${dsc})[acid]`;\n      chroma[1].f = chroma[1].f.replace('40','50');\n      chroma[2].d = `(60${ds})[electricity]`;\n      chroma[2].dd = `(120${dsc})[electricity]`;\n      chroma[2].f = chroma[2].f.replace('50','60');\n      chroma[3].d = `(35${ds})[poison]`;\n      chroma[3].dd = `(70${dsc})[poison]`;\n      chroma[3].f = chroma[3].f.replace('25','35');\n    }\n    const chromaR = new Roll(chromaD).evaluate({async:false}).total;\n    if (chromaR < 5) { \n      ddice = chroma[chromaR-1].dd; \n      flavor = flavor + chroma[chromaR-1].f; \n      spc.roll = new DamageRoll(chroma[chromaR-1].d);\n      if (critt === 3) {\n        spc.roll = new DamageRoll(chroma[chromaR-1].dd);\n      }\n    }\n    if (chromaR > 4 && chromaR <= 7) { flavor = flavor + chroma[chromaR-1].f; await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc }}); }\n    if (chromaR === 8) {\n      const flavor2 = flavor + chroma[chromaR-1].f;\n      await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor2, flags: { \"world.macro.spellUsed\": spc }});\n      if (critt === 3) {\n        const chromaRR = new Roll('1d7').evaluate({async:false}).total;\n        if (chromaRR < 5) { flavor = flavor + chroma[chromaRR-1].f; spc.roll = new DamageRoll(chroma[chromaRR-1].dd); }\n        if (chromaRR > 4) { flavor = flavor + chroma[chromaRR-1].f; await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc }});}\n\t    }\n    }\n  }\n\n  const {item} = await spc.spell.getRollData({castRank: spc.castRank});\n  if (critt >= 2) {\n    if (spc.slug !== \"chromatic-ray\" && spc.roll === undefined && spc.formula === undefined) {\n      await item.toMessage(null, {speaker: ChatMessage.getSpeaker(), flags: { \"world.macro.spellUsed\": spc } })\n    }\n    if (critt === 3 && spc.slug !== \"chromatic-ray\") {  ui.notifications.info('Spell damage will need to be doubled when applied'); }\n    if ( spc.roll !== undefined ) {\n      await spc.roll.toMessage({ flavor: flavor, speaker: ChatMessage.getSpeaker(), flags: { \"world.macro.spellUsed\": spc } });\n    }\n    else { \n      await item.rollDamage({event});\n    }\n  }\n\n  /* Expend slots */\n  if (spc.isCantrip || spell_choice[2]) { return; }\n  await s_entry.cast(spc.spell,{slotId: spc.index,rank: spc.castRank,message: false});\n}\n/* Dialog box */\nasync function quickDialog({data, title = `Quick Dialog`} = {}) {\n  data = data instanceof Array ? data : [data];\n\n  return await new Promise(async (resolve) => {\n    let content = `\n      <table style=\"width:100%\">\n      ${data.map(({type, label, options}, i)=> {\n        if(type.toLowerCase() === `select`) {\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e,i)=> `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n        }\n        else if(type.toLowerCase() === `checkbox`){\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n        }\n        else{\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n        }\n      }).join(``)}\n      </table>`;\n\n      await new Dialog({\n        title, content,\n        buttons : {\n          Ok : { label : `Ok`, callback : (html) => {\n            resolve(Array(data.length).fill().map((e,i)=>{\n              let {type} = data[i];\n              if(type.toLowerCase() === `select`){\n                 return html.find(`select#${i}qd`).val();\n              }\n              else{\n                switch(type.toLowerCase()){\n                  case `text` :\n                  case `password` :\n                  case `radio` :\n                  return html.find(`input#${i}qd`)[0].value;\n                  case `checkbox` :\n                  return html.find(`input#${i}qd`)[0].checked;\n                  case `number` :\n                  return html.find(`input#${i}qd`)[0].valueAsNumber;\n                }\n              }\n            }));\n          }}\n        },\n        default : 'Ok'\n      },{width:\"auto\"})._render(true);\n        document.getElementById(\"0qd\").focus();\n    });\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Eldritch Shot.js\" - Fetched on 2024-06-05T17:22:21.769Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Eldritch Shot","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"uS7bKxtKndu66k4G","actorIds":[],"author":"r6q0a7cptuoWkJny","command":"/*\nTo use this macro, you just have to target someone and use it.\nAdded ability to reroll using a hero point when available.\nStandby Spell now supported, if you have the feat it will:\n1. Set a Standby Spell by calling to the Standby Spell macro, if one hasn't been set yet.\n2. Dynamically filter the drop down list to only include spells you can substitute or spells you can spellstrike with,\ndepending on the current state of the use standby spell toggle.\n*/\n\n/* Throw warning if token is not selected*/\nif (canvas.tokens.controlled.length < 1) { return void ui.notifications.warn('No token is selected.'); }\nif (canvas.tokens.controlled.length > 1) { return void ui.notifications.warn('Only 1 token should be selected'); }\nif (game.user.targets.size < 1) { return void ui.notifications.warn('Please target a token'); }\nif (game.user.targets.size > 1) { return void ui.notifications.warn('Spellstrike can only affect 1 target'); }\n\n/* Check for eldritch archer dedication and warn if not present */\nif (!token.actor.itemTypes.feat.some(e => [\"spellstriker\",\"spellstrike\"].includes(e.slug))) {\n  return void ui.notifications.warn('Does not have Spellstrike.');\n}\nconst ess = token.actor.itemTypes.feat.some(f => f.slug === 'expansive-spellstrike');\n\nconst DamageRoll = CONFIG.Dice.rolls.find(((R) => R.name === \"DamageRoll\"));\n\n/* Standby Spells */\nlet sbs = null;\nif (token.actor.itemTypes.feat.some(f => f.slug === 'standby-spell')) {\n  sbs = actor.itemTypes.spell.find(s => s.flags.pf2e.standbySpell);\n  if (!sbs) {\n    // Have feat, spell not set, use macro to set it\n    let macro = game.macros.find(n => n.name === \"Assign Standby Spell\");\n    if (!macro && game.modules.get('xdy-pf2e-workbench')?.active) {\n      macro = (await game.packs.get(\"xdy-pf2e-workbench.asymonous-benefactor-macros-internal\")?.getDocuments({name: 'XDY DO_NOT_IMPORT Assign Standby Spell'}))?.[0]?.toObject();\n      if (macro) {\n        macro = new Macro(macro);\n        macro.ownership.default = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;\n      }\n    }\n    if (macro) {\n      await macro.execute();\n      sbs = actor.itemTypes.spell.find(s => s.flags.pf2e.standbySpell);\n    }\n    else {\n      // They won't be able to use standby spell, but the rest of spellstrike works fine\n      ui.notifications.warn(\"You have not chosen your Standby Spell and will not be able to cast it.\");\n      ui.notifications.warn(\"Cannot choose a Standby Spell. You do not have the latest workbench version or it is not active, or the Assign Standby Spell macro is not available.\");\n    }\n  }\n}\n\nlet spells = await spellList(actor, sbs, ess);\nspells = spells.filter(s => !s.isExpended && !s.isUseless);\nif (spells.length === 0) { return void ui.notifications.info(\"You have no spells available\"); }\n\nconst choices = await SSDialog(actor, spells, sbs);\n\nlet last, mes;\nif (choices.reroll) {\n  mes = game.messages.contents.findLast( lus => lus.getFlag(\"world\",\"macro.spellUsed\") !== undefined && lus.token.id === token.id);\n  if (mes === undefined) return void ui.notifications.warn(\"There are no previously cast spells or strike has already been rerolled\");\n  if (actor.system.resources.heroPoints.value === 0) { return void ui.notifications.warn(\"You have no hero points left\")}\n  last = mes.getFlag(\"world\",\"macro.spellUsed\");\n  last.spell = actor.itemTypes.spell.find(s => s.slug === last.slug);\n}\n\n/* Get the strike actions */\nlet spc = last ?? choices.spell;\n\n// Combine spell slot from dialog with standby spell's spell data. Reroll data from a message has already had this done, skip for rerolls.\nif (choices.standby && !choices.reroll) {\n  const {isAttack, isSave, description, save, slug, traits, hasDamage} = await sbs.getChatData({},{castRank});\n  spc = mergeObject(spc, {\n    name: sbs.name, spId: sbs.id, slug, description, DC: save.value, spell: sbs, isSave, isAttack,\n    basic: sbs.system.defense?.save?.basic ?? false, traits, save: save.type ?? \"\", hasDamage\n  });\n}\nconst s_entry = token.actor.itemTypes.spellcastingEntry.find(e => e.id === spc.sEId);\n\n// spc.spell is the base spell, turn it into the exact variant spell here.\n// This includes both heightening (always) and selecting an action cost, damage type, etc. variant (sometimes)\nconst variantParams = {castRank: spc.castRank};\nif (spc.spell.hasVariants) {\n  let toName = spc.spell.overlays.contents[0].system?.time !== undefined ?\n    (vs) => `${vs.name} (${vs.actionGlyph} actions)` :\n    (vs) => vs.name;\n\n  const spell_variants = spc.spell.overlays.overrideVariants.map((spell) => ({name: toName(spell), spell}))\n  spell_variants.sort((a, b) => a.spell.sort - b.spell.sort);\n\n  // Build dialog data\n  const ovr_data = [\n    { label: \"Choose a Spell Variant: \", type: \"select\", options: spell_variants.map(p => p.name) }\n  ];\n\n  // Query user for variant choice\n  const variant_choice = await quickDialog({data : ovr_data, title : `Variants Detected`});\n\n  // Get the overlayIds value for the selected variant\n  const variantId = spell_variants.find(x => x.name === variant_choice[0]).spell.variantId;\n  variantParams.overlayIds = [variantId];\n}\n// Both castRank and overlayIds (if used) must be specified in one call to loadVariant()\nspc.spell = spc.spell.loadVariant(variantParams) ?? spc.spell;\nspc.hasDamage = !!await spc.spell.getDamage(); // May have changed due to variant selected\n\n// Roll Strike and set/get applicable data\nlet pers, critt;\nif (!choices.reroll) {\n  const roll = await choices.action.variants[choices.variant].roll({\n    event: choices.event,\n    callback: async (roll, res, msg) => {\n      msg.setFlag(\"world\",\"macro.spellUsed\", spc);\n      await msg.update({flavor: msg.flavor + \"Chosen Spell: \" + spc.spell.link});\n    }\n  });\n  critt = roll.degreeOfSuccess;\n}\nelse {\n  await game.pf2e.Check.rerollFromMessage(mes,{heroPoint:1});\n  critt = game.messages.contents.findLast(r => r.isReroll && r.speaker.token === mes.speaker.token).rolls[0].degreeOfSuccess;\n}\nlet ttags = '';\nfor (const t of spc.traits) {\n  ttags += `<span class=\"tag\" data-trait data-tooltip=${t.description}>${t.value[0].toUpperCase() + t.value.substring(1)}</span>`\n}\nlet dos;\nlet hit = false\n\nif (critt === 2) { dos = 'Success'; hit = true }\nif (critt === 3) { dos = 'Critical Success'; hit = true}\n\n// Automated Animations insertion by MrVauxs\nif (game.modules.get(\"autoanimations\")?.active) {\n  AutomatedAnimations.playAnimation(token, {name: spc.name}, { targets: [Array.from(game.user.targets)[0]], hitTargets: hit ? [Array.from(game.user.targets)[0]] : []})\n}\n\nlet flavName = ` cast at Rank ${spc.castRank}`;\nif (spc.isCantrip) { flavName = ` Cantrip ${spc.castRank}`; }\nif (spc.isFocus) { flavName = ` Focus ${spc.castRank}`; }\nlet flavor = `<strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})`;\nif (spc.slug === null) { flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Spellstrike</strong><br>${flavName} [Custom Spell] (${dos})`; }\nif (spc.isSave) {\n  flavor += `<br>@Check[type:${spc.save}|dc:${spc.DC}|traits:damaging-effect,${spc.traits.map(v => v.value).join()}|basic:${spc.basic}]`;\n}\n\nif (spc.slug === \"acid-splash\" && critt === 3) {\n  if(spc.castRank < 3) { flavor += `[[/r 1[persistent,acid]]]` }\n  else if(spc.castRank > 2 && spc.castRank < 5) { flavor += `[[/r 2[persistent,acid]]]` }\n  else if(spc.castRank > 4 && spc.castRank < 7) { flavor += `[[/r 3[persistent,acid]]]` }\n  else if(spc.castRank > 6 && spc.castRank < 9) { flavor += `[[/r 4[persistent,acid]]]` }\n  else { flavor += `[[/r 5[persistent,acid]]]` }\n}\nif (spc.slug === 'ignition' && critt === 3) {\n  pers = Math.ceil(actor.level / 2);\n  if (spc.spell.name.includes('Melee')) {\n    pers += 'd6';\n  }\n  else {\n    pers += 'd4';\n  }\n  flavor += `[[/r ${pers}[persistent,fire]]]`\n}\nif (spc.slug === 'produce-flame' && critt === 3) {\n  pers = Math.ceil(actor.level / 2) + \"d4\";\n  flavor += `[[/r ${pers}[persistent,fire]]]`\n}\nif (spc.slug === 'ray-of-frost' && critt === 3) {\n  flavor += `@UUID[Compendium.pf2e.spell-effects.I4PsUAaYSUJ8pwKC]{Spell Effect: Ray of Frost}`\n}\n\nif(spc.slug === 'chilling-darkness'){\n  if (game.user.targets.first().actor.traits.has('holy')) {\n    const spRD = spc.spell.getRollData({castRank: spc.castRank});\n    spc.roll = (await spRD.item.getDamage()).template.damage.roll;\n    spc.roll = new DamageRoll(`{(${spc.roll.terms[0].rolls[0]._formula})[${spc.roll.terms[0].rolls[0].type}],(${(spc.castRank-3)*2 + 5}d6)[spirit]}`);\n    flavor = `<div class=\"tags\">${ttags}<br><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})`;\n  }\n}\n\n// Auto roll damage unless the workbench setting exists and is on, in which case workbench will do it\nif (!(game.modules.get('xdy-pf2e-workbench')?.active && game.settings.get(\"xdy-pf2e-workbench\",\"autoRollDamageForStrike\"))) {\n  if (critt === 2) await choices.action.damage({ event: choices.event });\n  if (critt === 3) await choices.action.critical({ event: choices.event });\n}\n\n/* Chromatic Ray */\nif(spc.slug === 'chromatic-ray' && critt >= 2) {\n  flavor = `<div class=\"tags\">${ttags}`;\n  let ds = '';\n  let dsc = '';\n  if (token.actor.itemTypes.feat.some(s => s.slug === 'dangerous-sorcery')) {\n    ds = ` + ${spc.castRank}`;\n    dsc = ` + ${spc.castRank * 2}`\n  }\n  const chroma = [\n    {d:`{30${ds}}[fire]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionFire\">Fire</span></div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>1.<strong>Red</strong> (fire) The ray deals 30 fire damage to the target. Double on a Critical.</p>`,dd:`(60${dsc})[fire]`},\n    {d:`{40${ds}}[acid]`,f:`<span class=\"tag\" data-trait=\"acid\" data-description=\"PF2E.TraitDescriptionAcid\">Acid</span></div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>2.<strong>Orange</strong> (acid) The ray deals 40 acid damage to the target. Double on a Critical.</p>`,dd:`(80${dsc})[acid]`},\n    {d:`(50${ds})[electricity]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionElectricity\">Electricity</span></div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>3.<strong>Yellow</strong> <br>(electricity) The ray deals 50 electricity damage to the target. Double on a Critical.</p>`,dd:`(100${dsc})[electricity]`},\n    {d:`(25${ds})[poison]`,f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionPoison\">Poison</span></div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>4.<strong>Green</strong> (poison) The ray deals 25 poison damage to the target, double on a Critical, and the target must succeed at a @Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light,poison] or be @Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 1} for 1 minute (@Compendium[pf2e.conditionitems.Enfeebled]{Enfeebled 2} on a critical failure).</p>`,dd:`(50${dsc})[poison]`},\n    {f:`</div><strong><hr>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>5.<strong>Blue</strong> The ray has the effect of the @Compendium[pf2e.spells-srd.Petrify]{Petrify} spell. On a critical hit, the target is @Compendium[pf2e.conditionitems.Clumsy]{Clumsy 1} as long as its slowed by the petrify effect.<br>@Check[type:fortitude|dc:${spc.DC}|traits:arcane,attack,evocation,light]</p>`},\n    {f:`<span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionEmotion\">Emotion</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionIncapacitation\">Incapacitation</span><span class=\"tag\" data-trait data-description=\"PF2E.TraitDescriptionMental\">Mental</span></div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>6.<strong>Indigo</strong> (emotion, incapacitation, mental) The ray has the effect of the @Compendium[pf2e.spells-srd.Confusion]{Confusion} spell. On a critical hit, it has the effect of @Compendium[pf2e.spells-srd.Warp Mind]{Warp Mind} instead.<br>@Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light,emotion,incapacitation,mental]</p>`},\n    {f:`</div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>7.<strong>Violet</strong> <br>The target is @Compendium[pf2e.conditionitems.Slowed]{Slowed} for 1 minute. It must also succeed at a @Check[type:will|dc:${spc.DC}|traits:arcane,attack,evocation,light] or be teleported 120 feet directly away from you (if there isnt room for it to appear there, it appears in the nearest open space); this is a teleportation effect.</p>`},\n    {f:`</div><hr><strong>Spellstrike</strong><br>${spc.spell.link}${flavName} (${dos})<br><p class='compact-text'>8.<strong>Intense Color</strong> The target is @Compendium[pf2e.conditionitems.Dazzled]{Dazzled} until the end of your next turn, or @Compendium[pf2e.conditionitems.Blinded]{Blinded} if your attack roll was a critical hit. Roll again and add the effects of another color (rerolling results of 8).</p>`},\n  ];\n  let chromaD = '1d4';\n  if (spc.castRank > 5) {\n    chromaD = '1d8';\n    chroma[0].d = `(40${ds})[fire]`;\n    chroma[0].dd = `(80${dsc})[fire]`;\n    chroma[0].f = chroma[0].f.replace('30','40');\n    chroma[1].d = `(50${ds})[acid]`;\n    chroma[1].dd = `(100${dsc})[acid]`;\n    chroma[1].f = chroma[1].f.replace('40','50');\n    chroma[2].d = `(60${ds})[electricity]`;\n    chroma[2].dd = `(120${dsc})[electricity]`;\n    chroma[2].f = chroma[2].f.replace('50','60');\n    chroma[3].d = `(35${ds})[poison]`;\n    chroma[3].dd = `(70${dsc})[poison]`;\n    chroma[3].f = chroma[3].f.replace('25','35');\n  }\n  const chromaR = new Roll(chromaD).evaluate({async:false}).total;\n  if (chromaR < 5) {\n    ddice = chroma[chromaR-1].dd;\n    flavor = flavor + chroma[chromaR-1].f;\n    spc.roll = new DamageRoll(chroma[chromaR-1].d);\n    if (critt === 3) {\n      spc.roll = new DamageRoll(chroma[chromaR-1].dd);\n    }\n  }\n  if (chromaR > 4 && chromaR <= 7) { flavor = flavor + chroma[chromaR-1].f; await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc }}); }\n  if (chromaR === 8) {\n    const flavor2 = flavor + chroma[chromaR-1].f;\n    await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor2, flags: { \"world.macro.spellUsed\": spc }});\n    if (critt === 3) {\n      const chromaRR = new Roll('1d7').evaluate({async:false}).total;\n      if (chromaRR < 5) { flavor = flavor + chroma[chromaRR-1].f; spc.roll = new DamageRoll(chroma[chromaRR-1].dd); }\n      if (chromaRR > 4) { flavor = flavor + chroma[chromaRR-1].f; await ChatMessage.create({speaker: ChatMessage.getSpeaker(), content: flavor, flags: { \"world.macro.spellUsed\": spc }});}\n  \t}\n  }\n}\n\nif (critt === 1 && !spc.isAttack) {\n  await spc.spell.toMessage(null);\n}\nif (critt >= 2) {\n  if (spc.slug !== \"chromatic-ray\" && !spc.hasDamage && !spc.roll) {\n    await spc.spell.toMessage(null);\n  }\n  if (critt === 3 && spc.slug !== \"chromatic-ray\" && spc.isAttack) {  ui.notifications.info('Spell damage will need to be doubled when applied'); }\n  if ( spc.roll !== undefined ) {\n    await spc.roll.toMessage({ flavor: flavor, speaker: ChatMessage.getSpeaker(), flags: { \"world.macro.spellUsed\": spc } });\n  }\n  else {\n    await spc.spell.rollDamage(choices.event, choices.variant);\n  }\n}\n\n/* Expend slots */\nif (spc.isCantrip || choices.reroll) { return; }\nawait s_entry.cast(spc.spell, {slotId: spc.index, message: false});\n\n// Show the SpellStrike dialog, return a promise of a result object:\n// { spell: Entry of \"spells\" that was chosen\n//   action: StatisticModifier, attack to use\n//   variant: Integer, action's variant, i.e. MAP\n//   reroll: Boolean, do a hero point reroll?\n//   standby: Boolean, standby spell to be used\n//   event: PointerEvent, from the attack button click (i.e. shift-click vs normal)\n// }\nasync function SSDialog(actor, spells, sbs) {\n  const starlit = actor.itemTypes.feat.some(f => f.slug === 'starlit-span');\n  const template = \"systems/pf2e/templates/actors/character/partials/strike.hbs\";\n  const base = await actor.sheet.getData();\n  const filter = (a) => starlit || a.item.isMelee || a.altUsages.some(aa => aa.item.isMelee);\n  // Need to perserve original index value from the actor action list\n  const actions = new Map(base.data.actions.map((a, i) => [i, a]).filter(\n    a => a[1].visible && a[1].type === \"strike\" && a[1].item.isEquipped && filter(a[1])));\n  const attacksHtml = await Promise.all(Array.from(actions, ([index, action]) => renderTemplate(template, {...base, index, action})));\n\n  // Build dialog data\n  const label = (useSBS) => `Choose a Spell ${useSBS ? \"Slot to expend\" : \" to Cast\"}`;\n  const spellOptions = spells.map((s, i) => `<option value=\"${i}\">${s.name}</option>`);\n  const content = `\n  <style>\n  .spellstrike-macro\n  .actor.sheet.character section.window-content .attack-popout.actions {\n    margin: 0 0 0 0;\n  }\n  .spellstrike-macro\n  .actor.sheet.character section.window-content .attack-popout.actions ol.strikes-list li.strike\n  .item-name {\n    align-items: center;\n  }\n  .spellstrike-macro\n  .actor.sheet.character section.window-content .attack-popout.actions ol.strikes-list li.strike\n  div.auxiliary-actions {\n    display: none;\n  }\n  .spellstrike-macro\n  .actor.sheet.character section.window-content .attack-popout.actions ol.strikes-list li.strike\n  button.damage.tag {\n    display: none;\n  }\n  .spellstrike-macro\n  .actor.sheet.character section.window-content .attack-popout.actions ol.strikes-list li.strike\n  button.tag:disabled {\n    background-color: var(--color-text-dark-inactive);\n    cursor: not-allowed;\n    pointer-events: initial;\n  }\n  ${starlit ? \"\" : `\n  .spellstrike-macro\n  ol.strikes-list li.strike div.alt-usage:has(button[data-alt-usage=\"thrown\"]) {\n    display: none;\n  }`}\n  </style>\n\n  ${sbs ? `<p>Cast Standby Spell: <input type=\"checkbox\" id=\"standby\"> ${sbs.name}</p>` : \"\"}\n  <p align=\"center\"><label id=\"spell-choice-label\">${label(false)}</label></p>\n  <p><select style=\"width:100%; font-size:12px\" id=\"spell\">${spellOptions.join('')}</select></p>\n  <div class=\"actor sheet character\"><section class=\"window-content\"><div class=\"tab actions active attack-popout\">\n  <ol class=\"actions-list item-list directory-list strikes-list\" data-strikes>\n    ${attacksHtml.join(\"\\n\")}\n  </ol>\n  </div></section></div>\n  <p><label>Reroll using Hero Point:</label><input type=\"checkbox\" id=\"reroll\"/></p>\n  `;\n\n  const result = new Promise(async (resolve) => {\n    const dialog = new Dialog({\n      title: \"Spellstrike\",\n      content,\n      buttons : { },\n      render: (html) => {\n        const strikes = html.find(\"ol.strikes-list > li.strike.ready[data-strike]:not(.hidden)\")\n        // Disable ranged primary usage when !starlit.\n        if (!starlit) {\n          actions.forEach((a, i) => {\n            if (!a.item.isMelee) {\n              strikes.filter(`[data-action-index=${i}]`).find(\"div.item-name [data-action=strike-attack]\").\n                prop('disabled', true).click(e => e.stopImmediatePropagation()).\n                attr(\"data-tooltip\", \"Ranged strikes not allowed\");\n            }\n          });\n        }\n        // Handler for all the attack buttons to do a \"submit\" of the dialog\n        strikes.find(\"[data-action=strike-attack]\").on(\"click\", (event) => {\n          const button = $(event.delegateTarget);\n          const index = Number(button.parents('[data-action-index]').data('action-index'));\n          const variant = Number(button.data('variant-index'));\n          const altp = ({thrown: \"isThrown\", melee: \"isMelee\"})[button.data('alt-usage')];\n          const action = altp ? actions.get(index).altUsages.find(a => a.item?.[altp]) : actions.get(index);\n          const spell = spells[Number(html.find('#spell :selected').val())];\n          const reroll = html.find('#reroll')[0].checked;\n          const standby = html.find(\"#standby\")[0]?.checked ?? false;\n          dialog.close();\n          resolve({spell, action, variant, reroll, standby, event: event.originalEvent});\n        });\n        // Handler for toggle buttons, only versatile is supported\n        strikes.find(\"[data-action=toggle-weapon-trait]\").on(\"click\", async (event) => {\n          const button = $(event.delegateTarget);\n          const index = Number(button.parents('[data-action-index]').data('action-index'));\n          const action = actions.get(index);\n          const trait = button.data('trait');\n          if (trait === \"versatile\") {\n            const selected = button.val() === action.item.system.damage.damageType ? null : button.val();\n            await action.item.system.traits.toggles.update({trait, selected});\n            const toggles = button.parents(\"div.toggles\");\n            // actions is the data the dialog was made with, it doesn't update, but the actor does\n            actor.system.actions[index]?.versatileOptions.forEach(trait =>\n              toggles.find(`button.${trait.value}`).toggleClass(\"selected\", trait.selected).prop('disabled', trait.selected)\n            );\n          }\n        });\n        // Update spell choices for standby slot to expend vs casting for spellstrike\n        const updateChoices = (useSBS) => {\n          html.find(\"#spell-choice-label\").text(label(useSBS));\n          const choice = html.find(\"#spell\");\n          // Hide/unhide the spells that are standby expendable slots or strikeable spells\n          spells.forEach((s, i) => choice.find(`option[value=${i}]`).prop(\"hidden\", useSBS ? !s.standbyExpendable : !s.isStrikeable));\n          // If non-legal slot was picked, switch to the first legal one\n          const spell = spells[Number(choice.val())];\n          if (useSBS && !spell?.standbyExpendable) choice.val(spells.findIndex(s => s.standbyExpendable)).change();\n          if (!useSBS && !spell?.isStrikeable) choice.val(spells.findIndex(s => s.isStrikeable)).change();\n        };\n        updateChoices(false);\n        // Handler for standby checkbox\n        if (sbs) {\n          html.find(\"#standby\").on(\"click\", (event) => updateChoices(html.find(\"#standby\")[0].checked));\n        }\n      }\n    }, { classes: [\"dialog\", \"spellstrike-macro\", \"dui-limited-scope\"]});\n    await dialog.render(true);\n  });\n  return result;\n};\n\n// Return list of actor's spells.  Each object has a bunch of fields, which include:\n// isStrikeable: Can be used with spellstrike\n// standbyExpendable: Slot can be expended when using StandbySpell\nasync function spellList(actor, sbs, ess) {\n  // A bunch of these should be excluded because they are not AoE spells, but there area bunch of AoE spells\n  // with multiple area choices and the system encodes these as no area, so we consider no area as AoE and then\n  // fix the mistakes with this list.\n  const blacklist = new Set([\n    \"celestial-accord\",\n    \"shattering-gem\",\n    \"entangle-fate\",\n    \"behold-the-weave\",\n    \"compel-true-name\",\n    \"foul-miasma\",\n    \"invoke-the-harrow\",\n    \"rewrite-memory\",\n    \"subconscious-suggestion\",\n    \"excise-lexicon\",\n    \"enthrall\",\n    \"mind-reading\",\n    \"mirecloak\",\n    \"mask-of-terror\",\n    \"hallucination\",\n    \"hyperfocus\",\n    \"pact-broker\",\n    \"death-knell\",\n    \"sudden-recollection\",\n    \"favorable-review\",\n    \"litany-of-self-interest\",\n    \"suggestion\",\n    \"command\",\n    \"dj-vu\",\n    \"charming-touch\",\n    \"charm\",\n    \"possession\",\n    \"cornucopia\",\n    \"delay-affliction\",\n    \"heal-companion\",\n    \"natures-bounty\",\n    \"rebuke-death\",\n    \"wholeness-of-body\",\n    \"revival\"\n  ]);\n\n  // ESS, in addition to AoE spells, extends \"spell attacks\" to \"harmful spells that target a creature\".\n  // Most harmful spells that target a creature are attacks, but some aren't.  These are they:\n  const harmfulNonAttacks = new Set(['force-barrage', 'force-fang']);\n  const undead = [...game.user.targets.values()].some(t => t.actor.traits.has('undead'));\n  if (undead) harmfulNonAttacks.add('heal');\n  // Don't allow healing damage spells, unless they are also vitality and there is an undead target\n  const healing = (spell, data) => data.damage?.[0]?.kinds.has('healing') &&\n    !(undead && spell.traits.has('vitality'));\n\n  // Spells that ESS allows us to use, beyond spell attacks\n  const essAllowed = (spell, data) => harmfulNonAttacks.has(data.slug) || (\n    !data.target.value.includes('willing') && !healing(spell, data) && (\n      (data.target.value.includes(\"creature\") && data.hasDamage) ||\n      ([\"line\", \"cone\", \"burst\", undefined].includes(data.area?.type) && (data.hasDamage || data.isSave))\n    )\n  );\n  // \"1\", \"2\", \"2 to 2 rounds\", \"1 or 2\", etc.\n  const actionsAllowed = /^[12]( (or|to) .*)?$/;\n\n  const spells = [];\n  for (const e of actor.itemTypes.spellcastingEntry.filter(r => r.system.prepared?.value !== \"items\")) {\n    const spellData = await e.getSheetData();\n    for(const group of spellData.groups) {\n      let i = 0;\n      for (const active of group.active) {\n        const index = i++\n        if (active === null) { continue; }\n        const spell = active.spell;\n        const spellChatData = await spell.getChatData({}, {groupId: group.id});\n        const isStrikeable = (spell.isAttack || (ess && essAllowed(spell, spellChatData))) &&\n          actionsAllowed.test(spell.system.time?.value) && !blacklist.has(spell.slug);\n        const {castRank, isAttack, isSave, description, save, slug, traits, hasDamage} = spellChatData;\n\n        let rank = `Rank ${castRank}`\n        if(spellData.isPrepared) {\n          rank += ` |Slot: ${index + 1}|`\n        }\n        let lvl = castRank+1;\n        const name = spell.name;\n        if (spell.isCantrip) {\n          rank = `Cantrip ${castRank}`\n          lvl = 0;\n        }\n        if (spellData.isFocusPool) {\n          rank = `Focus ${castRank}`\n          lvl = 1;\n        }\n        const sname = `${name} ${rank} (${e.name})`;\n        spells.push({name: sname, castRank, sEId: spellData.id, slug, description, DC: save.value, spell, index, isSave, isAttack,\n          basic: spell.system.defense?.save?.basic ?? false, isCantrip: spell.isCantrip, isFocus: spellData.isFocusPool, traits,\n          save: save.type ?? \"\", lvl, hasDamage, isExpended: active.expended ?? false , isUseless: group.uses?.value < 1,\n          isStrikeable, standbyExpendable: !spell.isCantrip && castRank >= sbs?.baseRank\n        });\n      }\n    }\n  };\n  spells.sort((a, b) => {\n    if (a.lvl === b.lvl)\n      return a.name.toUpperCase().localeCompare(b.name.toUpperCase(), undefined, {sensitivity: \"base\"});\n      return a.lvl - b.lvl;\n  });\n\n  return spells;\n}\n\n/* Dialog box */\nasync function quickDialog({data, title = `Quick Dialog`} = {}) {\n  data = data instanceof Array ? data : [data];\n\n  return await new Promise(async (resolve) => {\n    let content = `\n      <table style=\"width:100%\">\n      ${data.map(({type, label, options}, i)=> {\n        if(type.toLowerCase() === `select`) {\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e,i)=> `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n        }\n        else if(type.toLowerCase() === `checkbox`){\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n        }\n        else{\n          return `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n        }\n      }).join(``)}\n      </table>`;\n\n    await new Dialog({\n      title, content,\n      buttons : {\n        Ok : { label : `Ok`, callback : (html) => {\n          resolve(Array(data.length).fill().map((e,i)=>{\n            let {type} = data[i];\n            if(type.toLowerCase() === `select`){\n               return html.find(`select#${i}qd`).val();\n            }\n            else{\n              switch(type.toLowerCase()){\n                case `text` :\n                case `password` :\n                case `radio` :\n                return html.find(`input#${i}qd`)[0].value;\n                case `checkbox` :\n                return html.find(`input#${i}qd`)[0].checked;\n                case `number` :\n              return html.find(`input#${i}qd`)[0].valueAsNumber;\n              }\n            }\n          }));\n        }}\n      },\n      default : 'Ok'\n    },{width:\"auto\"})._render(true);\n    document.getElementById(\"0qd\").focus();\n  });\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Spellstrike.js\" - Fetched on 2024-06-05T17:22:21.772Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Spellstrike","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"w6ZYdQpHPaHgGHWI","actorIds":[],"author":"7uBG1IMT3ePw3jLD","command":"/* This is a modded version of the Custom Saves macro originally created by Tik.\nThis version adds the ability to create a skill check aside from just saves.\nIt also handles level based saves and skill checks as well as difficulty adjustements for skill check.\nYou can either enter a level between 0 and 25 for an appropriate level based DC for saves and skills,\nor you can set a custom DC. The difficulty adjustment changes the difficulty by the appropriate amount as per RAW.\nSetting a difficulty adjustement will also change the custom DC that is set.\nIf no values are entered, the macro defaults to DC 10.\nIf the custom value and the level based DC are used simultaniously, the larger DC is used (before adjustment for skill checks)\nAdd whatever text you would like to post along with the check to chat in the flavor section.\nAdd traits to ensure applicable mods will trigger if needed.\n*/\n\nlet lvl = \"\";\nif (canvas.tokens.controlled.length === 1) { lvl = token.actor.level; }\nif (canvas.tokens.controlled.length > 1) { lvl = Math.max(...canvas.tokens.controlled.map(l => l.actor.level)); }\n\nconst ldc = [14,15,16,18,19,20,22,23,24,26,27,28,30,31,32,34,35,36,38,39,40,42,44,46,48,50];\n\nlet answer = \"\";\nasync function Answers(){\n    answer = await new Promise((resolve) => {\n        new Dialog({\n            title: \"To Journal or Message?\",\n            buttons:{\n                message: {\n                label: \"Message\",\n                callback: async() => { resolve('message') }\n                },\n                journal: {\n                label: \"Journal\",\n                callback: async() => { resolve('journal') }\n                },\n            },\n            default:'message'\n        }).render(true);\n    })\n}\n\nconst check = new Dialog({\n    title: \"Save or Skill Check?\",\n    buttons: {\n        yes: {\n            label: 'Custom Saves',\n            callback: customSaves,\n        },\n        no: {\n            label: 'Skill Checks',\n            callback: skillCheck,\n        },\n        cancel: {\n            label: 'Cancel',\n        },\n    },\n    default: 'yes',\n});\n\ncheck.render(true);\n\nasync function customSaves() {\nasync function postSave($html) {\n    const adjDif = parseInt($html.find('[name=\"adj\"]')[0].value);\n    const lbdc = parseInt($html.find('[name=\"lbdc\"]')[0].value);\n    const bst = $html.find('[name=\"bst\"]')[0].checked;\nconsole.log(bst);\n    if (lbdc > 25 || lbdc < 0) { return ui.notifications.warn(\"Level Based DC's are between level 0 and 25\"); }\n    let DC;\n    if (lbdc !== NaN) { DC = ldc[lbdc]; }\n    const dc = parseInt($html.find('[name=\"dc\"]')[0].value) || '';\n    if (DC === undefined && (dc === '' || dc < 0)) { DC = 10; }\n    if (dc !== '' && (dc > DC || DC === undefined)) { DC = dc; }\n    DC += adjDif;\n    const save = $html.find('[name=\"save\"]')[0].value || 'fortitude';\n    const traits = $html.find('[name=\"traits\"]')[0].value || '';\n    const flavor = $html.find('[name=\"flavor\"]')[0].value || '';\n    let content = `@Check[type:${save}|traits:${traits}|dc:${DC}|basic:${bst}]`;\n    content += (flavor) ? `{${flavor}}` : \"\";\n    await Answers();\n    if (answer === 'message') {\n        ChatMessage.create({\n            user: game.user.id,\n            content: content\n        });\n    }\n    if (answer === 'journal') {\n        if (!game.journal.some(j => j.name === \"Custom Saves and Skill Checks\")) {\n            await JournalEntry.create(new JournalEntry({_id:randomID(),name:\"Custom Saves and Skill Checks\", pages: [await(new JournalEntryPage({_id:randomID(),name:\"To Send to Chat\",text:{content}})).toObject()]}));\n            ui.notifications.info('New Jounral \"Custom Saves and Skill Checks\" created');\n        }\n        else { \n            const page = game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").pages.contents[0];\n            page.text.content += \"<br>\" + content;\n            await game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").updateEmbeddedDocuments(\"JournalEntryPage\",[page]);\n            await game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").render();\n            ui.notifications.info(`New Entry ${content} added to Custom Saves and Skill Checks journal`);\n        }\n    }\n}\n\nconst dialog = new Dialog({\n    title: 'New Save',\n    content: `\n        <form>\n        <div class=\"form-group\">\n        <label>Save type:</label>\n        <select id=\"save\" name=\"save\">\n        <option value=\"fortitude\">Fortitude</option>\n        <option value=\"reflex\">Reflex</option>\n        <option value=\"will\">Will</option>\n        </select>\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Basic Saving Throw?</label>\n        <input id=\"bst\" name=\"bst\" type=\"checkbox\" checked=\"checked\">\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Level based DC:</label>\n        <input id=\"lbdc\" name=\"lbdc\" type=\"number\" value=\"${lvl}\">\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Custom DC:</label>\n        <input id=\"dc\" name=\"dc\" type=\"number\"/>\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Adjust Difficulty:</label>\n        <select id=\"adj\" name=\"adj\">\n        <option value=0>None</option>\n        <option value=-10>Incredibly Easy</option>\n        <option value=-5>Very Easy</option>\n        <option value=-2>Easy</option>\n        <option value=2>Hard</option>\n        <option value=5>Very Hard</option>\n        <option value=10>Incredibly Hard</option>\n        </select>\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Flavor text:</label>\n        <textarea id=\"flavor\" name=\"flavor\"></textarea>\n        </div>\n        </form>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Traits (poison,fire,damaging-effect...):</label>\n        <input type=\"text\" id=\"traits\" name=\"traits\"></textarea>\n        </div>\n        </form>\n        `\n        ,\n    buttons: {\n        yes: {\n            label: 'Post Save',\n            callback: postSave,\n        },\n        no: {\n            label: 'Cancel',\n        },\n    },\n    default: 'yes',\n});\n\ndialog.render(true);\n}\nasync function skillCheck() {\n\nconst skillType = await new Promise((resolve) => {\nnew Dialog({\n    title: \"Which Skill?\",\n    buttons: {\n     acr: {\n      label: 'Acrobatics',\n      callback: async() => { resolve('acrobatics'); }\n     },\n     arc: {\n      label: 'Arcana',\n      callback: async() => { resolve('arcana'); },\n     },\n     ath: {\n      label: 'Athletics',\n      callback: async() => { resolve('athletics'); },\n     },\n     crf: {\n      label: 'Crafting',\n      callback: async() => { resolve('crafting'); },\n     },\n     dcp: {\n      label: 'Deception',\n      callback: async() => { resolve('deception'); },\n     },\n     dip: {\n      label: 'Diplomacy',\n      callback: async() => { resolve('diplomacy'); },\n     },\n     int: {\n      label: 'Intimidation',\n      callback: async() => { resolve('intimidation'); },\n     },\n     med: {\n      label: 'Medicine',\n      callback: async() => { resolve('medicine'); },\n     },\n     nat: {\n      label: 'Nature',\n      callback: async() => { resolve('nature'); },\n     },\n     occ: {\n      label: 'Occultism',\n      callback: async() => { resolve('occultism'); },\n     },\n     per: {\n      label: 'Performance',\n      callback: async() => { resolve('performance'); },\n     },\n     rel: {\n      label: 'Religion',\n      callback: async() => { resolve('religion'); },\n     },\n     soc: {\n      label: 'Society',\n      callback: async() => { resolve('society'); },\n     },\n     sth: {\n      label: 'Stealth',\n      callback: async() => { resolve('stealth'); },\n     },\n     sur: {\n      label: 'Survival',\n      callback: async() => { resolve('survival'); },\n     },\n     thi: {\n      label: 'Thievery',\n      callback: async() => { resolve('thievery'); },\n     },\n    },\n }).render(true);\n});\n\nasync function postSkill($html) {\n    const adjDif = parseInt($html.find('[name=\"adj\"]')[0].value);\n    const lbdc = parseInt($html.find('[name=\"lbdc\"]')[0].value);\n    if (lbdc > 25 || lbdc < 0) { return ui.notifications.warn(\"Level Based DC's are between level 0 and 25\"); }\n    let DC;\n    if (lbdc !== NaN) { DC = ldc[lbdc]; }\n    const dc = parseInt($html.find('[name=\"dc\"]')[0].value) || '';\n    if (DC === undefined && (dc === '' || dc < 0)) { DC = 10; }\n    if (dc !== '' && (dc > DC || DC === undefined)) { DC = dc; }\n    const traits = $html.find('[name=\"traits\"]')[0].value || '';\n    const flavor = $html.find('[name=\"flavor\"]')[0].value || '';\n    DC += adjDif;\n    let content = `@Check[type:${skillType}|traits:${traits}|dc:${DC}]`;\n    content += (flavor) ? `{${flavor}}` : \"\";\n\n    await Answers();\n    if (answer === 'message') {\n        ChatMessage.create({\n            user: game.user.id,\n            content: content\n        });\n    }\n    if (answer === 'journal') {\n        if (!game.journal.some(j => j.name === \"Custom Saves and Skill Checks\")) {\n            await JournalEntry.create(new JournalEntry({_id:randomID(),name:\"Custom Saves and Skill Checks\", pages: [await(new JournalEntryPage({_id:randomID(),name:\"To Send to Chat\",text:{content}})).toObject()]}));\n            ui.notifications.info('New Jounral \"Custom Saves and Skill Checks\" created');\n        }\n        else { \n            const page = game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").pages.contents[0];\n            page.text.content += \"<br>\" + content;\n            await game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").updateEmbeddedDocuments(\"JournalEntryPage\",[page]);\n            await game.journal.find(x => x.name === \"Custom Saves and Skill Checks\").render();\n            ui.notifications.info(`New Entry ${content} added to Custom Saves and Skill Checks journal`);\n        }\n    }\n}\n\nconst dialog = new Dialog({\n    title: 'New Skill Check',\n    content: `\n        <form>\n        <div class=\"form-group\">\n        <label>Level based DC:</label>\n        <input id=\"lbdc\" name=\"lbdc\" type=\"number\" value=\"${lvl}\">\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Custom DC:</label>\n        <input id=\"dc\" name=\"dc\" type=\"number\"/>\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Adjust Difficulty:</label>\n        <select id=\"adj\" name=\"adj\">\n        <option value=0>None</option>\n        <option value=-10>Incredibly Easy</option>\n        <option value=-5>Very Easy</option>\n        <option value=-2>Easy</option>\n        <option value=2>Hard</option>\n        <option value=5>Very Hard</option>\n        <option value=10>Incredibly Hard</option>\n        </select>\n        </div>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Flavor text:</label>\n        <textarea id=\"flavor\" name=\"flavor\"></textarea>\n        </div>\n        </form>\n        </form>\n        <form>\n        <div class=\"form-group\">\n        <label>Traits (poison,fire,...):</label>\n        <input type=\"text\" id=\"traits\" name=\"traits\"></textarea>\n        </div>\n        </form>\n        `\n        ,\n    buttons: {\n        yes: {\n            label: 'Post Check',\n            callback: postSkill,\n        },\n        no: {\n            label: 'Cancel',\n        },\n    },\n    default: 'yes',\n});\n\ndialog.render(true);\n}\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Custom Saves and Skill Checks.js\" - Fetched on 2024-06-05T17:22:21.768Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Custom Saves and Skill Checks","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"wHYM9zS2xLmrOKiy","actorIds":[],"author":"3yL25sPSEyMoxCJh","command":"/*\n!!THIS MACRO DOES BOTH LINGERING COMPOSITION AND/OR FORTISSIMO COMPOSITION WHEN THE APPROPRIATE FEATS ARE PRESENT!!\nTo use this macro, you need to have the lingering composition feat on your character sheet or have Bard Dedication with the fortissimo composition feat.\nTo use fortissimo composition, you must have the fortissimo composition feat on your character sheet.\nIf you do not have lingering composition due to taking the bard dedication and skipping the feat, the checkbox will be permanently enabled and the spells will be filtered only to those that can be used by Fortissimo Composition.\nThis macro requires Workbench module. The macro will automatically use the effects in the workbench compendium.\n*/\n\nif(!game.modules.get(\"xdy-pf2e-workbench\")?.active) { return ui.notifications.error(\"This Macro requires PF2e Workbench module\")}\nif (!actor || token.actor.type !== 'character') { return ui.notifications.warn(\"You must have a PC token selected\"); }\nif (!token.actor.itemTypes.feat.some(lc => lc.slug === \"lingering-composition\") && ( !token.actor.itemTypes.feat.some(s => s.slug === 'fortissimo-composition') && !token.actor.itemTypes.feat.some(s => s.slug === 'bard-dedication') ) ) { return ui.notifications.warn(\"The actor does not possess the Lingering Composition feat or does not have the Bard dedication with Lingering or Fortissimo Composition feats.\"); }\nif (actor.system.resources.focus.value === 0 || actor.system.resources.focus.value === undefined) { return ui.notifications.warn(\"You have no focus points\"); }\n\nconst modifiers = [];\nconst notes = [];\nconst skillName = \"Performance\";\nconst skillKey = \"prf\";\nlet actionSlug = \"lingering-composition\";\nlet actionName = \"Lingering Composition\";\nconst options = token.actor.getRollOptions(['all', 'skill-check', skillName.toLowerCase()]);\n      \nlet cantrips = token.actor.itemTypes.spell.filter(s=> s.isFocusSpell === true && s.isCantrip === true && s.traits.has('composition') && s.system.duration.value === '1 round');\n\nif (!token.actor.itemTypes.feat.some(lc => lc.slug === \"lingering-composition\")) { cantrips = cantrips.filter(s => [\"rallying-anthem\", \"courageous-anthem\", \"song-of-strength\"].includes(s.slug)) }   \n      \nconst lc_data = [\n\t{ label: `Choose a Spell : `, type: `select`, options: cantrips.map(p=> p.name) },\n\t{ label: `Custom DC : `, type: `number`}\n];\n\nif (token.actor.itemTypes.feat.some(s => s.slug === 'fortissimo-composition')) {\n\tlet options = `style=\"margin:auto;display:block\"`\n\tif (!token.actor.itemTypes.feat.some(lc => lc.slug === \"lingering-composition\")) { options += ' checked disabled' }\n\tlc_data.push( { label: `Fortissimo Composition (Rallying Anthem, Courageous Anthem, and Song of Strength Only) : `, type: `checkbox`, options } ) \n}     \n\nconst {choice, event} = await quickDialog({data: lc_data, title: `Lingering Composition`});\n      \nconst cast_spell = token.actor.itemTypes.spell.find(e => e.name === choice[0]);\nconst slug = cast_spell.slug;\n\nlet cs,suc;\nconst effectcom = game.packs.find(sp => sp.collection === \"pf2e.spell-effects\");\nconst effects = await effectcom.getIndex({fields:[\"system.slug\"]});\nlet effect = effects.some(e => e.system.slug.includes(slug)) ? effects.find(e => e.system.slug.includes(slug)) : \"\";\nif (choice[2]) {\n\tif (choice[0] === 'Courageous Anthem' || choice[0] === 'Rallying Anthem' || choice[0] === 'Song of Strength') {  \n    \tactionSlug = \"fortissimo-composition\";\n    \tactionName = \"Fortissimo Composition\";\n\t\toptions.push(`action:${actionSlug}`);\n\t\tif (slug === \"courageous-anthem\") {\n\t\t\tcs = \"Compendium.pf2e.spell-effects.Item.VFereWC1agrwgzPL\";\n\t\t\tsuc = \"Compendium.pf2e.spell-effects.Item.kZ39XWJA3RBDTnqG\";\n\t\t}\n\t\tif (slug === \"rallying-anthem\") {\n\t\t\tcs = \"Compendium.pf2e.spell-effects.Item.BKam63zT98iWMJH7\";\n\t\t\tsuc = \"Compendium.pf2e.spell-effects.Item.Chol7ExtoN2T36mP\";\n\t\t}\n\t\tif (slug === \"song-of-strength\") {\n\t\t\tcs = \"Compendium.pf2e.spell-effects.Item.8XaSpienzVXLmcfp\";\n\t\t\tsuc = \"Compendium.pf2e.spell-effects.Item.Fjnm1l59KH5YJ7G9\";\n\t\t}\n\t\tif (effect !== ''){\n\t\t\tnotes.push({\"outcome\":[\"success\"], \"selector\":\"performance\", \"text\":`<p>@UUID[${suc}]</p>`});\n    \t\tnotes.push({\"outcome\":[\"criticalSuccess\"], \"selector\":\"performance\", \"text\":`<p>@UUID[${cs}]</p>`});\n    \t\tnotes.push({\"outcome\":[\"failure\",\"criticalFailure\"], \"selector\":\"performance\", \"text\":`<p>@UUID[${effect.uuid}] You don't spend the Focus Point for casting the spell</p>`});\n\t\t}\n\t}\n\telse { \n\t\treturn void ui.notifications.warn('Fortissimo Composition is only applicable to Inspire Courage, Rallying Anthem, or Song of Strength');\n\t}\n}\nelse {\n\tnotes.push({\"outcome\":[\"success\"], \"selector\":\"performance\", \"text\":`The composition lasts 3 rounds`});\n    notes.push({\"outcome\":[\"criticalSuccess\"], \"selector\":\"performance\", \"text\":`The composition lasts 4 rounds`});\n\tnotes.push({\"outcome\":[\"failure\",\"criticalFailure\"], \"selector\":\"performance\", \"text\":`The composition lasts 1 round, but you don't spend the Focus Point for casting this spell`});\n}\n      \nlet DCbyLevel = [14,15,16,18,19,20,22,23,24,26,27,28,30,31,32,34,35,36,38,39,40,42,44,46,48,50]\n      \nlet level;\nlet levels = [];\nlet willDCs = [];\nconst tokens = canvas.tokens.placeables.filter(t => token.distanceTo(t) <= 60 && !t.actor?.hasCondition(\"defeaned\"));\nif (choice[0] === 'Dirge of Doom') {\n  options.push(`secret`)\n  levels = tokens.filter(f => f.actor?.type === \"npc\" && !f.actor?.hasPlayerOwner && token.distanceTo(f) <= 30).map(l => l.actor.level);\n  if (levels.length === 0) { return ui.notifications.warn('There are no enemies within range'); }\n  else { level = Math.max(...levels); }\n}\nelse { \n\tlevels = tokens.filter(pc => pc?.actor?.hasPlayerOwner && pc?.actor?.type === \"character\").map(l => l.actor.level);\n    willDCs = tokens.filter(pc => pc?.actor?.hasPlayerOwner && pc?.actor?.type === \"character\").map(l => l.actor.saves.will.dc.value);\n\tlevel = Math.max(...levels);\n}\n\n\nif (level < 0) { level = 0 }      \nlet DC;\nif ( isNaN(choice[1]) ) { \n\tif (choice[2]) {\n    DC = Math.max(...willDCs); \n  }\n\telse { DC = DCbyLevel[level]; }\n}\nelse { DC = choice[1]; }\n      \nasync function quickDialog({data, title = `Quick Dialog`} = {}) {\n\tdata = data instanceof Array ? data : [data];\n      \n\treturn await new Promise(async (resolve) => {\n\t  let content = `\n\t\t<table style=\"width:100%\">\n\t\t${data.map(({type, label, options, style}, i)=> {\n\t\t\tif(type.toLowerCase() === `select`) {\n\t\t  \treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select id=\"${i}qd\">${options.map((e,i)=> `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n\t\t\t}\n\t\t\telse if(type.toLowerCase() === `checkbox`){\n\t\t  \treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n\t\t\t}\n\t\t\telse{\n\t\t  \treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" style=\"margin:auto;display:block;width:15%;text-align:center\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options} ${style || \"\"}\"/></td></tr>`;\n\t\t\t}\n\t\t}).join(``)}\n\t  </table>`;\n      \n\t  await new Dialog({\n\t    title, content,\n\t    buttons : {\n\t\t \t\tOk : { label : `Ok`, callback : (html, event) => {\n\t\t   \t\tresolve({choice:Array(data.length).fill().map((e,i)=>{\n\t\t     \t\tlet {type} = data[i];\n\t\t     \t\tif(type.toLowerCase() === `select`) {\n\t\t       \t\treturn html.find(`select#${i}qd`).val();\n\t\t     \t\t}\n\t\t\t\t\t\telse{\n\t\t       \t\tswitch(type.toLowerCase()) {\n\t\t\t \t\t\t\t\tcase `text` :\n\t\t\t \t\t\t\t\tcase `password` :\n\t\t\t \t\t\t\t\tcase `radio` :\n\t\t\t \t\t\t\t\treturn html.find(`input#${i}qd`)[0].value;\n\t\t\t\t\t\t\t\tcase `checkbox` :\n\t\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].checked;\n\t\t\t\t\t\t\t\tcase `number` :\n\t\t\t\t\t\t\t\treturn html.find(`input#${i}qd`)[0].valueAsNumber;\n\t\t      \t\t}\n\t\t    \t\t}\n\t\t  \t\t}), event});\n\t\t\t\t}}\n\t    },\n\t\tdefault: \"Ok\",\n\t  },{width:\"400\"})._render(true);\n\t  document.getElementById(\"0qd\").focus();\n\t});\n}\nlet aura = (await fromUuid(\"Compendium.xdy-pf2e-workbench.xdy-pf2e-workbench-items.Item.KIPV1TiPCzlhuAzo\")).toObject();\nif ( effect.slug === \"spell-effect-rallying-anthem\" ) {\n\taura = (await fromUuid(\"Compendium.xdy-pf2e-workbench.xdy-pf2e-workbench-items.Item.tcnjhVxyRchqjt71\")).toObject();\n}\nif (choice[0] === \"Dirge of Doom\") {\n  aura = (await fromUuid(\"Compendium.xdy-pf2e-workbench.xdy-pf2e-workbench-items.Item.wOcAf3pf04cTM4Uk\")).toObject();\n}\nif (effect === \"\" && choice[0] !== \"Dirge of Doom\") {\n\taura.system.rules[0] = {key: \"Aura\", radius: 60, slug:\"is-aura-effect\" }\n}\nelse if (choice[0] !== \"Dirge of Doom\") { aura.system.rules[0].effects[0].uuid = effect.uuid; }\naura.system.duration.value = 1;\naura.system.duration.unit = \"rounds\"\naura.img = cast_spell.img;\naura.name = `Aura: ${actionName} (${choice[0]})`\naura.slug = `aura-${actionSlug}`\naura.system.rules[0].level = Math.ceil(actor.level/2);\naura.system.level.value = Math.ceil(actor.level/2);\nif (cs !== undefined) {\n\taura.img = \"systems/pf2e/icons/spells/inspire-heroics.webp\"\n}\n\nconst roll = await game.pf2e.Check.roll(\n\tnew game.pf2e.CheckModifier(\n\t  `<span class=\"pf2-icon\">A</span> <b>${actionName}</b><br><i>${choice[0]}</i> - <p class=\"compact-text\">${skillName } Skill Check</p>`,\n\t  token.actor.skills.performance, modifiers \n\t), { actor: token.actor, type: 'skill-check', options, notes, dc: { value: DC }}, event);\n\nif (roll.options.degreeOfSuccess === 3) {\n\tif(choice[2] && effect !== undefined) {\n\t\taura.system.rules[0].effects[0].uuid = cs;\n\t}\n\telse {\n\t\taura.system.duration.value = 4\n\t}\n}\nif (roll.options.degreeOfSuccess === 2) {\n\tif(choice[2] && effect !== undefined) {\n\t\taura.system.rules[0].effects[0].uuid = suc;\n\t}\n\telse {\n\t\taura.system.duration.value = 3\n\t}\n}\nawait token.actor.createEmbeddedDocuments(\"Item\",[aura]);\nif (roll.options.degreeOfSuccess > 1) { \n  const currentpoints = actor.system.resources.focus.value-1;\n  await actor.update({\"system.resources.focus.value\":currentpoints});\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Lingering Fortissimo.js\" - Fetched on 2024-06-05T17:22:21.770Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Lingering Fortissimo","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"wWYlvDGN4mPQZQqC","actorIds":[],"author":"GTFeJzrqpfcyGkFg","command":"/*\nWelcome to the Conditions Manager.\nThis macro was designed to have a window that can be minimized when not needed or opened whenever to manage conditions.\nIt is mostly intended for those who want an easy to read condition manager without the need for modules.\nAll conditions are toggled on and off by having the tokens selected that you would apply the condition to and clicking the\nname of the condition. If the condition can have a value, simply click the + to increase the value or the - to decrease.\nThe Clear a condition button is used to clear a specific condition off of a group of selected tokens.\nThis macro is loosely adapted from the Apply Conditions macro created by cepvep.\nCSS design by websterguy\nAdded the ability to add Timed Effects that grant conditions for a specific amount of time.\nHave the actor causing the effect selected and the ones the effect it being placed on targeted when in combat.\nAdded a checkbox to use Player's targets if in an active combat and the selected token is playerOwned.\nAdded the ability to clear all conditions on selected tokens.\nPreselect targets(combat)/selected(outside of combat) tokens since the second dialog will not catch changes.\n*/\n\nconst condition_list = CONFIG.PF2E.conditionTypes;\n\nconst wV = [\n\t\"clumsy\",\n\t\"doomed\",\n\t\"drained\",\n\t\"dying\",\n\t\"enfeebled\",\n\t\"frightened\",\n\t\"sickened\",\n\t\"slowed\",\n\t\"stunned\",\n\t\"stupefied\",\n\t\"wounded\",\n];\n\nconst nF = [];\nconst script1 = async function CToggle(c) {\n  for(const token of canvas.tokens.controlled) {\n    if (token.actor === null) { ui.notifications.warn(`${token.name} does not have an actor or is broken`); continue; }\n    if (token.actor.itemTypes.condition.some(p => p.slug === c && p.system.references.parent !== undefined)) { continue; }\n    if (token.actor !== null) { await token.actor.toggleCondition(c); }\n  }\n};\n\nconst script2 = async function ICon(c) {\n  for(const token of canvas.tokens.controlled) {\n    if (token.actor === null) { ui.notifications.warn(`${token.name} does not have an actor or is broken`); continue; }\n    if (token.actor !== null) { await token.actor.increaseCondition(c); }\n  }\n};\n\nconst script3 = async function DCon(c) {\n  for(const token of canvas.tokens.controlled) {\n    if (token.actor === null) { ui.notifications.warn(`${token.name} does not have an actor or is broken`); continue; }\n    if (token.actor !== null) { await token.actor.decreaseCondition(c); }\n  }\n};\n\nconst script4 = async function CCon() {\n  async function Clear(html) {\n    const c = html.find(\"#condition\")[0].value;\n    for(const token of canvas.tokens.controlled) {\n      if (token.actor === null) { ui.notifications.warn(`${token.name} does not have an actor or is broken`); continue; }\n      if (!token.actor.itemTypes.condition.some(p => p.slug === c) || token.actor.itemTypes.condition.some(p => p.slug === c && p.system.references.parent !== undefined)) { continue; }\n      if (token.actor !== null) { await token.actor.toggleCondition(c); }\n    }\n  }\n  const cons = []; \n  for (const t of canvas.tokens.controlled) {\n    for ( const c of t.actor.itemTypes.condition) {\n      if (c.system.references.parent !== undefined) { return; }\n      cons.push(c.slug);\n    };\n  };\n  const ccon = [...new Set(cons)].sort();\n  if (ccon.length === 0) { return ui.notifications.info(\"No conditions to clear at this time.\") }\n  if (ccon.length === 1) { \n    for(const token of canvas.tokens.controlled) {\n      if(token.actor.hasCondition(ccon[0])) {\n        await token.actor.toggleCondition(ccon[0]); \n      }\n    }\n  }\n  else{\n    let choices = '';\n    ccon.forEach( cc => { choices += `<option value=\"${cc}\">${cc[0].toUpperCase() + cc.substring(1)}</option>`; });\n    new Dialog({\n      title: \"Condition to clear from tokens\",\n      content: `<p>Choose condition to clear from selected tokens: <select id=\"condition\">${choices}</select>`,\n      buttons: {\n        ok: {\n          label: \"Ok\",\n          callback: (html) => {\n            Clear(html);\n          },\n        },\n        cancel: {\n          label: \"Cancel\",\n        },\n      },\n      default: \"cancel\",\n    }).render(true);\n  }\n}\n\nconst script5 = async function CConAll() {\n  for (const t of canvas.tokens.controlled) {\n    for ( const c of t.actor.items ) {\n      if ( c.type === \"condition\" ) {\n        await c.delete();\n      }\n    }\n  }\n}\n\nconst script6 = async function TCon() {\n  if (canvas.tokens.controlled.length === 0) { return void ui.notifications.warn(\"No token selected\") }\n  if (canvas.tokens.controlled.length > 1 && game.combats.active?.started ) { return void ui.notifications.warn(\"Only one originating token can be selected at a time\") }\n  const actor = canvas.tokens.controlled[0].actor;\n  let targets = game.user.targets.ids;\n  let player, playerTargets = [];\n  if (game.user.isGM && actor.hasPlayerOwner) {\n    player = game.users.find(f => f.active && f.id === Object.entries(actor.ownership).find( o => o[0] !== game.userId && o[1] === 3 )[0]);\n    playerTargets = player?.targets?.ids ?? [];\n  }\n  if (!game.user.isGM && canvas.tokens.placeables.filter(t => t.actor.isOwner && targets.includes(t.id)).length === 0) { return void ui.notifications.warn(\"You do not own any of the targeted tokens\") }\n  else if (!game.user.isGM && canvas.tokens.placeables.filter(t => t.actor.isOwner && targets.includes(t.id)).length !== targets.length) {\n    targets = canvas.tokens.placeables.filter(t => t.actor.isOwner && targets.includes(t.id)).map(i => i.id);\n    void ui.notifications.info(`You cannot affect some targeted tokens because you do not own them`)\n  }\n  if (targets.length === 0 && game.combats.active?.started ) { \n    return void ui.notifications.warn(\"At least one target for timed condition is required\");\n  }\n\n  const con_list = CONFIG.PF2E.conditionTypes;\n  const w_V = [\n\t\"clumsy\",\n\t\"doomed\",\n\t\"drained\",\n\t\"enfeebled\",\n\t\"frightened\",\n\t\"sickened\",\n\t\"slowed\",\n\t\"stunned\",\n\t\"stupefied\",\n  ];\n\n  async function Xtml(html) { \n    const values = [html.find(\"#condition\")[0].value, html.find(\"#conval\")[0].valueAsNumber, html.find(\"#time\")[0].valueAsNumber, html.find(\"#times\")[0].value, html.find(\"#check\")[0].checked];\n    if (game.user.isGM && playerTargets.length > 0 && game.combats.active?.started) {\n      values.push(html.find(\"#check2\")[0].checked)\n    }\n    return values;\n  }\n\n  let conditions;\n  for ( const l in con_list ) {\n    conditions += `<option value=${l}>${game.i18n.localize(con_list[l])}</option>`;\n  }\n\n  let content = `<div class=\"timetable1\"><table>\n                  <tr><td>Choose condition:</td> <td><select id=\"condition\" autofocus>${conditions}</select></td> <td style=\"text-align:center\">Value(If applicable)</td><td width=\"8%\"><input id=\"conval\" type=\"number\" value=1 style=\"text-align:center\"></input></td></tr></table>\n                  <table><tr><td>Choose duration:</td> <td width=\"8%\"><input id=\"time\" type=\"number\" style=\"text-align:center\" value=1></input></td>\n                      <td><select id=\"times\">\n                        <option value=rounds>Rounds</option>\n                        <option value=minutes>Minutes</option>\n                        <option value=hours>Hours</option>\n                        <option value=days>Days</option>\n                      </select></td>\n                      <td style=\"text-align:center\">End of Turn?</td><td><input id=\"check\" type=\"checkbox\"></td>`\n  if (game.user.isGM && playerTargets.length > 0 && game.combats.active?.started) {\n      content += `<td style=\"text-align:center\">Use Player's Targets?</td><td><input id=\"check2\" type=\"checkbox\"></td>`; \n    }\n  content += `</tr></table></div>`;\n\n  const tcon = await Dialog.prompt({\n      title: \"Timed condition to place on tokens\",\n      content,\n      callback: async html => await Xtml(html),\n      rejectClose: true,\n  });\n\n  if (tcon[5]) {\n      targets = playerTargets;\n      ui.notifications.info(`Using ${player.name}'s targets.`)\n  }\n\n  let name = `Effect: ${game.i18n.localize(con_list[tcon[0]])} for ${tcon[2]} ${tcon[3]}`;\n  const pack = game.packs.get(\"pf2e.conditionitems\");\n  const index = await pack.getIndex({fields:[\"system.slug\"]});\n  const uuid = index.find(n => n.system.slug === tcon[0]).uuid;\n  const initiative = game.combats.active?.started ? canvas.tokens.controlled[0].combatant.initiative : null;\n  const actorUuid = actor.uuid;\n  \n  let alterations;\n  if ( w_V.includes(tcon[0]) ) {\n    name = `Effect: ${game.i18n.localize(con_list[tcon[0]])} for ${tcon[2]} ${tcon[3]}`;\n    alterations = [\n    {\n      \"mode\": \"override\",\n      \"property\": \"badge-value\",\n      \"value\": tcon[1]\n    }\n    ];\n  }\n\n  const effect = {\n    type: 'effect',\n    name,\n    img: `systems/pf2e/icons/conditions/${tcon[0]}.webp`,\n    system: {\n      context: {\n        origin: {\n          actor: actorUuid,\n        },\n      },\n      tokenIcon: {\n          show: false\n      },       \n      duration: {\n          value: tcon[2],\n          unit: `${tcon[3]}`,\n          sustained: false,\n          expiry: 'turn-start'\n      },\n      rules: [\n        {\n          \"key\": \"GrantItem\",\n          \"onDeleteActions\": {\n              \"grantee\": \"restrict\"\n          },\n          uuid,\n        }\n      ],\n      start: {\n        initiative,\n      }\n    },\n  };\n\n  if ( alterations !== undefined ) {\n    effect.system.rules[0].alterations = alterations;\n  }\n  if ( tcon[4] ) {\n    effect.system.duration.expiry = \"turn-end\";\n  }\n  if (game.combats.active?.started) {\n    for ( const t of targets ) {\n      const tok = canvas.tokens.placeables.find(i => i.id === t);\n      await tok.actor.createEmbeddedDocuments(\"Item\", [effect]);\n    }\n  }\n  else { \n    for ( const t of canvas.tokens.controlled) {\n      await t.actor.createEmbeddedDocuments(\"Item\", [effect]);\n    }\n  }\n}\n\n\nlet content = `\n<style>\n  .cond-cont {\n   margin: 1px auto;\n   column-count: 3;\n   column-width: 100px;\n   background: url(systems/pf2e/assets/sheet/background.webp);\n  }\n\n  .cond-buttons-pd, .cond-buttons-pd:focus {\n    margin: 1px auto;\n    height: fit-content;\n    background: var(--secondary);\n    box-shadow: inset 0 0 0 1px rgb(0 0 0 / 50%);\n    border: #000;\n    color: #fff;\n  }\n\n  .cond-buttons, .cond-buttons:focus {\n    margin: 1px auto;\n    width: 70%;\n    height: fit-content;\n    background: var(--secondary);\n    box-shadow: inset 0 0 0 1px rgb(0 0 0 / 50%);\n    text-shadow: none;\n    border: #000;\n    color: #fff;\n  }\n\n  .cond-buttons-small, .cond-buttons-small:focus {\n    margin: 1px;\n    width: 13%;\n  }\n\n  .cond-buttons:hover {\n    background-color:var(--secondary);\n    text-shadow: 0 0 2px #fff;\n  }\n\n  .cond-buttons-small:hover {\n    background-color:var(--secondary);\n    text-shadow: 0 0 2px #fff;\n  }\n\n  .cond-buttons-pd:hover {\n    background-color:var(--secondary);\n    text-shadow: 0 0 2px #fff;\n  }\n\n\n\n</style><script>${script1}${script2}${script3}${script4}${script5}${script6}</script><div class=\"cond-cont\">`\n\nObject.keys(condition_list).forEach((c,i) => {\n    if (wV.includes(c)) {\n     content += `<div class=\"cond-butt-set\"><button name=\"button${i}\" class=\"cond-buttons ${i}\" type=\"button\" onclick=\"CToggle('${c}')\">${game.i18n.localize(condition_list[c])}</button><button name=\"button${i}+\" class=\"cond-buttons cond-buttons-small ${i}+\" type=\"button\" onclick=\"ICon('${c}')\">+</button><button name=\"button${i}-\" class=\"cond-buttons cond-buttons-small ${i}-\" type=\"button\" onclick=\"DCon('${c}')\">-</button></div> `;\n    }\n    else {\n     if ( c === \"persistent-damage\" ) { \n\t  content += `<button name=\"button${i}\" class=\"cond-buttons-pd\" type=\"button\" onclick=\"game.pf2e.gm.editPersistent({actors:canvas.tokens.controlled?.map((t) => t.actor)})\">Persistent Damage</button> `\n     }\n     else{\n       content += `<button name=\"button${i}\" class=\"cond-buttons ${i}\" type=\"button\" onclick=\"CToggle('${c}')\">${game.i18n.localize(condition_list[c])}</button> `;\n    }\n  }\n});\n\ncontent += `<button name=\"button-timed\" class=\"cond-buttons timed\" type=\"button\" onclick=\"TCon()\">Timed Condition</button> \n<button name=\"button-clear\" class=\"cond-buttons clear\" type=\"button\" onclick=\"CCon()\">Clear a condition</button>\n<button name=\"button-clear-all\" class=\"cond-buttons clear-all\" type=\"button\" onclick=\"CConAll()\">Clear all Conditions</button></div>`\n\nawait new Promise(async (resolve) => {\n    setTimeout(resolve,200);\n await new Dialog({\n    title:\"Conditions Manager\",\n    content,\n    close: () => { return },\n    buttons:{ Close: { label: \"Close\" } },\n    },{width: 600}).render(true);\n});\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Conditions Manager.js\" - Fetched on 2024-06-05T17:22:21.768Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Conditions Manager","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"xBfrpJvVyYXmQ0wp","actorIds":[],"author":"19Q0wZcXmf5GnXVL","command":"/** This macro generates a roll prompt for the Wizard Feat Explosive Arrival - It prompts the user for the used Spell Rank and Damage trait, then posts the roll to the chat. Feel free to make changes or improve as you see fit.*/\r\n\r\nawait Dialog.prompt({\r\n    title: 'Explosive Arrival',\r\n    content: `\r\n\t<div class=\"form-group\">\r\n          <label for=\"spellRank\">Spell Rank</label>\r\n          <select name=\"spellRank\">\r\n            <option value=\"1\">1</option>\r\n            <option value=\"2\">2</option>\r\n            <option value=\"3\">3</option>\r\n            <option value=\"4\">4</option>\r\n            <option value=\"5\">5</option>\r\n\t    <option value=\"6\">6</option>\r\n\t    <option value=\"7\">7</option>\r\n\t    <option value=\"8\">8</option>\r\n\t    <option value=\"9\">9</option>\r\n\t    <option value=\"10\">10</option>\r\n          </select>\r\n        </div>\r\n        <div class=\"form-group\">\r\n          <label for=\"damageTrait\">Damage Trait</label>\r\n          <select name=\"damageTrait\">\r\n            <option value=\"fire\">Fire</option>\r\n            <option value=\"cold\">Cold</option>\r\n            <option value=\"electricity\">Electricity</option>\r\n            <option value=\"sonic\">Sonic</option>\r\n            <option value=\"spirit\">Spirit</option>\r\n          </select>\r\n        </div>\r\n    `,\r\n        callback: async(html) => {\r\n          let sr = html.find('[name=\"spellRank\"]').val();\r\n\t  let dt = html.find('[name=\"damageTrait\"]').val();\r\n          ChatMessage.create({\r\n             content: `@Damage[` + sr + `d4[` + dt + `]]{Explosive Arrival (Spell Rank ` + sr + ' - ' + dt + `)}`\r\n});\r\n    }\r\n})\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/Contributions by others/Explosive Arrival.js\" - Fetched on 2024-06-05T17:22:21.776Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Explosive Arrival","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"y5UyhffNEQUKR0sx","actorIds":[],"author":"eYw3uSQhiLHRUDnY","command":"const options = [\n    {name: \"Demoralize\", value: \"demoralize\"},\n    {name: \"Make an Impression\", value: \"makeAnImpression\"},\n    {name: \"Impersonate\", value: \"impersonate\"}\n];\n\nlet myContent = `\n        <div class=\"form-group\">\n          <label for=\"exampleSelect\">Action being used</label>\n          <select id=\"exampleSelect\">`\n\nfor (i = 0; i < options.length; i++){\n  myContent += `\n                <option value=\"${options[i].value}\">${options[i].name}</option>`\n};\n\nmyContent += `\n          </select>\n        </div>`\n\nconst select = await Dialog.prompt({\n    title: 'Versatile Performance',\n    content: myContent,\n        callback: async(html) => {\n          return html.find('#exampleSelect').val();\n    },\n    rejectClose: false,\n});\nif ( select === null ) { return }\ngame.pf2e.actions[select]({skill:\"performance\"});\n\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Versatile Performance.js\" - Fetched on 2024-06-05T17:22:21.773Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Versatile Performance","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"yt3viTCMfg1ARuz9","actorIds":[],"author":"TodWHFfeapj03Nhg","command":"/*\nSimple Wand/Scroll Generator\nInput Type, Rank, Tradition, Quantity, Rarity, Output Type, and Mystification.\nThis will also create useable Specialty Wands for:\n* Wand of Continuation\n* Wand of LegerDemain\n* Wand of Reaching\n* Wand of Widening\n\nHit Ok and it will generate output.\n\nWhen Generated Loot Actor is selected it will create a loot actor named Generated Loot if not available then populate this actor. If the actor is already available, it will populate the actor.\nWhen Party Actor or Existing Loot Actor are selected, if only one actor of that type is available, it will populate that actor. If more are available another dialog will prompt for an actor choice.\n*/\n\nWSGenerator();\n\nasync function WSGenerator() {\n    const wandIds = {\n        1: \"UJWiN0K3jqVjxvKk\",\n        2: \"vJZ49cgi8szuQXAD\",\n        3: \"wrDmWkGxmwzYtfiA\",\n        4: \"Sn7v9SsbEDMUIwrO\",\n        5: \"5BF7zMnrPYzyigCs\",\n        6: \"kiXh4SUWKr166ZeM\",\n        7: \"nmXPj9zuMRQBNT60\",\n        8: \"Qs8RgNH6thRPv2jt\",\n        9: \"Fgv722039TVM5JTc\"\n    };\n\n    const scrollIds = {\n        1: 'RjuupS9xyXDLgyIr', // Compendium.pf2e.equipment-srd.Item.RjuupS9xyXDLgyIr\n        2: 'Y7UD64foDbDMV9sx',\n        3: 'ZmefGBXGJF3CFDbn',\n        4: 'QSQZJ5BC3DeHv153',\n        5: 'tjLvRWklAylFhBHQ',\n        6: '4sGIy77COooxhQuC',\n        7: 'fomEZZ4MxVVK3uVu',\n        8: 'iPki3yuoucnj7bIt',\n        9: 'cFHomF3tty8Wi1e5',\n        10: 'o1XIHJ4MJyroAHfF',\n    };\n\n    const specWandsUUIDs = {\n        cont: {\n            1: \"Compendium.pf2e.equipment-srd.Item.a60NH7OztaEaGlU8\",\n            2: \"Compendium.pf2e.equipment-srd.Item.5V9bgqgQY1CHLd40\",\n            3: \"Compendium.pf2e.equipment-srd.Item.R88HWv9rw1VNMRer\",\n            4: \"Compendium.pf2e.equipment-srd.Item.bCsdAkffuk29ssUg\",\n            5: \"Compendium.pf2e.equipment-srd.Item.tDEi3zLVpxwA74qz\",\n            6: \"Compendium.pf2e.equipment-srd.Item.35rLqxDWgiDIkL8e\",\n            7: \"Compendium.pf2e.equipment-srd.Item.H1XGrl6Z0bzXN2oi\",\n            8: \"Compendium.pf2e.equipment-srd.Item.KMqHzKfpPq5H8GOo\",\n        },\n        reach: {\n            1: \"Compendium.pf2e.equipment-srd.Item.cyw2OgL4XJ9HOu0b\",\n            2: \"Compendium.pf2e.equipment-srd.Item.rmbvBjcDMDAZLJ7v\",\n            3: \"Compendium.pf2e.equipment-srd.Item.AzLEUTp4RHYAoXIe\",\n            4: \"Compendium.pf2e.equipment-srd.Item.XgKwydoro5eaIWC8\",\n            5: \"Compendium.pf2e.equipment-srd.Item.dPwRgQKEFLLDF2iB\",\n            6: \"Compendium.pf2e.equipment-srd.Item.pCr0zPdJoXZW3I6y\",\n            7: \"Compendium.pf2e.equipment-srd.Item.qeLAYEwUXNbri5eB\",\n            8: \"Compendium.pf2e.equipment-srd.Item.eFGpWmM8ehW9mkI4\",\n            9: \"Compendium.pf2e.equipment-srd.Item.sa9UGUMWYiZkTPjA\",\n        },\n        wide: {\n            1: \"Compendium.pf2e.equipment-srd.Item.Zw3BKaJYxxxzNZ0f\",\n            2: \"Compendium.pf2e.equipment-srd.Item.qmWlvoIlJRJ6pAeG\",\n            3: \"Compendium.pf2e.equipment-srd.Item.TJaumkbZy11sIAgR\",\n            4: \"Compendium.pf2e.equipment-srd.Item.zYRzgETeR1Hs1ti1\",\n            5: \"Compendium.pf2e.equipment-srd.Item.TGxZ3acyWjjTvfU9\",\n            6: \"Compendium.pf2e.equipment-srd.Item.JDQ4jqp6O8SurQGe\",\n            7: \"Compendium.pf2e.equipment-srd.Item.kNfdGNIGzF0fW7aq\",\n            8: \"Compendium.pf2e.equipment-srd.Item.20nQTcGzpUv8jJ6R\",\n            9: \"Compendium.pf2e.equipment-srd.Item.t5978mZ6CqfUDCP6\",\n        },\n        leger: {\n            1: \"Compendium.pf2e.equipment-srd.Item.z2QXO8vl0VsXaI1E\",\n            2: \"Compendium.pf2e.equipment-srd.Item.zaJ4HSNa6kMozYvM\",\n            3: \"Compendium.pf2e.equipment-srd.Item.XPqKEI246hsr9R6P\",\n            4: \"Compendium.pf2e.equipment-srd.Item.4hsPZ6rBpLKOlDjm\",\n            5: \"Compendium.pf2e.equipment-srd.Item.pdsepgrBRgdZ4DWm\",\n            6: \"Compendium.pf2e.equipment-srd.Item.dn53uqBi6MXg2gIM\",\n            7: \"Compendium.pf2e.equipment-srd.Item.AYIel6a1nARjqygh\",\n            8: \"Compendium.pf2e.equipment-srd.Item.34D6lFZ2gpZiyUU6\",\n            9: \"Compendium.pf2e.equipment-srd.Item.qoNaajuoAnKRrFyb\",\n        },\n    }\n\n    const picks = await Dialog.wait({\n        title: \"Wand and Scroll Generator\",\n        content: `\n            <table>\n                <tr>\n                    <th style=\"text-align:center\">Type:</th>\n                    <td width=\"20%\"><select id=\"type\" autofocus>\n                        <option value=\"scroll\">Scroll</option>\n                        <option value=\"wand\">Wand</option>\n                        <option value=\"cont\">Wand of Continuation</option>\n                        <option value=\"leger\">Wand of Legerdemain</option>\n                        <option value=\"reach\">Wand of Reaching</option>\n                        <option value =\"wide\">Wand of Widening</option>\n                    </select></td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Spell Rank:</th>\n                    <td>\n                        <select id=\"level\">\n                            <option>1</option>\n                            <option>2</option>\n                            <option>3</option>\n                            <option>4</option>\n                            <option>5</option>\n                            <option>6</option>\n                            <option>7</option>\n                            <option>8</option>\n                            <option>9</option>\n                            <option>10</option>\n                    </td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Tradition:</th>\n                    <td>\n                        <select id=\"trad\">\n                            <option value=\"random\">Random</option>\n                            <option value=\"arcane\">Arcane</option>\n                            <option value=\"divine\">Divine</option>\n                            <option value=\"occult\">Occult</option>\n                            <option value=\"primal\">Primal</option>\n                    </td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Quantity:</th>\n                    <td><input style=\"text-align:center\" type=\"number\" id=\"quantity\" value=1 /></td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Rarity:</th>\n                    <td><select id=\"rarity\">\n                        <option value=\"any\">Any</option>\n                        <option value=\"common\">Common</option>\n                        <option value=\"uncommon\">Uncommon</option>\n                        <option value=\"rare\">Rare</option>\n                    </select></td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Output Type:</th>\n                    <td><select id=\"outtype\">\n                        <option>Party Actor</option>\n                        <option>Existing Loot Actor</option>\n                        <option>Generated Loot Actor</option>\n                        <option>Message</option>\n                    </select></td>\n                </tr>\n                <tr>\n                    <th style=\"text-align:center\">Mystify?</th>\n                    <td><input type=\"checkbox\" id=\"mystify\" checked /></td>\n                </tr>\n            </table>    \n        `,\n        buttons: {\n            ok: {\n                label: \"Ok\",\n                callback: (html) => { \n                    WSGenerator();\n                    return [ html[0].querySelector(\"#type\").value, parseInt(html[0].querySelector(\"#level\").value), html[0].querySelector(\"#quantity\").valueAsNumber, html[0].querySelector(\"#rarity\").value, html[0].querySelector(\"#outtype\").value, html[0].querySelector(\"#mystify\").checked, html[0].querySelector(\"#trad\").value ] },\n            },\n            close: {\n                label: \"Close\",\n            }\n        },\n        close: () => { return \"close\" },\n        default: \"ok\",\n    },{width:\"auto\"});\n    if (picks === \"close\") { return }\n    if ( picks[1] > 10 ) { return ui.notifications.info(\"There are no spells above rank 10\") }\n    if ( picks[0] === \"cont\" && picks[1] > 8 ) { return ui.notifications.info (\"There are no wands of continuation for spells above rank 8\")}\n    if ( picks[0] !== \"scroll\" && picks[1] > 9 ) { return ui.notifications.info(\"There are no wands for spells above rank 9\") }\n    if ( picks[1] === NaN || picks[2] === NaN || picks[1] < 1 || picks[2] < 1) { return ui.notifications.warn(\"Rank must be a value between 1 and 10 and Quantity must be a value greater than 1!\")}\n\n    const quantity = new Array.fromRange(picks[2]);\n    let spells = [];\n    const compendiums = [\"pf2e.spells-srd\",/*\"pf2e-expansion-pack.Expansion-Spells\"*/];\n    const aCSpells = game.packs.filter(c => compendiums.includes(c.collection));\n    for (const s of aCSpells) {\n        const index = (await s.getIndex({fields: [\"system.level.value\",\"system.slug\",\"system.traits\",\"system.ritual\",\"uuid\",\"system.area\",\"system.duration\",\"system.range\",\"system.time\"]})).filter(f => !f.system.traits.value.includes(\"cantrip\") && !(f.system.ritual ??= false) && !f.system.traits.value.includes(\"focus\") && f.system.level.value === picks[1] );\n        index.forEach( x => {\n            x.compendium = s.collection;\n            spells.push(x);\n        });\n        if ( picks[3] !== \"any\" ) { spells = spells.filter(r => r.system.traits.rarity === picks[3]) }\n        if ( picks[6] !== \"random\" ) { spells = spells.filter(r => r.system.traits.traditions.includes(picks[6])) }\n    }\n\n    if ( spells.length < 1 ) { return ui.notifications.info(`There are no ${picks[3]} spells at rank ${picks[1]}`)}\n\n    const output = [];\n    for ( const q of quantity ) {\n        const randomSpell = spells[Math.floor(Math.random() * spells.length)];\n        if ( picks[0] === \"scroll\" ){\n            output.push({ name: `Scroll of ${randomSpell.name} (Rank ${picks[1]})`, uuid: randomSpell.uuid, sid: scrollIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${scrollIds[picks[1]]}`});\n        }\n        if ( picks[0] === \"wand\" ){\n            output.push({ name: `Wand of ${randomSpell.name} (Rank ${picks[1]})`, uuid: randomSpell.uuid, sid: wandIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[picks[1]]}`});\n        }\n        if ( picks[0] === \"wide\" ){\n            spells = spells.filter( f => f.system.duration.value === \"\" && ((f.system.area?.value > 10 && f.system.area?.type === \"burst\") || (f.system.area?.type === \"cone\" || f.system.area?.type === \"line\")) && (f.system.time.value === \"1\" || f.system.time.value === \"2\") );\n            if ( spells.length === 0 ) { return ui.notifications.info(\"No spells available within these parameters for a Wand of Widening\") }\n            const rSpell = spells[Math.floor(Math.random() * spells.length)];\n            output.push({ name: `Wand of Widening ${rSpell.name} (Rank ${picks[1]})`, uuid: rSpell.uuid, sid: wandIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[picks[1]]}`, sWUUID: specWandsUUIDs[picks[0]][picks[1]]});\n        }\n        if ( picks[0] === \"cont\" ){\n            spells = spells.filter( f => (f.system.duration.value === \"10 minutes\" || f.system.duration.value === \"1 hour\") && (f.system.time?.value === \"1\" || f.system.time?.value === \"2\") );\n            if ( spells.length === 0 ) { return ui.notifications.info(\"No spells available within these parameters for a Wand of Continuation\") }\n            const rSpell = spells[Math.floor(Math.random() * spells.length)];\n            output.push({ name: `Wand of Continuation ${rSpell.name} (Rank ${picks[1]})`, uuid: rSpell.uuid, sid: wandIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[picks[1]]}`, sWUUID: specWandsUUIDs[picks[0]][picks[1]]});\n        }\n        if ( picks[0] === \"reach\" ){\n            spells = spells.filter( f =>  f.system.range?.value.includes(\"feet\" || \"touch\") && (f.system.time?.value === \"1\" || f.system.time?.value === \"2\") );\n            if ( spells.length === 0 ) { return ui.notifications.info(\"No spells available within these parameters for a Wand of Reaching\") }\n            const rSpell = spells[Math.floor(Math.random() * spells.length)];\n            output.push({ name: `Wand of Reaching ${rSpell.name} (Rank ${picks[1]})`, uuid: rSpell.uuid, sid: wandIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[picks[1]]}`, sWUUID: specWandsUUIDs[picks[0]][picks[1]]});\n        }\n        if ( picks[0] === \"leger\" ) {\n            output.push({ name: `Wand of Legerdemain ${randomSpell.name} (Rank ${picks[1]})`, uuid: randomSpell.uuid, sid: wandIds[picks[1]], sc: \"pf2e.equipment-srd\", level: picks[1], scrollUUID: `Compendium.pf2e.equipment-srd.Item.${wandIds[picks[1]]}`, sWUUID: specWandsUUIDs[picks[0]][picks[1]]});\n        }\n    }\n\n    if ( picks[4] === \"Message\" ) {\n            let content = \"\";\n            for ( const o of output ) {\n                content += `<p>@UUID[${o.uuid}]</p>`\n            }\n            let item = picks[0];\n            if ( item === \"leger\" ) item = \"wand of legerdemain\";\n            if ( item === \"reach\" ) item = \"wand of reaching\";\n            if ( item === \"cont\" ) item = \"wand of continuation\";\n            if ( item === \"wide\" ) item = \"wand of widening\";\n            await ChatMessage.create({flavor: `<strong>Random ${item}</strong><br>`,content, speaker: {alias:'GM'}, whisper:[game.user.id]});\n            ui.notifications.info(\"Check chat message. Hold alt when dragging and dropping to mystify items\");\n    }\n    else {\n\t\tlet a;\n\t\tif ( picks[4] === \"Generated Loot Actor\" ) {\n\t\t\tif (!game.actors.some( n => n.name === \"Generated Loot\")) {\n\t\t\t\tawait Actor.create({name:\"Generated Loot\",type:\"loot\",img:\"icons/containers/chest/chest-reinforced-steel-red.webp\"});\n\t\t\t}\n\t\t\ta = game.actors.getName(\"Generated Loot\");\n\t\t}\n\t\t\n\t\tif ( picks[4] === \"Party Actor\" ) {\n\t\t\tif ( game.actors.filter( p => p.type === \"party\" ).length > 1 ) {\n\t\t\t\ta = await MyDialog(\"party\");\n\t\t\t}\n\t\t\telse { \n\t\t\t\ta = game.actors.find(p => p.type === \"party\" );\n\t\t\t}\n\t\t}\n\n\t\tif ( picks[4] === \"Existing Loot Actor\" ) {\n\t\t\tif ( game.actors.filter( p => p.type === \"loot\" ).length > 1 ) {\n\t\t\t\ta = await MyDialog(\"loot\");\n\t\t\t}\n\t\t\telse { \n\t\t\t\ta = game.actors.find(p => p.type === \"loot\" );\n\t\t\t}\n\t\t}\n\t\tif ( a === undefined ) { return }\n        const stuff = [];\n        for ( const o of output ) {\n            stuff.push(await createSpellScrollWand(o.scrollUUID, o.uuid, o.level, o.name, o.sWUUID))\n        }\n        const updates = await a.createEmbeddedDocuments(\"Item\",stuff);\n        if ( picks[5] ) { await a.updateEmbeddedDocuments(\"Item\", updates.map(u => ({_id: u.id, \"system.identification.status\": \"unidentified\" }))); }\n        await a.sheet.render(true);\n    }\n\n    async function MyDialog(type) {\n\t\tlet options = \"\";\n\t\tfor (const plac of game.actors.filter( f => f.type === type )) {\n\t\t\toptions += `<option value=${plac.id}>${plac.name}</option>`\n\t\t}\n\t\tconst myac = await Dialog.prompt({\n\t\t\ttitle: `Select ${type} actor`,\n\t\t\tcontent:`\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th width=\"70%\" style=\"text-align:center\">Please select an actor : </th>\n\t\t\t\t\t\t<td width=\"30%\"><select>${options}</select></td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t`,\n\t\t\tcallback: (html) => { return html[0].querySelector(\"select\").value },\n\t\t\trejectClose:false,\n\t\t},{width:\"200px\"});\n\t\treturn game.actors.get(myac);\n\t}\n\n    async function createSpellScrollWand( scrollUUID, uuid, level, name, sWUUID, temp = false ) {\n        const spell = (await fromUuid(uuid))?.toObject();\n        if (!spell) return null;\n        if ( picks[0] === \"reach\" ) {\n            if ( spell.system.range.value !== \"touch\" ) {\n                const split = spell.system.range.value.split(\" \");\n                split[0] = `${parseInt(split[0]) + 30}`;\n                spell.system.range.value = split.join(\" \");\n            }\n            else {\n                spell.system.range.value === \"30 feet\";\n            }\n        }\n        if ( picks[0] === \"wide\" ) {\n            if ( spell.system.area.type === \"burst\" ) {\n                spell.system.area.value += 5;\n            }\n            if ( spell.system.area.type !== \"burst\") {\n                if ( spell.system.area.value > 15 ) {\n                    spell.system.area.value += 10;\n                }\n                else { spell.system.area.value += 5; }\n            }\n        }\n        if ( picks[0] === \"cont\" ) {\n            const split = spell.system.duration.value.split(\" \");\n            split[0] = `${parseInt(split[0]) * 1.5}`;\n            spell.system.duration.value = split.join(\" \");\n        }\n\n        if (level === false) level = spell.system.level.value;\n\n        scrolls = await fromUuid(scrollUUID);\n\n        const scroll = scrolls?.toObject();\n        if (!scroll) return null;\n\n        spell.system.location.heightenedLevel = level;\n        scroll.name = name;\n        scroll.system.temporary = temp;\n        scroll.system.spell = spell;\n        scroll.system.traits.rarity = spell.system.traits.rarity;\n        scroll.system.traits.value = [...new Set(scroll.system.traits.value.concat(spell.system.traits.traditions).concat(spell.system.traits.value))];\n            \n        const sourceId = spell.flags.core?.sourceId;\n        if (sourceId && sWUUID === undefined) scroll.system.description.value = `@UUID[${uuid}]\\n<hr />${scroll.system.description.value}`;\n        if (sWUUID !== undefined) {\n            const w = (await fromUuid(sWUUID)).toObject();\n            scroll.system.description.value = `@UUID[${uuid}]\\n<hr />${w.system.description.value}`;\n            scroll.system.price = w.system.price;\n            if ( picks[0] !== \"leger\" ) {\n                if ( scroll.system.spell.system.time.value === \"2\" ) { scroll.system.spell.system.time.value = \"3\" }\n                if ( scroll.system.spell.system.time.value === \"1\" ) { scroll.system.spell.system.time.value = \"2\" }\n            }\n        }\n        return scroll;\n    }\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Wand and Scroll Generator.js\" - Fetched on 2024-06-05T17:22:21.773Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Wand and Scroll Generator","permission":{"default":1},"scope":"global","type":"script"}
{"_id":"zWfmRaFs6eWjcZiv","actorIds":[],"author":"fWs1jMBc82yfWzJL","command":"/*\n    This Macro creates random encounters using a folder in the actor's tab named \"Random Encounter\".\n    Simply Populate the folder with actors, run the macro and select the NPCs.\n    Or create subfolders and populate those with NPCs.\n    Place the enemies where you want to spawn them as groups.\n    This Macro requires the WarpGate Module.\n    It is recommended to only use this with lower level enemies than the party.\n    Double check your XP budget before starting an encounter.\n*/\n\nif (!game.modules.has(\"warpgate\") || !game.modules.getName(\"warpgate\")?.active) { return void ui.notifications.warn(\"This macro requires the Warpgate Module\"); }\n\nif ( game.folders.filter(x => x.name ===\"Random Encounter\" && x.type === \"Actor\").length > 1 ) { return void ui.notifications.warn(\"You have multiple folders named Random Encounter in the Actors tab\"); }\n\nif ( game.folders.filter(x => x.name ===\"Random Encounter\" && x.type === \"Actor\").length < 1 ) { return void ui.notifications.warn(\"You don't have a folder named Random Encounter in the Actors tab\"); }\n\nlet folder = game.folders.find(x => x.name ===\"Random Encounter\" && x.type === \"Actor\");\nif (folder.children.length > 0) {\n    const folders = folder.children;\n    if ( folders.length > 1 ) {\n        let content = `<div class=\"form-group\">\n            <label for=\"exampleSelect\">Choose subfolder containing NPCs:&nbsp</label>\n            <select id=\"exampleSelect\" autofocus>\n        `;\n        for ( const f of folders ) {\n            content += `<option value=${(f.folder.id)}>${f.folder.name}</option>`\n        }\n        content += \"</select></div>\"\n        folder = await Dialog.prompt({\n            title: \"Select Folder with NPCs\",\n            content,\n            callback: (html) => { return game.folders.get(html.find(\"#exampleSelect\").val()); },\n            rejectClose: false\n        },{width:\"auto\"});\n    }\n    else {\n        folder = folders[0].folder;\n    }\n}\n\nlet npcs = game.actors.filter(f => f.folder?.id === folder.id);\nif (folder.name === \"Random Encounter\" && npcs.length < 1) { return void ui.notifications.warn(\"You have no actors in the Random Ecnounter Folder\")}\nif (folder.name !== \"Random Encounter\" && npcs.length < 1) { return void ui.notifications.warn(`You have no actors in the subfolder ${folder.name} within the Random Ecnounter Folder`)}\n\nlet amount = await Dialog.prompt({\n    title: \"Random Encounter Builder\",\n    content: `<strong>Total Number of Random Enemies:&nbsp</strong> <input id=\"dcinput\" type=\"number\" autofocus style=\"width: 25px;text-align: center;\" value=''>`,\n    rejectClose: false,\n    callback: (html) => { return html.find(\"#dcinput\")[0].valueAsNumber }\n});\nconst size = {\n    tiny: 1,\n    sm: 1,\n    med: 1,\n    lg: 2,\n    huge: 3,\n    grg: 4\n}\n\nconst acn = [];\nwhile (amount > 0 && acn.length < npcs.length) {\n    const npc = npcs[Math.floor(Math.random() * npcs.length)]\n    if ( acn.includes(npc.name) ) { continue }\n    if ( amount <= 0 ) { break }\n    let random = Math.floor(Math.random() * (amount - 1) + 1);\n    acn.push(npc.name);\n    if (npcs.length === 1 || acn.length === npcs.length) { random = amount }\n    amount = amount - random;\n    await warpgate.spawn(npc.name, {token: {height: size[npc.size], width: size[npc.size]}}, {}, {duplicates:random});\n}\n/* # source \"https://gitlab.com/symonsch/my-foundryvtt-macros/-/tree/main/PF2e/Random Encounter Builder.js\" - Fetched on 2024-06-05T17:22:21.771Z */\n                ","flags":{},"img":"icons/svg/trap.svg","name":"XDY DO_NOT_IMPORT Random Encounter Builder","permission":{"default":1},"scope":"global","type":"script"}
